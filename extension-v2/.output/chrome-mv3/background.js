var background=(function(){"use strict";var _e=Object.defineProperty;var Te=(j,S,$)=>S in j?_e(j,S,{enumerable:!0,configurable:!0,writable:!0,value:$}):j[S]=$;var ie=(j,S,$)=>Te(j,typeof S!="symbol"?S+"":S,$);var ne,ae;function j(l){return l==null||typeof l=="function"?{main:l}:l}function S(l){return l&&l.__esModule&&Object.prototype.hasOwnProperty.call(l,"default")?l.default:l}var $={exports:{}},oe=$.exports,J;function le(){return J||(J=1,(function(l,e){(function(r,t){t(l)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:oe,function(r){if(!(globalThis.chrome&&globalThis.chrome.runtime&&globalThis.chrome.runtime.id))throw new Error("This script should only be loaded in a browser extension.");if(globalThis.browser&&globalThis.browser.runtime&&globalThis.browser.runtime.id)r.exports=globalThis.browser;else{const t="The message port closed before a response was received.",f=m=>{const x={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(x).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class d extends WeakMap{constructor(c,u=void 0){super(u),this.createItem=c}get(c){return this.has(c)||this.set(c,this.createItem(c)),super.get(c)}}const p=o=>o&&typeof o=="object"&&typeof o.then=="function",v=(o,c)=>(...u)=>{m.runtime.lastError?o.reject(new Error(m.runtime.lastError.message)):c.singleCallbackArg||u.length<=1&&c.singleCallbackArg!==!1?o.resolve(u[0]):o.resolve(u)},y=o=>o==1?"argument":"arguments",M=(o,c)=>function(h,...E){if(E.length<c.minArgs)throw new Error(`Expected at least ${c.minArgs} ${y(c.minArgs)} for ${o}(), got ${E.length}`);if(E.length>c.maxArgs)throw new Error(`Expected at most ${c.maxArgs} ${y(c.maxArgs)} for ${o}(), got ${E.length}`);return new Promise((I,b)=>{if(c.fallbackToNoCallback)try{h[o](...E,v({resolve:I,reject:b},c))}catch(w){console.warn(`${o} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,w),h[o](...E),c.fallbackToNoCallback=!1,c.noCallback=!0,I()}else c.noCallback?(h[o](...E),I()):h[o](...E,v({resolve:I,reject:b},c))})},R=(o,c,u)=>new Proxy(c,{apply(h,E,I){return u.call(E,o,...I)}});let L=Function.call.bind(Object.prototype.hasOwnProperty);const K=(o,c={},u={})=>{let h=Object.create(null),E={has(b,w){return w in o||w in h},get(b,w,T){if(w in h)return h[w];if(!(w in o))return;let _=o[w];if(typeof _=="function")if(typeof c[w]=="function")_=R(o,o[w],c[w]);else if(L(u,w)){let V=M(w,u[w]);_=R(o,o[w],V)}else _=_.bind(o);else if(typeof _=="object"&&_!==null&&(L(c,w)||L(u,w)))_=K(_,c[w],u[w]);else if(L(u,"*"))_=K(_,c[w],u["*"]);else return Object.defineProperty(h,w,{configurable:!0,enumerable:!0,get(){return o[w]},set(V){o[w]=V}}),_;return h[w]=_,_},set(b,w,T,_){return w in h?h[w]=T:o[w]=T,!0},defineProperty(b,w,T){return Reflect.defineProperty(h,w,T)},deleteProperty(b,w){return Reflect.deleteProperty(h,w)}},I=Object.create(o);return new Proxy(I,E)},a=o=>({addListener(c,u,...h){c.addListener(o.get(u),...h)},hasListener(c,u){return c.hasListener(o.get(u))},removeListener(c,u){c.removeListener(o.get(u))}}),s=new d(o=>typeof o!="function"?o:function(u){const h=K(u,{},{getContent:{minArgs:0,maxArgs:0}});o(h)}),n=new d(o=>typeof o!="function"?o:function(u,h,E){let I=!1,b,w=new Promise(C=>{b=function(P){I=!0,C(P)}}),T;try{T=o(u,h,b)}catch(C){T=Promise.reject(C)}const _=T!==!0&&p(T);if(T!==!0&&!_&&!I)return!1;const V=C=>{C.then(P=>{E(P)},P=>{let F;P&&(P instanceof Error||typeof P.message=="string")?F=P.message:F="An unexpected error occurred",E({__mozWebExtensionPolyfillReject__:!0,message:F})}).catch(P=>{console.error("Failed to send onMessage rejected reply",P)})};return V(_?T:w),!0}),i=({reject:o,resolve:c},u)=>{m.runtime.lastError?m.runtime.lastError.message===t?c():o(new Error(m.runtime.lastError.message)):u&&u.__mozWebExtensionPolyfillReject__?o(new Error(u.message)):c(u)},g=(o,c,u,...h)=>{if(h.length<c.minArgs)throw new Error(`Expected at least ${c.minArgs} ${y(c.minArgs)} for ${o}(), got ${h.length}`);if(h.length>c.maxArgs)throw new Error(`Expected at most ${c.maxArgs} ${y(c.maxArgs)} for ${o}(), got ${h.length}`);return new Promise((E,I)=>{const b=i.bind(null,{resolve:E,reject:I});h.push(b),u.sendMessage(...h)})},A={devtools:{network:{onRequestFinished:a(s)}},runtime:{onMessage:a(n),onMessageExternal:a(n),sendMessage:g.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:g.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},k={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return x.privacy={network:{"*":k},services:{"*":k},websites:{"*":k}},K(m,A,x)};r.exports=f(chrome)}})})($)),$.exports}var ce=le();const U=S(ce);var Q=Object.prototype.hasOwnProperty;function z(l,e){var r,t;if(l===e)return!0;if(l&&e&&(r=l.constructor)===e.constructor){if(r===Date)return l.getTime()===e.getTime();if(r===RegExp)return l.toString()===e.toString();if(r===Array){if((t=l.length)===e.length)for(;t--&&z(l[t],e[t]););return t===-1}if(!r||typeof l=="object"){t=0;for(r in l)if(Q.call(l,r)&&++t&&!Q.call(e,r)||!(r in e)||!z(l[r],e[r]))return!1;return Object.keys(e).length===t}}return l!==l&&e!==e}const ge=new Error("request for lock canceled");var ue=function(l,e,r,t){function f(m){return m instanceof r?m:new r(function(x){x(m)})}return new(r||(r=Promise))(function(m,x){function d(y){try{v(t.next(y))}catch(M){x(M)}}function p(y){try{v(t.throw(y))}catch(M){x(M)}}function v(y){y.done?m(y.value):f(y.value).then(d,p)}v((t=t.apply(l,e||[])).next())})};class me{constructor(e,r=ge){this._value=e,this._cancelError=r,this._queue=[],this._weightedWaiters=[]}acquire(e=1,r=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((t,f)=>{const m={resolve:t,reject:f,weight:e,priority:r},x=Y(this._queue,d=>r<=d.priority);x===-1&&e<=this._value?this._dispatchItem(m):this._queue.splice(x+1,0,m)})}runExclusive(e){return ue(this,arguments,void 0,function*(r,t=1,f=0){const[m,x]=yield this.acquire(t,f);try{return yield r(m)}finally{x()}})}waitForUnlock(e=1,r=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,r)?Promise.resolve():new Promise(t=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),de(this._weightedWaiters[e-1],{resolve:t,priority:r})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const r=this._value;this._value-=e.weight,e.resolve([r,this._newReleaser(e.weight)])}_newReleaser(e){let r=!1;return()=>{r||(r=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const r=this._weightedWaiters[e-1];r&&(r.forEach(t=>t.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let r=this._value;r>0;r--){const t=this._weightedWaiters[r-1];if(!t)continue;const f=t.findIndex(m=>m.priority<=e);(f===-1?t:t.splice(0,f)).forEach((m=>m.resolve()))}}}_couldLockImmediately(e,r){return(this._queue.length===0||this._queue[0].priority<r)&&e<=this._value}}function de(l,e){const r=Y(l,t=>e.priority<=t.priority);l.splice(r+1,0,e)}function Y(l,e){for(let r=l.length-1;r>=0;r--)if(e(l[r]))return r;return-1}var Ae=function(l,e,r,t){function f(m){return m instanceof r?m:new r(function(x){x(m)})}return new(r||(r=Promise))(function(m,x){function d(y){try{v(t.next(y))}catch(M){x(M)}}function p(y){try{v(t.throw(y))}catch(M){x(M)}}function v(y){y.done?m(y.value):f(y.value).then(d,p)}v((t=t.apply(l,e||[])).next())})};class fe{constructor(e){this._semaphore=new me(1,e)}acquire(){return Ae(this,arguments,void 0,function*(e=0){const[,r]=yield this._semaphore.acquire(1,e);return r})}runExclusive(e,r=0){return this._semaphore.runExclusive(()=>e(),1,r)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const B=(ae=(ne=globalThis.browser)==null?void 0:ne.runtime)!=null&&ae.id?globalThis.browser:globalThis.chrome,W=he();function he(){const l={local:D("local"),session:D("session"),sync:D("sync"),managed:D("managed")},e=a=>{const s=l[a];if(s==null){const n=Object.keys(l).join(", ");throw Error(`Invalid area "${a}". Options: ${n}`)}return s},r=a=>{const s=a.indexOf(":"),n=a.substring(0,s),i=a.substring(s+1);if(i==null)throw Error(`Storage key should be in the form of "area:key", but received "${a}"`);return{driverArea:n,driverKey:i,driver:e(n)}},t=a=>a+"$",f=(a,s)=>{const n={...a};return Object.entries(s).forEach(([i,g])=>{g==null?delete n[i]:n[i]=g}),n},m=(a,s)=>a??s??null,x=a=>typeof a=="object"&&!Array.isArray(a)?a:{},d=async(a,s,n)=>{const i=await a.getItem(s);return m(i,(n==null?void 0:n.fallback)??(n==null?void 0:n.defaultValue))},p=async(a,s)=>{const n=t(s),i=await a.getItem(n);return x(i)},v=async(a,s,n)=>{await a.setItem(s,n??null)},y=async(a,s,n)=>{const i=t(s),g=x(await a.getItem(i));await a.setItem(i,f(g,n))},M=async(a,s,n)=>{if(await a.removeItem(s),n!=null&&n.removeMeta){const i=t(s);await a.removeItem(i)}},R=async(a,s,n)=>{const i=t(s);if(n==null)await a.removeItem(i);else{const g=x(await a.getItem(i));[n].flat().forEach(A=>delete g[A]),await a.setItem(i,g)}},L=(a,s,n)=>a.watch(s,n);return{getItem:async(a,s)=>{const{driver:n,driverKey:i}=r(a);return await d(n,i,s)},getItems:async a=>{const s=new Map,n=new Map,i=[];a.forEach(A=>{let k,o;typeof A=="string"?k=A:"getValue"in A?(k=A.key,o={fallback:A.fallback}):(k=A.key,o=A.options),i.push(k);const{driverArea:c,driverKey:u}=r(k),h=s.get(c)??[];s.set(c,h.concat(u)),n.set(k,o)});const g=new Map;return await Promise.all(Array.from(s.entries()).map(async([A,k])=>{(await l[A].getItems(k)).forEach(c=>{const u=`${A}:${c.key}`,h=n.get(u),E=m(c.value,(h==null?void 0:h.fallback)??(h==null?void 0:h.defaultValue));g.set(u,E)})})),i.map(A=>({key:A,value:g.get(A)}))},getMeta:async a=>{const{driver:s,driverKey:n}=r(a);return await p(s,n)},getMetas:async a=>{const s=a.map(g=>{const A=typeof g=="string"?g:g.key,{driverArea:k,driverKey:o}=r(A);return{key:A,driverArea:k,driverKey:o,driverMetaKey:t(o)}}),n=s.reduce((g,A)=>{var k;return g[k=A.driverArea]??(g[k]=[]),g[A.driverArea].push(A),g},{}),i={};return await Promise.all(Object.entries(n).map(async([g,A])=>{const k=await B.storage[g].get(A.map(o=>o.driverMetaKey));A.forEach(o=>{i[o.key]=k[o.driverMetaKey]??{}})})),s.map(g=>({key:g.key,meta:i[g.key]}))},setItem:async(a,s)=>{const{driver:n,driverKey:i}=r(a);await v(n,i,s)},setItems:async a=>{const s={};a.forEach(n=>{const{driverArea:i,driverKey:g}=r("key"in n?n.key:n.item.key);s[i]??(s[i]=[]),s[i].push({key:g,value:n.value})}),await Promise.all(Object.entries(s).map(async([n,i])=>{await e(n).setItems(i)}))},setMeta:async(a,s)=>{const{driver:n,driverKey:i}=r(a);await y(n,i,s)},setMetas:async a=>{const s={};a.forEach(n=>{const{driverArea:i,driverKey:g}=r("key"in n?n.key:n.item.key);s[i]??(s[i]=[]),s[i].push({key:g,properties:n.meta})}),await Promise.all(Object.entries(s).map(async([n,i])=>{const g=e(n),A=i.map(({key:u})=>t(u)),k=await g.getItems(A),o=Object.fromEntries(k.map(({key:u,value:h})=>[u,x(h)])),c=i.map(({key:u,properties:h})=>{const E=t(u);return{key:E,value:f(o[E]??{},h)}});await g.setItems(c)}))},removeItem:async(a,s)=>{const{driver:n,driverKey:i}=r(a);await M(n,i,s)},removeItems:async a=>{const s={};a.forEach(n=>{let i,g;typeof n=="string"?i=n:"getValue"in n?i=n.key:"item"in n?(i=n.item.key,g=n.options):(i=n.key,g=n.options);const{driverArea:A,driverKey:k}=r(i);s[A]??(s[A]=[]),s[A].push(k),g!=null&&g.removeMeta&&s[A].push(t(k))}),await Promise.all(Object.entries(s).map(async([n,i])=>{await e(n).removeItems(i)}))},clear:async a=>{await e(a).clear()},removeMeta:async(a,s)=>{const{driver:n,driverKey:i}=r(a);await R(n,i,s)},snapshot:async(a,s)=>{var g;const i=await e(a).snapshot();return(g=s==null?void 0:s.excludeKeys)==null||g.forEach(A=>{delete i[A],delete i[t(A)]}),i},restoreSnapshot:async(a,s)=>{await e(a).restoreSnapshot(s)},watch:(a,s)=>{const{driver:n,driverKey:i}=r(a);return L(n,i,s)},unwatch(){Object.values(l).forEach(a=>{a.unwatch()})},defineItem:(a,s)=>{const{driver:n,driverKey:i}=r(a),{version:g=1,migrations:A={},onMigrationComplete:k,debug:o=!1}=s??{};if(g<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const c=async()=>{var P;const b=t(i),[{value:w},{value:T}]=await n.getItems([i,b]);if(w==null)return;const _=(T==null?void 0:T.v)??1;if(_>g)throw Error(`Version downgrade detected (v${_} -> v${g}) for "${a}"`);if(_===g)return;o===!0&&console.debug(`[@wxt-dev/storage] Running storage migration for ${a}: v${_} -> v${g}`);const V=Array.from({length:g-_},(F,Z)=>_+Z+1);let C=w;for(const F of V)try{C=await((P=A==null?void 0:A[F])==null?void 0:P.call(A,C))??C,o===!0&&console.debug(`[@wxt-dev/storage] Storage migration processed for version: v${F}`)}catch(Z){throw new we(a,F,{cause:Z})}await n.setItems([{key:i,value:C},{key:b,value:{...T,v:g}}]),o===!0&&console.debug(`[@wxt-dev/storage] Storage migration completed for ${a} v${g}`,{migratedValue:C}),k==null||k(C,g)},u=(s==null?void 0:s.migrations)==null?Promise.resolve():c().catch(b=>{console.error(`[@wxt-dev/storage] Migration failed for ${a}`,b)}),h=new fe,E=()=>(s==null?void 0:s.fallback)??(s==null?void 0:s.defaultValue)??null,I=()=>h.runExclusive(async()=>{const b=await n.getItem(i);if(b!=null||(s==null?void 0:s.init)==null)return b;const w=await s.init();return await n.setItem(i,w),w});return u.then(I),{key:a,get defaultValue(){return E()},get fallback(){return E()},getValue:async()=>(await u,s!=null&&s.init?await I():await d(n,i,s)),getMeta:async()=>(await u,await p(n,i)),setValue:async b=>(await u,await v(n,i,b)),setMeta:async b=>(await u,await y(n,i,b)),removeValue:async b=>(await u,await M(n,i,b)),removeMeta:async b=>(await u,await R(n,i,b)),watch:b=>L(n,i,(w,T)=>b(w??E(),T??E())),migrate:c}}}}function D(l){const e=()=>{if(B.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(B.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const t=B.storage[l];if(t==null)throw Error(`"browser.storage.${l}" is undefined`);return t},r=new Set;return{getItem:async t=>(await e().get(t))[t],getItems:async t=>{const f=await e().get(t);return t.map(m=>({key:m,value:f[m]??null}))},setItem:async(t,f)=>{f==null?await e().remove(t):await e().set({[t]:f})},setItems:async t=>{const f=t.reduce((m,{key:x,value:d})=>(m[x]=d,m),{});await e().set(f)},removeItem:async t=>{await e().remove(t)},removeItems:async t=>{await e().remove(t)},clear:async()=>{await e().clear()},snapshot:async()=>await e().get(),restoreSnapshot:async t=>{await e().set(t)},watch(t,f){const m=x=>{const d=x[t];d!=null&&(z(d.newValue,d.oldValue)||f(d.newValue??null,d.oldValue??null))};return e().onChanged.addListener(m),r.add(m),()=>{e().onChanged.removeListener(m),r.delete(m)}},unwatch(){r.forEach(t=>{e().onChanged.removeListener(t)}),r.clear()}}}class we extends Error{constructor(e,r,t){super(`v${r} migration failed for "${e}"`,t),this.key=e,this.version=r}}const xe={enabled:!0,apiEndpoint:"http://localhost:3002/api",cacheMinutes:5},N=W.defineItem("local:authToken",{fallback:null}),X=W.defineItem("local:refreshToken",{fallback:null}),O=W.defineItem("local:cachedProfile",{fallback:null}),ee=W.defineItem("local:settings",{fallback:xe});async function re(){await N.setValue(null),await X.setValue(null),await O.setValue(null)}async function ye(l){const e=await O.getValue();return e?Date.now()-e.fetchedAt<l:!1}class te extends Error{constructor(e){super(e),this.name="AuthError"}}class se extends Error{constructor(r,t){super(t);ie(this,"status");this.name="APIError",this.status=r}}class ve{async getBaseUrl(){return(await ee.getValue()).apiEndpoint}async request(e,r={}){const t=await this.getBaseUrl(),f=await N.getValue(),m={"Content-Type":"application/json",...f?{Authorization:`Bearer ${f}`}:{},...r.headers},x=await fetch(`${t}${e}`,{...r,headers:m});if(x.status===401){if(await this.refreshAccessToken()){const p=await N.getValue(),v={"Content-Type":"application/json",...p?{Authorization:`Bearer ${p}`}:{},...r.headers},y=await fetch(`${t}${e}`,{...r,headers:v});if(!y.ok){const M=await y.json().catch(()=>({}));throw new se(y.status,M.message||`HTTP ${y.status}`)}return y.json()}throw new te("Session expired - please log in again")}if(!x.ok){const d=await x.json().catch(()=>({}));throw new se(x.status,d.message||`HTTP ${x.status}`)}return x.json()}async refreshAccessToken(){var r,t;const e=await X.getValue();if(!e)return!1;try{const f=await this.getBaseUrl(),m=await fetch(`${f}/auth/v2/refresh`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refreshToken:e}),credentials:"include"});if(!m.ok)return!1;const d=(t=(r=(await m.json()).data)==null?void 0:r.tokens)==null?void 0:t.accessToken;return d&&await N.setValue(d),!!d}catch{return!1}}async login(e){var d,p,v;const r=await this.getBaseUrl(),f=await(await fetch(`${r}/auth/v2/login`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e),credentials:"include"})).json(),m=(d=f.data)!=null&&d.user?{id:f.data.user.id,email:f.data.user.email,firstName:f.data.user.firstName,lastName:f.data.user.lastName,role:f.data.user.role}:void 0,x={success:!!f.success,message:f.message,user:m,accessToken:(v=(p=f.data)==null?void 0:p.tokens)==null?void 0:v.accessToken};return x.success&&x.accessToken&&await N.setValue(x.accessToken),x}async getProfile(){try{return(await this.request("/users/me/profile")).profile??null}catch{return null}}async getCurrentUser(){var e;try{const t=(e=(await this.request("/auth/v2/me")).data)==null?void 0:e.user;return t?{id:t.id,email:t.email,firstName:t.firstName,lastName:t.lastName,role:t.role}:null}catch{return null}}async inferFields(e){try{return(await this.request("/extension/infer-fields",{method:"POST",body:JSON.stringify(e)})).mappings??[]}catch{return[]}}}const q=new ve,be=300*1e3,pe=5,ke=j(()=>{console.log("IntelliFill: Background service worker started");async function l(d,p){try{const v=await q.login({email:d,password:p});if(v.success&&v.user){const y=await q.getProfile();return y&&await O.setValue({profile:y,fetchedAt:Date.now()}),{success:!0,user:v.user}}return{success:!1,error:v.message||"Login failed"}}catch(v){return{success:!1,error:v instanceof Error?v.message:"Login failed"}}}async function e(){return await re(),{success:!0}}async function r(d){try{if(!d&&await ye(be)){const v=await O.getValue();if(v)return{success:!0,profile:v.profile}}const p=await q.getProfile();return p?(await O.setValue({profile:p,fetchedAt:Date.now()}),{success:!0,profile:p}):{success:!1,error:"Failed to fetch profile"}}catch(p){return p instanceof te?(await re(),{success:!1,error:"Session expired - please log in again"}):{success:!1,error:p instanceof Error?p.message:"Failed to fetch profile"}}}async function t(){try{const d=await q.getCurrentUser();return d?{success:!0,user:d}:{success:!1,error:"Failed to fetch user"}}catch(d){return{success:!1,error:d instanceof Error?d.message:"Failed to fetch user"}}}async function f(){return{authenticated:!!await N.getValue()}}async function m(){return await O.setValue(null),{success:!0}}async function x(d,p){try{return{success:!0,mappings:await q.inferFields({fields:d,profileKeys:p})}}catch(v){return{success:!1,error:v instanceof Error?v.message:"Inference failed"}}}U.runtime.onMessage.addListener((d,p,v)=>{const y=d;return console.log("IntelliFill: Received message",y.action),(async()=>{switch(y.action){case"login":return l(y.email,y.password);case"logout":return e();case"getProfile":return r(y.forceRefresh);case"getCurrentUser":return t();case"isAuthenticated":return f();case"clearCache":return m();case"inferFields":return x(y.fields,y.profileKeys)}})().then(v),!0}),U.alarms.create("refreshProfile",{periodInMinutes:pe}),U.alarms.onAlarm.addListener(async d=>{if(d.name==="refreshProfile"){const{authenticated:p}=await f();p&&(console.log("IntelliFill: Periodic profile refresh"),await r(!0))}}),U.runtime.onInstalled.addListener(d=>{d.reason==="install"?(console.log("IntelliFill: Extension installed"),ee.setValue({enabled:!0,apiEndpoint:"http://localhost:3002/api",cacheMinutes:5})):d.reason==="update"&&(console.log("IntelliFill: Extension updated"),O.setValue(null))})});function Me(){}function H(l,...e){}const Ee={debug:(...l)=>H(console.debug,...l),log:(...l)=>H(console.log,...l),warn:(...l)=>H(console.warn,...l),error:(...l)=>H(console.error,...l)};let G;try{G=ke.main(),G instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(l){throw Ee.error("The background crashed on startup!"),l}return G})();
background;
