var background=(function(){"use strict";var Te=Object.defineProperty;var _e=(F,S,$)=>S in F?Te(F,S,{enumerable:!0,configurable:!0,writable:!0,value:$}):F[S]=$;var ie=(F,S,$)=>_e(F,typeof S!="symbol"?S+"":S,$);var ne,ae;function F(l){return l==null||typeof l=="function"?{main:l}:l}function S(l){return l&&l.__esModule&&Object.prototype.hasOwnProperty.call(l,"default")?l.default:l}var $={exports:{}},oe=$.exports,J;function le(){return J||(J=1,(function(l,e){(function(r,n){n(l)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:oe,function(r){if(!(globalThis.chrome&&globalThis.chrome.runtime&&globalThis.chrome.runtime.id))throw new Error("This script should only be loaded in a browser extension.");if(globalThis.browser&&globalThis.browser.runtime&&globalThis.browser.runtime.id)r.exports=globalThis.browser;else{const n="The message port closed before a response was received.",d=A=>{const u={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(u).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class x extends WeakMap{constructor(c,m=void 0){super(m),this.createItem=c}get(c){return this.has(c)||this.set(c,this.createItem(c)),super.get(c)}}const E=o=>o&&typeof o=="object"&&typeof o.then=="function",T=(o,c)=>(...m)=>{A.runtime.lastError?o.reject(new Error(A.runtime.lastError.message)):c.singleCallbackArg||m.length<=1&&c.singleCallbackArg!==!1?o.resolve(m[0]):o.resolve(m)},y=o=>o==1?"argument":"arguments",M=(o,c)=>function(h,...p){if(p.length<c.minArgs)throw new Error(`Expected at least ${c.minArgs} ${y(c.minArgs)} for ${o}(), got ${p.length}`);if(p.length>c.maxArgs)throw new Error(`Expected at most ${c.maxArgs} ${y(c.maxArgs)} for ${o}(), got ${p.length}`);return new Promise((I,v)=>{if(c.fallbackToNoCallback)try{h[o](...p,T({resolve:I,reject:v},c))}catch(w){console.warn(`${o} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,w),h[o](...p),c.fallbackToNoCallback=!1,c.noCallback=!0,I()}else c.noCallback?(h[o](...p),I()):h[o](...p,T({resolve:I,reject:v},c))})},q=(o,c,m)=>new Proxy(c,{apply(h,p,I){return m.call(p,o,...I)}});let L=Function.call.bind(Object.prototype.hasOwnProperty);const K=(o,c={},m={})=>{let h=Object.create(null),p={has(v,w){return w in o||w in h},get(v,w,_){if(w in h)return h[w];if(!(w in o))return;let k=o[w];if(typeof k=="function")if(typeof c[w]=="function")k=q(o,o[w],c[w]);else if(L(m,w)){let V=M(w,m[w]);k=q(o,o[w],V)}else k=k.bind(o);else if(typeof k=="object"&&k!==null&&(L(c,w)||L(m,w)))k=K(k,c[w],m[w]);else if(L(m,"*"))k=K(k,c[w],m["*"]);else return Object.defineProperty(h,w,{configurable:!0,enumerable:!0,get(){return o[w]},set(V){o[w]=V}}),k;return h[w]=k,k},set(v,w,_,k){return w in h?h[w]=_:o[w]=_,!0},defineProperty(v,w,_){return Reflect.defineProperty(h,w,_)},deleteProperty(v,w){return Reflect.deleteProperty(h,w)}},I=Object.create(o);return new Proxy(I,p)},a=o=>({addListener(c,m,...h){c.addListener(o.get(m),...h)},hasListener(c,m){return c.hasListener(o.get(m))},removeListener(c,m){c.removeListener(o.get(m))}}),t=new x(o=>typeof o!="function"?o:function(m){const h=K(m,{},{getContent:{minArgs:0,maxArgs:0}});o(h)}),s=new x(o=>typeof o!="function"?o:function(m,h,p){let I=!1,v,w=new Promise(P=>{v=function(C){I=!0,P(C)}}),_;try{_=o(m,h,v)}catch(P){_=Promise.reject(P)}const k=_!==!0&&E(_);if(_!==!0&&!k&&!I)return!1;const V=P=>{P.then(C=>{p(C)},C=>{let j;C&&(C instanceof Error||typeof C.message=="string")?j=C.message:j="An unexpected error occurred",p({__mozWebExtensionPolyfillReject__:!0,message:j})}).catch(C=>{console.error("Failed to send onMessage rejected reply",C)})};return V(k?_:w),!0}),i=({reject:o,resolve:c},m)=>{A.runtime.lastError?A.runtime.lastError.message===n?c():o(new Error(A.runtime.lastError.message)):m&&m.__mozWebExtensionPolyfillReject__?o(new Error(m.message)):c(m)},g=(o,c,m,...h)=>{if(h.length<c.minArgs)throw new Error(`Expected at least ${c.minArgs} ${y(c.minArgs)} for ${o}(), got ${h.length}`);if(h.length>c.maxArgs)throw new Error(`Expected at most ${c.maxArgs} ${y(c.maxArgs)} for ${o}(), got ${h.length}`);return new Promise((p,I)=>{const v=i.bind(null,{resolve:p,reject:I});h.push(v),m.sendMessage(...h)})},f={devtools:{network:{onRequestFinished:a(t)}},runtime:{onMessage:a(s),onMessageExternal:a(s),sendMessage:g.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:g.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},b={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return u.privacy={network:{"*":b},services:{"*":b},websites:{"*":b}},K(A,f,u)};r.exports=d(chrome)}})})($)),$.exports}var ce=le();const U=S(ce);var Y=Object.prototype.hasOwnProperty;function G(l,e){var r,n;if(l===e)return!0;if(l&&e&&(r=l.constructor)===e.constructor){if(r===Date)return l.getTime()===e.getTime();if(r===RegExp)return l.toString()===e.toString();if(r===Array){if((n=l.length)===e.length)for(;n--&&G(l[n],e[n]););return n===-1}if(!r||typeof l=="object"){n=0;for(r in l)if(Y.call(l,r)&&++n&&!Y.call(e,r)||!(r in e)||!G(l[r],e[r]))return!1;return Object.keys(e).length===n}}return l!==l&&e!==e}const ge=new Error("request for lock canceled");var ue=function(l,e,r,n){function d(A){return A instanceof r?A:new r(function(u){u(A)})}return new(r||(r=Promise))(function(A,u){function x(y){try{T(n.next(y))}catch(M){u(M)}}function E(y){try{T(n.throw(y))}catch(M){u(M)}}function T(y){y.done?A(y.value):d(y.value).then(x,E)}T((n=n.apply(l,e||[])).next())})};class me{constructor(e,r=ge){this._value=e,this._cancelError=r,this._queue=[],this._weightedWaiters=[]}acquire(e=1,r=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((n,d)=>{const A={resolve:n,reject:d,weight:e,priority:r},u=X(this._queue,x=>r<=x.priority);u===-1&&e<=this._value?this._dispatchItem(A):this._queue.splice(u+1,0,A)})}runExclusive(e){return ue(this,arguments,void 0,function*(r,n=1,d=0){const[A,u]=yield this.acquire(n,d);try{return yield r(A)}finally{u()}})}waitForUnlock(e=1,r=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,r)?Promise.resolve():new Promise(n=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),Ae(this._weightedWaiters[e-1],{resolve:n,priority:r})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const r=this._value;this._value-=e.weight,e.resolve([r,this._newReleaser(e.weight)])}_newReleaser(e){let r=!1;return()=>{r||(r=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const r=this._weightedWaiters[e-1];r&&(r.forEach(n=>n.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let r=this._value;r>0;r--){const n=this._weightedWaiters[r-1];if(!n)continue;const d=n.findIndex(A=>A.priority<=e);(d===-1?n:n.splice(0,d)).forEach((A=>A.resolve()))}}}_couldLockImmediately(e,r){return(this._queue.length===0||this._queue[0].priority<r)&&e<=this._value}}function Ae(l,e){const r=X(l,n=>e.priority<=n.priority);l.splice(r+1,0,e)}function X(l,e){for(let r=l.length-1;r>=0;r--)if(e(l[r]))return r;return-1}var fe=function(l,e,r,n){function d(A){return A instanceof r?A:new r(function(u){u(A)})}return new(r||(r=Promise))(function(A,u){function x(y){try{T(n.next(y))}catch(M){u(M)}}function E(y){try{T(n.throw(y))}catch(M){u(M)}}function T(y){y.done?A(y.value):d(y.value).then(x,E)}T((n=n.apply(l,e||[])).next())})};class de{constructor(e){this._semaphore=new me(1,e)}acquire(){return fe(this,arguments,void 0,function*(e=0){const[,r]=yield this._semaphore.acquire(1,e);return r})}runExclusive(e,r=0){return this._semaphore.runExclusive(()=>e(),1,r)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const N=(ae=(ne=globalThis.browser)==null?void 0:ne.runtime)!=null&&ae.id?globalThis.browser:globalThis.chrome,B=he();function he(){const l={local:W("local"),session:W("session"),sync:W("sync"),managed:W("managed")},e=a=>{const t=l[a];if(t==null){const s=Object.keys(l).join(", ");throw Error(`Invalid area "${a}". Options: ${s}`)}return t},r=a=>{const t=a.indexOf(":"),s=a.substring(0,t),i=a.substring(t+1);if(i==null)throw Error(`Storage key should be in the form of "area:key", but received "${a}"`);return{driverArea:s,driverKey:i,driver:e(s)}},n=a=>a+"$",d=(a,t)=>{const s={...a};return Object.entries(t).forEach(([i,g])=>{g==null?delete s[i]:s[i]=g}),s},A=(a,t)=>a??t??null,u=a=>typeof a=="object"&&!Array.isArray(a)?a:{},x=async(a,t,s)=>{const i=await a.getItem(t);return A(i,(s==null?void 0:s.fallback)??(s==null?void 0:s.defaultValue))},E=async(a,t)=>{const s=n(t),i=await a.getItem(s);return u(i)},T=async(a,t,s)=>{await a.setItem(t,s??null)},y=async(a,t,s)=>{const i=n(t),g=u(await a.getItem(i));await a.setItem(i,d(g,s))},M=async(a,t,s)=>{if(await a.removeItem(t),s!=null&&s.removeMeta){const i=n(t);await a.removeItem(i)}},q=async(a,t,s)=>{const i=n(t);if(s==null)await a.removeItem(i);else{const g=u(await a.getItem(i));[s].flat().forEach(f=>delete g[f]),await a.setItem(i,g)}},L=(a,t,s)=>a.watch(t,s);return{getItem:async(a,t)=>{const{driver:s,driverKey:i}=r(a);return await x(s,i,t)},getItems:async a=>{const t=new Map,s=new Map,i=[];a.forEach(f=>{let b,o;typeof f=="string"?b=f:"getValue"in f?(b=f.key,o={fallback:f.fallback}):(b=f.key,o=f.options),i.push(b);const{driverArea:c,driverKey:m}=r(b),h=t.get(c)??[];t.set(c,h.concat(m)),s.set(b,o)});const g=new Map;return await Promise.all(Array.from(t.entries()).map(async([f,b])=>{(await l[f].getItems(b)).forEach(c=>{const m=`${f}:${c.key}`,h=s.get(m),p=A(c.value,(h==null?void 0:h.fallback)??(h==null?void 0:h.defaultValue));g.set(m,p)})})),i.map(f=>({key:f,value:g.get(f)}))},getMeta:async a=>{const{driver:t,driverKey:s}=r(a);return await E(t,s)},getMetas:async a=>{const t=a.map(g=>{const f=typeof g=="string"?g:g.key,{driverArea:b,driverKey:o}=r(f);return{key:f,driverArea:b,driverKey:o,driverMetaKey:n(o)}}),s=t.reduce((g,f)=>{var b;return g[b=f.driverArea]??(g[b]=[]),g[f.driverArea].push(f),g},{}),i={};return await Promise.all(Object.entries(s).map(async([g,f])=>{const b=await N.storage[g].get(f.map(o=>o.driverMetaKey));f.forEach(o=>{i[o.key]=b[o.driverMetaKey]??{}})})),t.map(g=>({key:g.key,meta:i[g.key]}))},setItem:async(a,t)=>{const{driver:s,driverKey:i}=r(a);await T(s,i,t)},setItems:async a=>{const t={};a.forEach(s=>{const{driverArea:i,driverKey:g}=r("key"in s?s.key:s.item.key);t[i]??(t[i]=[]),t[i].push({key:g,value:s.value})}),await Promise.all(Object.entries(t).map(async([s,i])=>{await e(s).setItems(i)}))},setMeta:async(a,t)=>{const{driver:s,driverKey:i}=r(a);await y(s,i,t)},setMetas:async a=>{const t={};a.forEach(s=>{const{driverArea:i,driverKey:g}=r("key"in s?s.key:s.item.key);t[i]??(t[i]=[]),t[i].push({key:g,properties:s.meta})}),await Promise.all(Object.entries(t).map(async([s,i])=>{const g=e(s),f=i.map(({key:m})=>n(m)),b=await g.getItems(f),o=Object.fromEntries(b.map(({key:m,value:h})=>[m,u(h)])),c=i.map(({key:m,properties:h})=>{const p=n(m);return{key:p,value:d(o[p]??{},h)}});await g.setItems(c)}))},removeItem:async(a,t)=>{const{driver:s,driverKey:i}=r(a);await M(s,i,t)},removeItems:async a=>{const t={};a.forEach(s=>{let i,g;typeof s=="string"?i=s:"getValue"in s?i=s.key:"item"in s?(i=s.item.key,g=s.options):(i=s.key,g=s.options);const{driverArea:f,driverKey:b}=r(i);t[f]??(t[f]=[]),t[f].push(b),g!=null&&g.removeMeta&&t[f].push(n(b))}),await Promise.all(Object.entries(t).map(async([s,i])=>{await e(s).removeItems(i)}))},clear:async a=>{await e(a).clear()},removeMeta:async(a,t)=>{const{driver:s,driverKey:i}=r(a);await q(s,i,t)},snapshot:async(a,t)=>{var g;const i=await e(a).snapshot();return(g=t==null?void 0:t.excludeKeys)==null||g.forEach(f=>{delete i[f],delete i[n(f)]}),i},restoreSnapshot:async(a,t)=>{await e(a).restoreSnapshot(t)},watch:(a,t)=>{const{driver:s,driverKey:i}=r(a);return L(s,i,t)},unwatch(){Object.values(l).forEach(a=>{a.unwatch()})},defineItem:(a,t)=>{const{driver:s,driverKey:i}=r(a),{version:g=1,migrations:f={},onMigrationComplete:b,debug:o=!1}=t??{};if(g<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const c=async()=>{var C;const v=n(i),[{value:w},{value:_}]=await s.getItems([i,v]);if(w==null)return;const k=(_==null?void 0:_.v)??1;if(k>g)throw Error(`Version downgrade detected (v${k} -> v${g}) for "${a}"`);if(k===g)return;o===!0&&console.debug(`[@wxt-dev/storage] Running storage migration for ${a}: v${k} -> v${g}`);const V=Array.from({length:g-k},(j,Q)=>k+Q+1);let P=w;for(const j of V)try{P=await((C=f==null?void 0:f[j])==null?void 0:C.call(f,P))??P,o===!0&&console.debug(`[@wxt-dev/storage] Storage migration processed for version: v${j}`)}catch(Q){throw new we(a,j,{cause:Q})}await s.setItems([{key:i,value:P},{key:v,value:{..._,v:g}}]),o===!0&&console.debug(`[@wxt-dev/storage] Storage migration completed for ${a} v${g}`,{migratedValue:P}),b==null||b(P,g)},m=(t==null?void 0:t.migrations)==null?Promise.resolve():c().catch(v=>{console.error(`[@wxt-dev/storage] Migration failed for ${a}`,v)}),h=new de,p=()=>(t==null?void 0:t.fallback)??(t==null?void 0:t.defaultValue)??null,I=()=>h.runExclusive(async()=>{const v=await s.getItem(i);if(v!=null||(t==null?void 0:t.init)==null)return v;const w=await t.init();return await s.setItem(i,w),w});return m.then(I),{key:a,get defaultValue(){return p()},get fallback(){return p()},getValue:async()=>(await m,t!=null&&t.init?await I():await x(s,i,t)),getMeta:async()=>(await m,await E(s,i)),setValue:async v=>(await m,await T(s,i,v)),setMeta:async v=>(await m,await y(s,i,v)),removeValue:async v=>(await m,await M(s,i,v)),removeMeta:async v=>(await m,await q(s,i,v)),watch:v=>L(s,i,(w,_)=>v(w??p(),_??p())),migrate:c}}}}function W(l){const e=()=>{if(N.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(N.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const n=N.storage[l];if(n==null)throw Error(`"browser.storage.${l}" is undefined`);return n},r=new Set;return{getItem:async n=>(await e().get(n))[n],getItems:async n=>{const d=await e().get(n);return n.map(A=>({key:A,value:d[A]??null}))},setItem:async(n,d)=>{d==null?await e().remove(n):await e().set({[n]:d})},setItems:async n=>{const d=n.reduce((A,{key:u,value:x})=>(A[u]=x,A),{});await e().set(d)},removeItem:async n=>{await e().remove(n)},removeItems:async n=>{await e().remove(n)},clear:async()=>{await e().clear()},snapshot:async()=>await e().get(),restoreSnapshot:async n=>{await e().set(n)},watch(n,d){const A=u=>{const x=u[n];x!=null&&(G(x.newValue,x.oldValue)||d(x.newValue??null,x.oldValue??null))};return e().onChanged.addListener(A),r.add(A),()=>{e().onChanged.removeListener(A),r.delete(A)}},unwatch(){r.forEach(n=>{e().onChanged.removeListener(n)}),r.clear()}}}class we extends Error{constructor(e,r,n){super(`v${r} migration failed for "${e}"`,n),this.key=e,this.version=r}}const xe={enabled:!0,apiEndpoint:"http://localhost:3002/api",cacheMinutes:5},R=B.defineItem("local:authToken",{fallback:null}),D=B.defineItem("local:refreshToken",{fallback:null}),O=B.defineItem("local:cachedProfile",{fallback:null}),ee=B.defineItem("local:settings",{fallback:xe});async function re(){await R.setValue(null),await D.setValue(null),await O.setValue(null)}async function ye(l){const e=await O.getValue();return e?Date.now()-e.fetchedAt<l:!1}class te extends Error{constructor(e){super(e),this.name="AuthError"}}class se extends Error{constructor(r,n){super(n);ie(this,"status");this.name="APIError",this.status=r}}class ve{async getBaseUrl(){return(await ee.getValue()).apiEndpoint}async request(e,r={}){const n=await this.getBaseUrl(),d=await R.getValue(),A={"Content-Type":"application/json",...d?{Authorization:`Bearer ${d}`}:{},...r.headers},u=await fetch(`${n}${e}`,{...r,headers:A});if(u.status===401){if(await this.refreshAccessToken()){const E=await R.getValue(),T={"Content-Type":"application/json",...E?{Authorization:`Bearer ${E}`}:{},...r.headers},y=await fetch(`${n}${e}`,{...r,headers:T});if(!y.ok){const M=await y.json().catch(()=>({}));throw new se(y.status,M.message||`HTTP ${y.status}`)}return y.json()}throw new te("Session expired - please log in again")}if(!u.ok){const x=await u.json().catch(()=>({}));throw new se(u.status,x.message||`HTTP ${u.status}`)}return u.json()}async refreshAccessToken(){const e=await D.getValue();if(!e)return!1;try{const r=await this.getBaseUrl(),n=await fetch(`${r}/auth/v2/refresh`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refreshToken:e})});if(!n.ok)return!1;const d=await n.json();return d.accessToken&&await R.setValue(d.accessToken),d.refreshToken&&await D.setValue(d.refreshToken),!0}catch{return!1}}async login(e){const r=await this.getBaseUrl(),d=await(await fetch(`${r}/auth/v2/login`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)})).json();return d.success&&d.accessToken&&(await R.setValue(d.accessToken),d.refreshToken&&await D.setValue(d.refreshToken)),d}async getProfile(){try{return(await this.request("/users/me/profile")).profile??null}catch{return null}}async getCurrentUser(){try{return(await this.request("/users/me")).user??null}catch{return null}}}const H=new ve,be=300*1e3,pe=5,ke=F(()=>{console.log("IntelliFill: Background service worker started");async function l(u,x){try{const E=await H.login({email:u,password:x});if(E.success&&E.user){const T=await H.getProfile();return T&&await O.setValue({profile:T,fetchedAt:Date.now()}),{success:!0,user:E.user}}return{success:!1,error:E.message||"Login failed"}}catch(E){return{success:!1,error:E instanceof Error?E.message:"Login failed"}}}async function e(){return await re(),{success:!0}}async function r(u){try{if(!u&&await ye(be)){const E=await O.getValue();if(E)return{success:!0,profile:E.profile}}const x=await H.getProfile();return x?(await O.setValue({profile:x,fetchedAt:Date.now()}),{success:!0,profile:x}):{success:!1,error:"Failed to fetch profile"}}catch(x){return x instanceof te?(await re(),{success:!1,error:"Session expired - please log in again"}):{success:!1,error:x instanceof Error?x.message:"Failed to fetch profile"}}}async function n(){try{const u=await H.getCurrentUser();return u?{success:!0,user:u}:{success:!1,error:"Failed to fetch user"}}catch(u){return{success:!1,error:u instanceof Error?u.message:"Failed to fetch user"}}}async function d(){return{authenticated:!!await R.getValue()}}async function A(){return await O.setValue(null),{success:!0}}U.runtime.onMessage.addListener((u,x,E)=>{const T=u;return console.log("IntelliFill: Received message",T.action),(async()=>{switch(T.action){case"login":return l(T.email,T.password);case"logout":return e();case"getProfile":return r(T.forceRefresh);case"getCurrentUser":return n();case"isAuthenticated":return d();case"clearCache":return A()}})().then(E),!0}),U.alarms.create("refreshProfile",{periodInMinutes:pe}),U.alarms.onAlarm.addListener(async u=>{if(u.name==="refreshProfile"){const{authenticated:x}=await d();x&&(console.log("IntelliFill: Periodic profile refresh"),await r(!0))}}),U.runtime.onInstalled.addListener(u=>{u.reason==="install"?(console.log("IntelliFill: Extension installed"),ee.setValue({enabled:!0,apiEndpoint:"http://localhost:3002/api",cacheMinutes:5})):u.reason==="update"&&(console.log("IntelliFill: Extension updated"),O.setValue(null))})});function Me(){}function z(l,...e){}const Ee={debug:(...l)=>z(console.debug,...l),log:(...l)=>z(console.log,...l),warn:(...l)=>z(console.warn,...l),error:(...l)=>z(console.error,...l)};let Z;try{Z=ke.main(),Z instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(l){throw Ee.error("The background crashed on startup!"),l}return Z})();
background;
