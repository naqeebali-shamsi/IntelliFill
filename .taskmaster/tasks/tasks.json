{
  "master": {
    "tasks": [
      {
        "id": "187",
        "title": "Implement JWT Secret Startup Validation",
        "description": "Add startup validation in backend config to check for JWT_SECRET and JWT_REFRESH_SECRET environment variables, fail hard if missing with clear error message and exit code 1 (REQ-004)",
        "details": "In quikadmin/src/config/index.ts, add validation function using process.env checks. Use crypto.randomBytes(64).toString('hex') as example in error message. Remove all hardcoded fallbacks from supabase-auth.routes.ts. Ensure cookie-parser@^1.4.6 is installed for cookie handling. Implementation:\n```typescript\nconst validateJWTSecrets = () => {\n  const required = ['JWT_SECRET', 'JWT_REFRESH_SECRET'];\n  for (const key of required) {\n    if (!process.env[key] || process.env[key].length < 64) {\n      console.error(`FATAL: ${key} not set or too short. Set ${key}=<64+ char random string like ${crypto.randomBytes(64).toString('hex').slice(0,32)}...>`);\n      process.exit(1);\n    }\n  }\n};\nvalidateJWTSecrets();\n``` Call at app startup before routes. Update .env.example with both vars.",
        "testStrategy": "Unit test config validation: mock missing env vars → expect exit(1) and correct error message. Integration test: start server without env vars → verify crash with correct log. Test with valid 64+ char secrets → server starts successfully.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add JWT secrets validation function to config",
            "description": "Create validateJWTSecrets function in quikadmin/src/config/index.ts that checks for JWT_SECRET and JWT_REFRESH_SECRET environment variables",
            "dependencies": [],
            "details": "Implement the provided code snippet using process.env checks and crypto.randomBytes(64).toString('hex') for error message example. Ensure function validates length >= 64 characters.",
            "status": "pending",
            "testStrategy": "Unit test: mock missing/invalid env vars → verify console.error called and process.exit(1) triggered",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Call validation function at app startup",
            "description": "Invoke validateJWTSecrets() at the earliest point in app startup before any routes are registered",
            "dependencies": [1],
            "details": "Add validateJWTSecrets(); call in the main server startup sequence, ideally right after environment loading but before express app initialization and route mounting.",
            "status": "pending",
            "testStrategy": "Integration test: start server without env vars → verify immediate crash with exit code 1 and correct error message",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Remove hardcoded JWT fallbacks from routes",
            "description": "Eliminate all hardcoded JWT secret fallbacks from supabase-auth.routes.ts file",
            "dependencies": [1],
            "details": "Search for and remove any default/fallback JWT_SECRET or JWT_REFRESH_SECRET values in supabase-auth.routes.ts. Ensure the app now strictly requires environment variables.",
            "status": "pending",
            "testStrategy": "Code review: verify no hardcoded secrets remain. Test startup without env vars → confirm proper validation failure",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Install and configure cookie-parser dependency",
            "description": "Add cookie-parser@^1.4.6 to package.json and ensure it's properly imported for cookie handling",
            "dependencies": [],
            "details": "Run npm install cookie-parser@^1.4.6. Verify it's imported and initialized in the main express app with app.use(cookieParser()).",
            "status": "pending",
            "testStrategy": "Verify package.json includes correct version. Test cookie reading in auth routes → confirm req.cookies works correctly",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update .env.example with required JWT variables",
            "description": "Add JWT_SECRET and JWT_REFRESH_SECRET entries to .env.example with generation instructions",
            "dependencies": [1],
            "details": "Include both variables in .env.example file with comments explaining they must be 64+ character random strings generated via crypto.randomBytes(64).toString('hex').",
            "status": "pending",
            "testStrategy": "Manual verification: check .env.example contains both vars with proper instructions and example generation command",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T11:23:18.134Z"
      },
      {
        "id": "188",
        "title": "Standardize localStorage Keys and Add Migration",
        "description": "Consolidate all localStorage keys to 'intellifill-backend-auth' and add one-time migration from old keys (REQ-002)",
        "details": "In stores/index.ts and migrationUtils.ts, standardize to single key. Add migration logic:\n```typescript\nconst migrateAuthStorage = () => {\n  const oldKeys = ['intellifill-auth', 'auth-storage'];\n  const newKey = 'intellifill-backend-auth';\n  for (const oldKey of oldKeys) {\n    if (localStorage.getItem(oldKey)) {\n      localStorage.setItem(newKey, localStorage.getItem(oldKey)!);\n      localStorage.removeItem(oldKey);\n    }\n  }\n  localStorage.removeItem('migration-complete');\n};\n// Call once on first app load\nif (!localStorage.getItem('migration-complete')) {\n  migrateAuthStorage();\n  localStorage.setItem('migration-complete', 'true');\n}\n``` Update all cleanup/export functions to use new key. Remove refreshToken from Zustand partialize.",
        "testStrategy": "Unit tests: simulate old keys → verify migration to new key and cleanup. E2E test: populate old keys → reload → verify data in new key only. Test idempotency: run migration twice → no data loss.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create migrationUtils.ts with migrateAuthStorage function",
            "description": "Implement the migration logic to copy data from old keys to new key and clean up old keys.",
            "dependencies": [],
            "details": "Create migrationUtils.ts file with the provided migrateAuthStorage function that handles oldKeys ['intellifill-auth', 'auth-storage'] to 'intellifill-backend-auth'. Include removal of 'migration-complete' flag. Ensure safe handling with null checks.",
            "status": "pending",
            "testStrategy": "Unit test: mock localStorage with old keys → verify data copied to new key and old keys removed.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add one-time migration trigger in app initialization",
            "description": "Call migration logic once on first app load using migration-complete flag.",
            "dependencies": [1],
            "details": "In stores/index.ts or main app entry, add the check: if (!localStorage.getItem('migration-complete')) { migrateAuthStorage(); localStorage.setItem('migration-complete', 'true'); }. Place at earliest app initialization point.",
            "status": "pending",
            "testStrategy": "Unit test: simulate first load → verify migration runs once; second load → verify skipped.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update stores/index.ts to use new localStorage key",
            "description": "Replace all instances of old localStorage keys with 'intellifill-backend-auth' in stores/index.ts.",
            "dependencies": [1],
            "details": "Search and replace all getItem/setItem/removeItem calls using old keys with the new unified key 'intellifill-backend-auth'. Update any Zustand persist configurations to use the new name.",
            "status": "pending",
            "testStrategy": "Unit test: verify store persistence reads/writes only new key after migration.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update cleanup and export functions to use new key",
            "description": "Modify all cleanup/export functions throughout codebase to reference the standardized key.",
            "dependencies": [1, 3],
            "details": "Globally update logout, session clear, data export functions to use 'intellifill-backend-auth'. Ensure no references to old keys remain in cleanup logic. Check auth-related utilities.",
            "status": "pending",
            "testStrategy": "Integration test: trigger logout → verify only new key cleared, no old keys remain.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Remove refreshToken from Zustand partialize configuration",
            "description": "Update backendAuthStore to exclude refreshToken from localStorage persistence.",
            "dependencies": [1, 3],
            "details": "In backendAuthStore.ts, modify persist partialize to include only { user, accessToken, tokenExpiresAt }. Ensure refreshToken cleared on login/refresh and stored only in cookies.",
            "status": "pending",
            "testStrategy": "E2E test: login → verify no refreshToken in localStorage, session works on reload via cookie.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T11:54:32.725Z"
      },
      {
        "id": "189",
        "title": "Fix Session Initialization Race Conditions",
        "description": "Refactor initialization to run only once using useRef flag and useCallback memoization (REQ-003)",
        "details": "In App.tsx and ProtectedRoute.tsx, use useRef for initialization flag:\n```typescript\nconst initRef = useRef(false);\nconst initialize = useCallback(async () => {\n  if (initRef.current) return;\n  initRef.current = true;\n  try {\n    await initializeStores();\n  } finally {\n    initRef.current = false;\n  }\n}, []);\nuseEffect(() => {\n  initialize();\n}, [initialize]);\n``` Remove duplicate calls from ProtectedRoute.tsx. Use existing useIsMounted hook to prevent state updates after unmount. Add console.warn if duplicate detected.",
        "testStrategy": "E2E test: rapid page reloads (10x) → verify single /api/auth/v2/me call per reload. Console log analysis: no race warnings. Network tab: no duplicate API calls.",
        "priority": "high",
        "dependencies": ["188"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement useRef flag in App.tsx",
            "description": "Add useRef initialization flag and memoized initialize function in App.tsx to prevent multiple initialization calls",
            "dependencies": [],
            "details": "Use provided code pattern: create initRef = useRef(false), useCallback for initialize() with early return if initRef.current true, set true before await initializeStores(), false in finally block. Add useEffect to trigger initialize.",
            "status": "pending",
            "testStrategy": "Verify console shows no duplicate warnings during rapid re-renders. Check network tab for single /api/auth/v2/me call.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrate useIsMounted hook in App.tsx",
            "description": "Wrap initialization logic with existing useIsMounted hook to prevent state updates after component unmount",
            "dependencies": [1],
            "details": "Import useIsMounted from hooks library. Use useIsMountedEffect or similar wrapper around state updates in initialize function to avoid memory leaks and stale updates.",
            "status": "pending",
            "testStrategy": "Unmount component during initialization → verify no React warnings about updating unmounted component.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add duplicate detection warning in App.tsx",
            "description": "Implement console.warn logging when duplicate initialization attempts are detected",
            "dependencies": [1],
            "details": "In initialize useCallback, add console.warn('Duplicate initialization detected') when initRef.current is already true before returning early. Include timestamp and component name.",
            "status": "pending",
            "testStrategy": "Trigger multiple concurrent initialize calls → verify warning appears exactly once per duplicate attempt.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Remove initialization from ProtectedRoute.tsx",
            "description": "Eliminate all duplicate initializeStores() calls from ProtectedRoute.tsx",
            "dependencies": [1],
            "details": "Search for initializeStores(), useEffect with initialization, or similar patterns in ProtectedRoute.tsx. Remove completely since App.tsx now handles centralized initialization.",
            "status": "pending",
            "testStrategy": "Verify ProtectedRoute.tsx contains no initializeStores() calls. Test navigation → single API call from App.tsx only.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "E2E test session initialization race conditions",
            "description": "Create E2E tests for rapid page reloads verifying single initialization per reload",
            "dependencies": [1, 2, 3, 4],
            "details": "Write Playwright test: 10x rapid page reloads, expect exactly 1 /api/auth/v2/me call per reload cycle. Verify no console warnings. Check network tab for no duplicates.",
            "status": "pending",
            "testStrategy": "Run test suite → verify passes consistently across browsers. Test edge cases: network failure, slow initialization, concurrent navigation.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T12:06:28.408Z"
      },
      {
        "id": "190",
        "title": "Implement Token Validation on Rehydration",
        "description": "Modify onRehydrateStorage to automatically call initialize() for backend validation (REQ-001)",
        "details": "In backendAuthStore.ts Zustand store:\n```typescript\nconst useBackendAuthStore = create<BackendAuthState>()(\n  persist(\n    // store config\n    {\n      onRehydrateStorage: (state) => {\n        return (state, error) => {\n          if (!error && state) {\n            initialize(); // Auto-validate with backend\n          }\n        };\n      },\n    },\n    { name: 'intellifill-backend-auth' }\n  )\n);\n``` Add loading state during validation. Implement 10s timeout using existing useTimeout hook.",
        "testStrategy": "E2E test: login → page reload → verify /api/auth/v2/me called → dashboard shown (valid token) or login shown (invalid). Verify loading spinner during validation.",
        "priority": "high",
        "dependencies": ["188", "189"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add loading state to BackendAuthState interface",
            "description": "Extend the BackendAuthState TypeScript interface to include a loading boolean property for tracking rehydration validation status.",
            "dependencies": [],
            "details": "In backendAuthStore.ts, update the BackendAuthState interface to include `loading: boolean` with initial value false. This enables components to show loading spinner during token validation.",
            "status": "pending",
            "testStrategy": "Unit test: Verify interface includes loading property and initial state is false.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update onRehydrateStorage to set loading state",
            "description": "Modify the onRehydrateStorage callback to set loading state to true before calling initialize() and handle the complete callback.",
            "dependencies": [1],
            "details": "In the onRehydrateStorage return function, add `set({ loading: true })` before `initialize()`, then in initialize() completion/error handlers set `loading: false`. Ensure both success and error paths clear loading state.",
            "status": "pending",
            "testStrategy": "Unit test: Mock rehydration → verify loading becomes true → mock initialize complete → verify loading false.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate useTimeout hook for 10s validation timeout",
            "description": "Implement 10-second timeout logic using the existing useTimeout hook to force logout if backend validation doesn't complete.",
            "dependencies": [2],
            "details": "In the store, create a timeout mechanism that calls logout() after 10s if loading is still true. Use useTimeout hook pattern adapted for Zustand store context, clearing timeout on validation complete.",
            "status": "pending",
            "testStrategy": "Unit test: Mock initialize delay >10s → verify timeout triggers logout and loading cleared.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update initialize() to handle loading state management",
            "description": "Modify the existing initialize() function to accept and manage the store's loading state in its success/error callbacks.",
            "dependencies": [2],
            "details": "Pass store setter to initialize() or use getState/set from Zustand context. Ensure initialize() completion (success or /api/auth/v2/me failure) calls set({ loading: false }) regardless of validation outcome.",
            "status": "pending",
            "testStrategy": "Integration test: Call initialize() → verify loading toggles correctly on success and 401 error paths.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add E2E test for rehydration token validation flow",
            "description": "Create end-to-end test verifying the complete rehydration validation flow including loading state and timeout.",
            "dependencies": [3],
            "details": "E2E test sequence: 1) Login with valid token 2) Page reload 3) Verify loading spinner appears 4) Verify /api/auth/v2/me called 5) Verify dashboard for valid token or login for invalid 6) Test 10s timeout → login screen.",
            "status": "pending",
            "testStrategy": "Cypress/Playwright: Test valid token → dashboard + loading spinner. Test expired token → login screen. Test network timeout → login after 10s.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T12:10:13.440Z"
      },
      {
        "id": "191",
        "title": "Add Initialization Timeout Guard",
        "description": "Wrap initialize() with 10-second timeout using useTimeout hook (REQ-008)",
        "details": "In ProtectedRoute.tsx:\n```typescript\nconst { startTimeout, isTimingOut, resetTimeout } = useTimeout(10000, () => {\n  toast.error('Session initialization timed out. Please check your connection and try again.', {\n    action: { label: 'Retry', onClick: () => window.location.reload() }\n  });\n});\nuseEffect(() => {\n  startTimeout();\n  initialize().finally(() => resetTimeout());\n}, []);\nif (isLoading || isTimingOut) return <LoadingSpinner message={isTimingOut ? 'Initializing...' : 'Validating session...'} />;\n``` Use existing hooks library useTimeout.",
        "testStrategy": "E2E test: mock slow backend (>10s) → verify timeout error and retry button. Test fast init (<2s) → no timeout. Test retry → reinitializes successfully.",
        "priority": "high",
        "dependencies": ["189", "190"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Import useTimeout hook",
            "description": "Add the useTimeout hook import statement to ProtectedRoute.tsx from the existing hooks library.",
            "dependencies": [],
            "details": "Add import at the top of ProtectedRoute.tsx: import { useTimeout } from '@/hooks/useTimeout'; or wherever the existing hooks library exports it. Verify the exact import path matches project structure.",
            "status": "pending",
            "testStrategy": "Verify no TypeScript import errors in IDE. Check bundle includes hook without tree-shaking issues.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add useTimeout hook declaration",
            "description": "Declare the useTimeout hook with 10-second timeout and toast error callback in ProtectedRoute.tsx component.",
            "dependencies": [1],
            "details": "Add exactly this code: const { startTimeout, isTimingOut, resetTimeout } = useTimeout(10000, () => { toast.error('Session initialization timed out. Please check your connection and try again.', { action: { label: 'Retry', onClick: () => window.location.reload() } }); }); Ensure toast is imported.",
            "status": "pending",
            "testStrategy": "Unit test: verify hook returns expected methods. Console log hook values on render.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Wrap initialize() call with timeout logic",
            "description": "Create useEffect that starts timeout before initialize() and resets it after completion using finally().",
            "dependencies": [2],
            "details": "Add useEffect: useEffect(() => { startTimeout(); initialize().finally(() => resetTimeout()); }, []); Ensure initialize() is properly imported/available from parent task dependencies (189/190). Empty dependency array for mount-only execution.",
            "status": "pending",
            "testStrategy": "Verify useEffect runs once on mount. Check initialize() called after startTimeout(). Console log sequence.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update loading spinner condition",
            "description": "Modify loading spinner render condition to show during isLoading OR isTimingOut states.",
            "dependencies": [3],
            "details": "Replace existing loading condition with: if (isLoading || isTimingOut) return <LoadingSpinner message={isTimingOut ? 'Initializing...' : 'Validating session...'} />; Ensure LoadingSpinner component handles both messages correctly.",
            "status": "pending",
            "testStrategy": "Manual test: trigger both isLoading=true and isTimingOut=true states, verify correct messages display.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add E2E timeout tests",
            "description": "Implement comprehensive E2E tests for timeout scenarios including slow backend, fast init, and retry functionality.",
            "dependencies": [4],
            "details": "Create Cypress/Playwright tests: 1) Mock backend >10s → verify timeout toast + retry button appears. 2) Fast init <2s → no timeout. 3) Click retry → page reloads and reinitializes. Use network throttling for slow backend simulation.",
            "status": "pending",
            "testStrategy": "E2E: Mock slow backend (>10s) → verify timeout error and retry button. Test fast init (<2s) → no timeout. Test retry → reinitializes successfully. Network tab verification.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T12:13:41.869Z"
      },
      {
        "id": "192",
        "title": "Fix Session Persistence E2E Test",
        "description": "Unskip and fix auth.spec.ts session persistence test (REQ-010)",
        "details": "In auth.spec.ts, unskip test and fix assertions:\n```typescript\nit('restores session on page reload', async ({ page }) => {\n  // Login\n  await login(page);\n  // Reload\n  await page.reload();\n  // Verify loading spinner shown\n  await expect(page.locator('[data-testid=\"loading-spinner\"]')).toBeVisible({ timeout: 15000 });\n  // Verify dashboard visible, no login flash\n  await expect(page.locator('[data-testid=\"dashboard\"]')).toBeVisible();\n  await expect(page.locator('[data-testid=\"login-form\"]')).not.toBeVisible();\n  // Verify /me API called\n  await expect(page.waitForResponse('/api/auth/v2/me')).toPass();\n});\n``` Mock backend to return valid session.",
        "testStrategy": "Run test suite → verify passes consistently. Test invalid token → redirects to login. Test network failure → timeout error shown.",
        "priority": "high",
        "dependencies": ["190"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Unskip the session persistence test",
            "description": "Locate the 'restores session on page reload' test in auth.spec.ts and remove the skip marker (it.skip or test.skip) to enable execution.",
            "dependencies": [],
            "details": "Search for the test by name in auth.spec.ts file. Remove .skip() call or change it.skip to it. Verify test appears in Cypress runner without skip indicator.",
            "status": "pending",
            "testStrategy": "Run Cypress test suite and confirm the test is listed as runnable, not skipped.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Set up backend mocking for /api/auth/v2/me endpoint",
            "description": "Create Cypress intercept to mock the /api/auth/v2/me response returning valid session data after login.",
            "dependencies": [1],
            "details": "Use cy.intercept('GET', '/api/auth/v2/me', { statusCode: 200, body: { user: { id: 1, email: 'test@example.com' }, token: 'valid-token' } }).as('me-api'); Ensure mock returns before page reload assertions.",
            "status": "pending",
            "testStrategy": "Verify network tab shows mocked response with 200 status and valid user data during test execution.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement and verify login + reload sequence",
            "description": "Ensure login(page) completes successfully, followed by page.reload(), then verify loading spinner visibility with 15s timeout.",
            "dependencies": [1, 2],
            "details": "Keep existing code: await login(page); await page.reload(); await expect(page.locator('[data-testid=\"loading-spinner\"]')).toBeVisible({ timeout: 15000 }); Add logging if spinner timeout occurs.",
            "status": "pending",
            "testStrategy": "Watch for spinner element appearance in test replay. Test fails if spinner never appears within timeout.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add dashboard and login form visibility assertions",
            "description": "After spinner verification, assert dashboard is visible and login form is hidden to confirm no login flash.",
            "dependencies": [1, 2, 3],
            "details": "Add assertions: await expect(page.locator('[data-testid=\"dashboard\"]')).toBeVisible(); await expect(page.locator('[data-testid=\"login-form\"]')).not.toBeVisible(); Increase timeout if elements slow to appear.",
            "status": "pending",
            "testStrategy": "Screenshot comparison: dashboard visible, login form absent. Run test 3x to verify consistency.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify /api/auth/v2/me API call and finalize test",
            "description": "Confirm the mocked /me API is called after reload using waitForResponse, then run full test suite validation.",
            "dependencies": [1, 2, 3, 4],
            "details": "Add: await expect(page.waitForResponse('/api/auth/v2/me')).toPass(); Run entire suite: npm run test:e2e. Test invalid token case separately by modifying mock to 401.",
            "status": "pending",
            "testStrategy": "Network tab: exactly one /me call post-reload. Full suite passes. Invalid token mock redirects to login form.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T20:22:01.834Z"
      },
      {
        "id": "193",
        "title": "Backend: Add httpOnly Cookie Support to Login/Register",
        "description": "Update login/register endpoints to set refreshToken in httpOnly cookie (REQ-005 Phase 2)",
        "details": "In supabase-auth.routes.ts, ensure cookie-parser middleware:\n```typescript\napp.use(cookieParser());\n\n// Login endpoint\napp.post('/api/auth/v2/login', async (req, res) => {\n  // ... auth logic\n  const refreshToken = await generateRefreshToken();\n  res.cookie('refreshToken', refreshToken, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'strict',\n    maxAge: 604800000, // 7 days\n    path: '/api/auth'\n  });\n  res.json({ success: true, data: { user, tokens: { accessToken, expiresIn } } });\n});\n``` Remove refreshToken from response body. Same for register endpoint.",
        "testStrategy": "Integration test: POST /login → verify Set-Cookie header with correct flags. Browser test: login → inspect cookies → verify httpOnly refreshToken present.",
        "priority": "high",
        "dependencies": ["187"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify and Add cookie-parser Middleware",
            "description": "Ensure cookie-parser middleware is properly installed and configured in the Express app before auth routes.",
            "dependencies": [],
            "details": "Check package.json for 'cookie-parser' dependency, install if missing. In main app file or routes file, add app.use(cookieParser()) before mounting supabase-auth.routes.ts. Import cookieParser from 'cookie-parser'.",
            "status": "pending",
            "testStrategy": "Verify req.cookies is available in a test route by logging req.cookies after middleware.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update Login Endpoint for httpOnly Cookie",
            "description": "Modify POST /api/auth/v2/login to set refreshToken in httpOnly cookie and remove from response body.",
            "dependencies": [1],
            "details": "In supabase-auth.routes.ts, generate refreshToken, call res.cookie('refreshToken', refreshToken, {httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: 'strict', maxAge: 604800000, path: '/api/auth'}). Update res.json to exclude refreshToken: {success: true, data: {user, tokens: {accessToken, expiresIn}}}",
            "status": "pending",
            "testStrategy": "Integration test: POST /login with credentials → verify 200 response, Set-Cookie header contains refreshToken with httpOnly=true, secure flag correct for env, and refreshToken absent from JSON body.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update Register Endpoint for httpOnly Cookie",
            "description": "Apply identical httpOnly cookie changes to POST /api/auth/v2/register endpoint as done for login.",
            "dependencies": [1],
            "details": "Locate register endpoint in supabase-auth.routes.ts, add refreshToken cookie setting with same options as login. Remove refreshToken from response JSON body, keeping only user data and accessToken.",
            "status": "pending",
            "testStrategy": "Integration test: POST /register with user data → verify Set-Cookie header with correct flags, no refreshToken in response body, user created successfully.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Remove refreshToken from All Auth Responses",
            "description": "Audit and clean up any remaining instances where refreshToken appears in JSON responses across auth endpoints.",
            "dependencies": [2, 3],
            "details": "Search codebase for 'refreshToken' in res.json calls within auth routes. Ensure only accessToken and user data returned. Update any documentation or frontend expectations if needed.",
            "status": "pending",
            "testStrategy": "Run full auth flow tests (login/register) → grep responses for 'refreshToken' → confirm absence. Manual inspection of response schemas.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Integration Tests for Cookie Implementation",
            "description": "Create comprehensive tests verifying cookie setting, security flags, and response changes for login/register.",
            "dependencies": [2, 3, 4],
            "details": "Use supertest for POST /login and /register tests. Assert Set-Cookie header presence, parse for httpOnly=true, secure=(env-based), sameSite=strict, maxAge=604800000. Verify 401 without creds. Browser test: login → devtools → confirm httpOnly refreshToken cookie.",
            "status": "pending",
            "testStrategy": "CI/CD tests pass: 100% coverage of cookie flags, edge cases (no creds, prod env secure=true), cross-browser cookie inspection.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T20:29:16.915Z"
      },
      {
        "id": "194",
        "title": "Backend: Implement Cookie-Based Refresh Endpoint",
        "description": "Update refresh endpoint to read refreshToken from cookie, not body (REQ-005 Phase 2)",
        "details": "In supabase-auth.routes.ts:\n```typescript\napp.post('/api/auth/v2/refresh', async (req, res) => {\n  const refreshToken = req.cookies.refreshToken;\n  if (!refreshToken) {\n    return res.status(401).json({ success: false, error: 'No refresh token' });\n  }\n  // Validate and rotate refresh token\n  const newTokens = await refreshSession(refreshToken);\n  res.cookie('refreshToken', newTokens.refreshToken, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'strict',\n    maxAge: 604800000,\n    path: '/api/auth'\n  });\n  res.json({ success: true, data: { tokens: { accessToken: newTokens.accessToken, expiresIn: 3600 } } });\n});\n``` Support both cookie and body during migration phase.",
        "testStrategy": "Integration test: POST /refresh with cookie → verify new accessToken and updated cookie. Test missing cookie → 401. Test expired refreshToken → 401.",
        "priority": "high",
        "dependencies": ["193"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify cookie-parser middleware configuration",
            "description": "Ensure cookie-parser middleware is properly configured in the Express app to read cookies from refresh endpoint requests.",
            "dependencies": [],
            "details": "Check that `app.use(cookieParser());` is present before auth routes in supabase-auth.routes.ts. Install cookie-parser if missing via `npm i cookie-parser`. Test cookie reading with a simple endpoint.",
            "status": "pending",
            "testStrategy": "Unit test: Mock req.cookies object and verify middleware parses correctly. Integration test: Send cookie in request and verify it's accessible in handler.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement dual refreshToken extraction logic",
            "description": "Update refresh endpoint to read refreshToken from cookie first, then fallback to request body during migration phase.",
            "dependencies": [1],
            "details": "Modify handler: `let refreshToken = req.cookies?.refreshToken || req.body?.refreshToken;`. Add validation: if (!refreshToken) return 401. Preserve existing refreshSession() call.",
            "status": "pending",
            "testStrategy": "Integration tests: 1) Cookie only → success. 2) Body only → success. 3) Both → prefers cookie. 4) Neither → 401 error.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update refresh token cookie setting with correct options",
            "description": "Ensure new refreshToken cookie is set with secure httpOnly options matching login/register endpoints.",
            "dependencies": [2],
            "details": "Use exact same cookie options as Task 193: httpOnly: true, secure: NODE_ENV==='production', sameSite: 'strict', maxAge: 604800000 (7 days), path: '/api/auth'. Clear old cookie if present.",
            "status": "pending",
            "testStrategy": "Verify Set-Cookie header contains all security flags. Test in production/staging envs for secure flag. Browser devtools: inspect cookie attributes post-refresh.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Preserve existing response format and error handling",
            "description": "Maintain backward-compatible JSON response structure and add specific error messages for missing/expired tokens.",
            "dependencies": [2],
            "details": "Response: { success: true, data: { tokens: { accessToken, expiresIn: 3600 } } }. Errors: 'No refresh token', handle refreshSession() failures with 401. Log errors for debugging.",
            "status": "pending",
            "testStrategy": "Test happy path → correct JSON structure. Test refreshSession() throws → 401 with error message. Verify expiresIn is always 3600.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add comprehensive integration tests for refresh endpoint",
            "description": "Create integration tests covering all refresh endpoint scenarios including cookie precedence and migration support.",
            "dependencies": [3],
            "details": "Use supertest: 1) Valid cookie → new tokens + updated cookie. 2) Valid body → success (migration). 3) No token → 401. 4) Expired token → 401. 5) Cookie + body → cookie wins.",
            "status": "pending",
            "testStrategy": "Full test suite with 100% coverage of endpoint logic. Mock refreshSession() for predictable responses. Test cookie flags in Set-Cookie headers. Run against staging env.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T20:33:00.365Z"
      },
      {
        "id": "195",
        "title": "Frontend: Remove Refresh Token from localStorage",
        "description": "Update frontend stores to exclude refreshToken from persistence (REQ-005 Phase 2)",
        "details": "In backendAuthStore.ts, update persist config:\n```typescript\nconst useBackendAuthStore = create(\n  persist(\n    (set, get) => ({\n      // state without refreshToken\n    }), {\n      name: 'intellifill-backend-auth',\n      partialize: (state) => ({ \n        user: state.user, \n        accessToken: state.accessToken, \n        tokenExpiresAt: state.tokenExpiresAt \n        // exclude refreshToken\n      })\n    }\n  )\n);\n``` Clear any existing refreshTokens on login/refresh.",
        "testStrategy": "Browser devtools: login → verify no refreshToken in localStorage, only in cookies. E2E test: page reload → session still works via cookie.",
        "priority": "high",
        "dependencies": ["188", "194"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update persist partialize config to exclude refreshToken",
            "description": "Modify the partialize function in backendAuthStore.ts to exclude refreshToken from localStorage persistence while keeping user, accessToken, and tokenExpiresAt.",
            "dependencies": [],
            "details": "Update the persist config exactly as specified: partialize: (state) => ({ user: state.user, accessToken: state.accessToken, tokenExpiresAt: state.tokenExpiresAt }) - ensure refreshToken is completely omitted from the returned object.",
            "status": "pending",
            "testStrategy": "Check store state in Redux DevTools - verify refreshToken exists in memory but is absent from partialize output.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Ensure store state definition excludes refreshToken persistence",
            "description": "Update the Zustand store creator to properly handle refreshToken in memory only, without any persistence configuration that includes it.",
            "dependencies": [1],
            "details": "In the create(persist((set, get) => ({ ... }))) - ensure the initial state shape supports refreshToken in memory but relies solely on the partialize from subtask 1 for persistence.",
            "status": "pending",
            "testStrategy": "Verify store can set/get refreshToken in memory via get().refreshToken and set({refreshToken: 'test'}) without errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Clear existing refreshTokens from localStorage on login",
            "description": "Implement cleanup logic in the login action to remove any pre-existing refreshToken from localStorage immediately upon successful login.",
            "dependencies": [1, 2],
            "details": "In the login handler: after successful login, explicitly call localStorage.removeItem('intellifill-backend-auth') or use store rehydration to overwrite with new partialized state excluding refreshToken.",
            "status": "pending",
            "testStrategy": "Manually add refreshToken to localStorage → login → verify key is cleared or overwritten without refreshToken.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Clear existing refreshTokens from localStorage on token refresh",
            "description": "Add cleanup logic in refreshTokenIfNeeded to ensure localStorage never contains refreshToken after refresh operations.",
            "dependencies": [1, 2, 3],
            "details": "In refreshTokenIfNeeded(): after successful refresh, ensure the store state update uses partialize (no manual localStorage writes) and consider explicit localStorage cleanup if legacy data exists.",
            "status": "pending",
            "testStrategy": "Trigger refresh flow → check localStorage before/after → confirm no refreshToken persists.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify implementation with browser testing and E2E validation",
            "description": "Test the complete implementation to confirm refreshToken is excluded from localStorage while session functionality remains intact.",
            "dependencies": [1, 2, 3, 4],
            "details": "Follow test strategy: Browser devtools Application tab → login → verify no refreshToken in localStorage (only cookies). Page reload → session works via cookie refresh mechanism.",
            "status": "pending",
            "testStrategy": "1. Login → DevTools → localStorage → no refreshToken. 2. Page reload → auto-refresh works. 3. E2E: simulate expiry → refresh succeeds via cookies only.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T20:34:45.813Z"
      },
      {
        "id": "196",
        "title": "Update Frontend Refresh Logic for Cookies",
        "description": "Modify refreshTokenIfNeeded() to send empty body (cookie auto-sent) (REQ-005 Phase 2)",
        "details": "In backendAuthStore.ts:\n```typescript\nconst refreshTokenIfNeeded = async () => {\n  if (Date.now() < get().tokenExpiresAt - 2 * 60 * 1000) return; // 2min early\n  \n  try {\n    const response = await fetch('/api/auth/v2/refresh', {\n      method: 'POST',\n      credentials: 'include', // Send cookies\n      body: JSON.stringify({}) // Empty body\n    });\n    \n    if (response.ok) {\n      const data = await response.json();\n      set({ accessToken: data.data.tokens.accessToken, tokenExpiresAt: Date.now() + data.data.tokens.expiresIn * 1000 });\n    } else {\n      logout();\n    }\n  } catch (error) {\n    toast.error('Unable to refresh session. Please save your work.', {\n      action: { label: 'Retry', onClick: () => refreshTokenIfNeeded() }\n    });\n  }\n};\n``` Always include credentials: 'include'.",
        "testStrategy": "E2E test: wait until near expiry → verify refresh called with credentials: 'include' and empty body → new accessToken received.",
        "priority": "high",
        "dependencies": ["195"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Locate and Open backendAuthStore.ts File",
            "description": "Navigate to the backendAuthStore.ts file in the project and open it in the code editor for modification.",
            "dependencies": [],
            "details": "Find the file containing the refreshTokenIfNeeded function, typically in the stores or auth directory. Verify the current implementation matches the provided code snippet with the existing body: JSON.stringify({}).",
            "status": "pending",
            "testStrategy": "Manual verification: Confirm file opens and function signature is visible.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update refreshTokenIfNeeded Fetch Request",
            "description": "Modify the fetch call in refreshTokenIfNeeded to ensure empty body is sent with credentials: 'include'.",
            "dependencies": [1],
            "details": "Replace or confirm the fetch options: method: 'POST', credentials: 'include', body: JSON.stringify({}). Ensure no other body content is added and comment clearly indicates cookie auto-sent behavior.",
            "status": "pending",
            "testStrategy": "Unit test: Mock fetch call and verify request options include credentials: 'include' and body is '{}'.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Verify Token Parsing and State Update Logic",
            "description": "Confirm response parsing and state update logic correctly handles new access token and expiry.",
            "dependencies": [2],
            "details": "Check if (response.ok) block correctly extracts data.data.tokens.accessToken and sets tokenExpiresAt: Date.now() + data.data.tokens.expiresIn * 1000. Add comments for clarity.",
            "status": "pending",
            "testStrategy": "Unit test: Mock successful response with token data and verify set() is called with correct values.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Validate Error Handling and Logout Behavior",
            "description": "Ensure error handling in refreshTokenIfNeeded properly triggers logout and shows toast notification.",
            "dependencies": [2],
            "details": "Verify !response.ok calls logout() and catch block displays toast.error with 'Unable to refresh session. Please save your work.' and Retry action that recalls refreshTokenIfNeeded.",
            "status": "pending",
            "testStrategy": "Unit test: Mock failed response (non-ok) and error throw, verify logout() called and toast triggered.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run E2E Tests and Commit Changes",
            "description": "Execute end-to-end tests for token refresh and commit the updated backendAuthStore.ts.",
            "dependencies": [3, 4],
            "details": "Run E2E test: simulate near token expiry, verify /api/auth/v2/refresh called with credentials: 'include' and empty body, confirm new accessToken received and stored. Commit with message referencing REQ-005 Phase 2.",
            "status": "pending",
            "testStrategy": "E2E test: Wait until 2min before expiry → verify fetch request → assert new accessToken and updated tokenExpiresAt.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T20:36:35.197Z"
      },
      {
        "id": "197",
        "title": "Add Token Refresh Test Suite",
        "description": "Create comprehensive E2E tests for proactive/reactive refresh flows (REQ-011)",
        "details": "Create token-refresh.spec.ts:\n```typescript\n// Proactive refresh (before 2min threshold)\nit('proactively refreshes token', async ({ page }) => {\n  await mockTokenExpiry(page, Date.now() + 1 * 60 * 1000); // 1min\n  await page.waitForResponse('/api/auth/v2/refresh');\n});\n\n// Reactive refresh (401 error)\nit('reactively refreshes on 401', async ({ page }) => {\n  await mock401Response(page);\n  await expect(page.waitForResponse('/api/auth/v2/refresh')).toPass();\n});\n\n// Failed refresh → logout\nit('logs out on refresh failure', async ({ page }) => {\n  await mockRefreshFail(page);\n  await expect(page.locator('[data-testid=\"login-form\"]')).toBeVisible();\n});\n``` Test concurrent prevention using shared promise.",
        "testStrategy": "Run full test suite → all refresh scenarios pass. Verify no double refresh calls. Test edge cases: expired refresh token, network failure.",
        "priority": "medium",
        "dependencies": ["196"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create token-refresh.spec.ts file structure",
            "description": "Set up the Playwright test file with describe block, beforeEach hooks for login and initial token setup.",
            "dependencies": [],
            "details": "Create token-refresh.spec.ts with describe('Token Refresh Flows', () => { beforeEach(async ({ page }) => { await loginUser(page); await mockValidToken(page, Date.now() + 10 * 60 * 1000); }); }); Add test tags for E2E reporting.",
            "status": "pending",
            "testStrategy": "Verify file structure loads without syntax errors in Playwright test runner",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement proactive refresh test case",
            "description": "Write test for proactive token refresh triggered before 2-minute expiry threshold.",
            "dependencies": [1],
            "details": "Implement it('proactively refreshes token', async ({ page }) => { await mockTokenExpiry(page, Date.now() + 1 * 60 * 1000); await page.waitForResponse('/api/auth/v2/refresh'); expect(await getTokenExpiry(page)).toBeGreaterThan(Date.now() + 15 * 60 * 1000); }); Verify new token expiry >15min.",
            "status": "pending",
            "testStrategy": "Mock 1min expiry → verify single /refresh call → new token expiry >15min",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement reactive refresh on 401 test",
            "description": "Test automatic refresh triggered by 401 Unauthorized response on API call.",
            "dependencies": [1],
            "details": "Add it('reactively refreshes on 401', async ({ page }) => { await mock401Response(page, '/api/protected-endpoint'); await expect(page.waitForResponse('/api/auth/v2/refresh')).toPass({ timeout: 5000 }); await expect(page.waitForResponse('/api/protected-endpoint')).toPass(); }); Verify retry succeeds.",
            "status": "pending",
            "testStrategy": "Mock 401 → verify refresh called → verify retry API succeeds with 200",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement refresh failure logout test",
            "description": "Test user logout when refresh endpoint returns failure (401/500).",
            "dependencies": [1],
            "details": "Create it('logs out on refresh failure', async ({ page }) => { await mockRefreshFail(page); await expect(page.locator('[data-testid=\"login-form\"]')).toBeVisible({ timeout: 10000 }); await expect(page.locator('[data-testid=\"protected-content\"]')).toBeHidden(); }); Verify session cleared.",
            "status": "pending",
            "testStrategy": "Mock refresh 401 → verify login form visible → verify protected content hidden",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add concurrent refresh prevention test",
            "description": "Test shared promise prevents multiple simultaneous refresh calls using race condition simulation.",
            "dependencies": [2, 3],
            "details": "Implement it('prevents concurrent refresh calls', async ({ page }) => { const promises = Array(5).fill(0).map(() => mockNearExpiry(page)); await Promise.all(promises); const responses = await page.waitForResponse('/api/auth/v2/refresh', { timeout: 10000 }); expect(responses.length).toBe(1); }); Use shared promise verification.",
            "status": "pending",
            "testStrategy": "Trigger 5 concurrent expiry conditions → verify exactly 1 refresh call made",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T20:38:02.092Z"
      },
      {
        "id": "198",
        "title": "Implement Proactive Refresh Error Notifications",
        "description": "Show toast notifications for refresh failures with retry option (REQ-007)",
        "details": "Already partially implemented in task 196. Enhance toast:\n```typescript\nif (!response.ok || !data.success) {\n  toast.error('Session refresh failed. Save your work and retry.', {\n    id: 'refresh-error',\n    duration: 10000,\n    action: [\n      {\n        label: 'Retry',\n        onClick: () => refreshTokenIfNeeded(),\n      },\n      {\n        label: 'Logout',\n        onClick: logout,\n      },\n    ],\n  });\n  // Retry 3x with exponential backoff\n  let retries = 0;\n  const maxRetries = 3;\n  const retryWithBackoff = async () => {\n    retries++;\n    if (retries >= maxRetries) {\n      toast.error('Multiple refresh attempts failed. Logging out...', { id: 'refresh-fatal' });\n      logout();\n      return;\n    }\n    await new Promise(r => setTimeout(r, 1000 * Math.pow(2, retries)));\n    refreshTokenIfNeeded();\n  };\n}\n``` Use sonner/react-hot-toast for toasts.",
        "testStrategy": "E2E test: mock refresh failure → verify toast appears with Retry/Logout buttons. Test retry → calls refresh again. Test 3 failures → auto-logout.",
        "priority": "medium",
        "dependencies": ["196"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor Inline Retry Logic into Separate Hook",
            "description": "Extract the inline retry logic with exponential backoff into a reusable custom hook to improve code organization and testability.",
            "dependencies": [],
            "details": "Create useAutoRetryRefresh hook that handles up to 3 retries with exponential backoff (1s, 2s, 4s). Return loading state and success/failure status. Remove inline retries from the existing error handler.",
            "status": "pending",
            "testStrategy": "Unit test hook: mock refreshTokenIfNeeded failures → verify 3 retries with correct delays → verify returns failure after max retries.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Enhance Toast Notification Content and UX",
            "description": "Improve toast message clarity, add progress indication for retries, and ensure sonner/react-hot-toast best practices are followed.",
            "dependencies": [1],
            "details": "Update toast.error message to 'Session refresh failed. Auto-retrying...' with dynamic retry count. Add loading spinner during retries using toast.loading(). Ensure duration=10000 and unique IDs. Follow UX best practices: clear messaging, simple actions.",
            "status": "pending",
            "testStrategy": "Visual regression test: verify toast appears with correct message, Retry/Logout buttons, and 10s duration. Test auto-dismiss behavior.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate Auto-Retry Hook with Error Handler",
            "description": "Replace existing toast + inline retry code with the new useAutoRetryRefresh hook integration.",
            "dependencies": [1, 2],
            "details": "In refresh error block: show initial toast, then call useAutoRetryRefresh(). Update Retry button to trigger manual retry via hook. Ensure Logout action remains available. Dismiss 'refresh-error' toast on retry success.",
            "status": "pending",
            "testStrategy": "Integration test: trigger refresh failure → verify hook called → verify sequential retries → verify toast updates.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Comprehensive Error State Management",
            "description": "Implement global refresh failure state in auth store with loading indicators and user guidance.",
            "dependencies": [3],
            "details": "Add isRefreshing and refreshFailed states to backendAuthStore. Show app-wide loading overlay during retries. Display persistent banner if refresh permanently fails before auto-logout. Ensure smooth UX transitions.",
            "status": "pending",
            "testStrategy": "E2E test: refresh failure → verify loading spinner → verify banner after max retries → verify auto-logout after fatal error.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Complete E2E Test Coverage",
            "description": "Write comprehensive tests covering all refresh failure scenarios as specified in original test strategy.",
            "dependencies": [4],
            "details": "Create Cypress/Playwright tests: 1) Mock refresh failure → verify toast with Retry/Logout 2) Click Retry → verify refreshTokenIfNeeded called 3) 3 failures → verify 'refresh-fatal' toast → auto-logout. Test edge cases: network errors, 401 responses.",
            "status": "pending",
            "testStrategy": "Run full test suite: verify 100% pass rate. Test manual Retry button → single refresh call. Test Logout → immediate redirect to /login.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T20:39:35.012Z"
      },
      {
        "id": "199",
        "title": "Add Race Condition and Edge Case Tests",
        "description": "Add E2E tests for rapid reloads and edge cases (REQ-012, REQ-013)",
        "details": "Extend auth.spec.ts:\n```typescript\n// Race condition test\nit('handles rapid reloads without races', async ({ page, browser }) => {\n  await login(page);\n  for (let i = 0; i < 10; i++) {\n    await page.reload({ waitUntil: 'networkidle' });\n    await expect(page.locator('[data-testid=\"dashboard\"]')).toBeVisible({ timeout: 5000 });\n  }\n});\n\n// Edge cases\nit('clears invalid token', async ({ page }) => {\n  await page.addInitScript(() => {\n    localStorage.setItem('intellifill-backend-auth', JSON.stringify({ accessToken: 'invalid' }));\n  });\n  await page.goto('/');\n  await expect(page.locator('[data-testid=\"login-form\"]')).toBeVisible();\n});\n```",
        "testStrategy": "Run tests → 100% pass rate. Verify rapid reloads show no console errors. Test offline → timeout error. Test expired during session → refresh triggered.",
        "priority": "medium",
        "dependencies": ["192", "197"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Race Condition Rapid Reload Test",
            "description": "Implement the E2E test for handling rapid reloads without race conditions in auth.spec.ts as provided in the task details.",
            "dependencies": [],
            "details": "Copy the provided test code into auth.spec.ts: login, perform 10 rapid reloads with networkidle wait, verify dashboard visibility each time with 5000ms timeout. Ensure test uses Playwright fixtures page and browser.",
            "status": "pending",
            "testStrategy": "Run test 10x, verify 100% pass rate, check browser console for no race warnings or duplicate API calls to /api/auth/v2/me.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Invalid Token Clearing Test",
            "description": "Implement the E2E test for clearing invalid tokens by simulating localStorage with invalid auth token.",
            "dependencies": [],
            "details": "Add the provided test code to auth.spec.ts: use page.addInitScript to set invalid accessToken in localStorage, goto '/', expect login-form to be visible indicating token cleared.",
            "status": "pending",
            "testStrategy": "Verify login form appears, no dashboard shown, check network tab for no successful auth calls, console shows no errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Offline Mode Edge Case Test",
            "description": "Create new E2E test for offline scenario where auth operations should timeout appropriately.",
            "dependencies": [1, 2],
            "details": "In auth.spec.ts, use browser.newContext({ offline: true }), attempt login or reload after login, expect timeout error on dashboard locator or API calls, timeout after 10s.",
            "status": "pending",
            "testStrategy": "Set offline context, verify timeout errors logged, no infinite hangs, test passes when expecting failure due to offline.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Expired Token During Session Test",
            "description": "Implement test simulating token expiration mid-session triggering automatic refresh.",
            "dependencies": [1, 2],
            "details": "Mock expired token via initScript after login, perform page interaction/reload, verify refresh token call triggered and dashboard remains visible, login form does not appear.",
            "status": "pending",
            "testStrategy": "Check network tab for refresh token API call, verify single /api/auth/v2/me after refresh, no fallback to login, 100% pass rate.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run Full Test Suite and Validate Coverage",
            "description": "Execute all auth.spec.ts tests, validate against REQ-012/REQ-013, ensure 100% pass rate and no regressions.",
            "dependencies": [1, 2, 3, 4],
            "details": "Run npx playwright test auth.spec.ts --headed, review console/network for races/duplicates/errors, update test strategy docs, commit with message referencing REQ-012, REQ-013.",
            "status": "pending",
            "testStrategy": "100% pass rate required, verify rapid reloads: single init per reload, no console errors, offline/expired handle gracefully per specs.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T20:51:32.727Z"
      },
      {
        "id": "200",
        "title": "Implement Token Cache Invalidation on Logout",
        "description": "Call tokenCache.invalidateToken() during logout (REQ-006)",
        "details": "In supabase-auth.routes.ts logout endpoint:\n```typescript\napp.post('/api/auth/v2/logout', async (req, res) => {\n  const refreshToken = req.cookies.refreshToken;\n  if (refreshToken) {\n    await tokenCache.invalidateToken(refreshToken); // Non-blocking\n    res.clearCookie('refreshToken');\n  }\n  res.json({ success: true });\n});\n``` Frontend logout also clears localStorage:\n```typescript\nconst logout = () => {\n  localStorage.clear();\n  window.location.href = '/login';\n};\n``` Make cache invalidation fire-and-forget with 500ms timeout.",
        "testStrategy": "Integration test: login → logout → verify cache cleared (subsequent /me calls hit Supabase). Test concurrent logouts → no errors.",
        "priority": "medium",
        "dependencies": ["194"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update logout endpoint to make invalidation non-blocking",
            "description": "Modify the backend logout endpoint to call tokenCache.invalidateToken() without awaiting it, ensuring the response is sent immediately.",
            "dependencies": [],
            "details": "In supabase-auth.routes.ts, remove 'await' from tokenCache.invalidateToken(refreshToken) to make it fire-and-forget. Keep cookie clearing and success response synchronous for fast logout.",
            "status": "pending",
            "testStrategy": "Verify endpoint responds <100ms even if cache op hangs. Test with mock slow invalidateToken() → response still fast.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement 500ms timeout wrapper for cache invalidation",
            "description": "Create a utility function that wraps tokenCache.invalidateToken() with Promise.race() to timeout after 500ms and prevent hanging requests.",
            "dependencies": [1],
            "details": "Create timeoutInvalidateToken(refreshToken) using Promise.race([tokenCache.invalidateToken(refreshToken), new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 500))]). Log timeout errors.",
            "status": "pending",
            "testStrategy": "Unit test: mock invalidateToken hanging → verify timeout fires at exactly 500ms. Test normal case → completes without timeout.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate timeout wrapper into logout endpoint",
            "description": "Replace direct cache invalidation call with the new timeout wrapper in the logout endpoint.",
            "dependencies": [2],
            "details": "Update POST /api/auth/v2/logout to use timeoutInvalidateToken(refreshToken) instead of direct call. Ensure it remains non-blocking with try-catch for timeout handling.",
            "status": "pending",
            "testStrategy": "Integration test: simulate slow cache → verify endpoint still responds fast, timeout logged but user unaffected.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add logging for cache invalidation success/failure",
            "description": "Implement structured logging for cache invalidation attempts, timeouts, and successes during logout.",
            "dependencies": [3],
            "details": "Add console.error for timeouts with refreshToken hash (not full token), console.log for successful invalidations. Use structured format: {event: 'token_invalidation', status: 'timeout/success', tokenHash: '...'}",
            "status": "pending",
            "testStrategy": "Manual test: logout → check server logs show success. Simulate timeout → verify timeout log appears without crashing endpoint.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create integration tests for logout cache invalidation",
            "description": "Write comprehensive tests verifying cache invalidation works correctly on logout with timeout protection.",
            "dependencies": [4],
            "details": "Test suite: 1) login→logout→/me hits Supabase (cache cleared); 2) concurrent logouts (no errors); 3) slow cache simulation (timeout works); 4) no refreshToken (fast success response).",
            "status": "pending",
            "testStrategy": "Full E2E: login → logout → verify subsequent /me calls bypass cache and hit Supabase directly. Load test: 100 concurrent logouts → no errors, all caches cleared.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T20:41:21.280Z"
      },
      {
        "id": "201",
        "title": "Improve Loading States with Stages",
        "description": "Add substates to distinguish rehydration vs backend validation (REQ-009)",
        "details": "In store:\n```typescript\ntype LoadingStage = 'idle' | 'rehydrating' | 'validating' | 'ready';\nloadingStage: LoadingStage;\n```\nIn ProtectedRoute.tsx:\n```typescript\nconst stage = useBackendAuthStore(s => s.loadingStage);\nconst messages = {\n  rehydrating: 'Restoring session...',\n  validating: 'Validating with server...',\n  ready: 'Loading dashboard...'\n};\nreturn <LoadingSpinner message={messages[stage] || 'Loading...'} />;\n```\nUpdate initialize to set stages appropriately.",
        "testStrategy": "Manual test: page reload → verify spinner messages change: 'Restoring...' → 'Validating...' → dashboard. E2E test: verify no flash of wrong content.",
        "priority": "low",
        "dependencies": ["190", "191"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update BackendAuthStore with LoadingStage state",
            "description": "Add the LoadingStage type and loadingStage property to the Zustand store used by backend authentication.",
            "dependencies": [],
            "details": "Define type LoadingStage = 'idle' | 'rehydrating' | 'validating' | 'ready'; Add loadingStage: LoadingStage to store state. Initialize as 'idle'. Export selector useBackendAuthStore(s => s.loadingStage).",
            "status": "pending",
            "testStrategy": "Unit test: verify store initializes with loadingStage='idle', selector returns correct value.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add stage transition actions to store",
            "description": "Create actions in the store to set loadingStage to 'rehydrating', 'validating', and 'ready'.",
            "dependencies": [1],
            "details": "Add store methods: setRehydrating(), setValidating(), setReady(). Each updates loadingStage to respective value. Ensure actions are exported from store.",
            "status": "pending",
            "testStrategy": "Unit test: call each action and verify loadingStage updates correctly in store state.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update ProtectedRoute.tsx to use staged messages",
            "description": "Modify ProtectedRoute component to read loadingStage and display appropriate spinner messages.",
            "dependencies": [1],
            "details": "Use const stage = useBackendAuthStore(s => s.loadingStage); Define messages object with rehydrating, validating, ready keys. Render <LoadingSpinner message={messages[stage] || 'Loading...'} />.",
            "status": "pending",
            "testStrategy": "Unit test: render with different stage props, verify correct message displayed in LoadingSpinner.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update initialize function with stage transitions",
            "description": "Modify the initialize function to set appropriate loading stages during rehydration and validation.",
            "dependencies": [2],
            "details": "In initialize(): setRehydrating() before local storage/session check, setValidating() before backend refresh call, setReady() on successful completion or final state.",
            "status": "pending",
            "testStrategy": "Unit test: mock initialize flow, verify actions called in sequence: rehydrating → validating → ready.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add manual and E2E tests for loading stages",
            "description": "Implement testing strategy to verify spinner messages change correctly during page load.",
            "dependencies": [3, 4],
            "details": "Manual: page reload and check message sequence. E2E: use Cypress/Playwright to assert spinner text changes 'Restoring session...' → 'Validating with server...' → dashboard loads without wrong content flash.",
            "status": "pending",
            "testStrategy": "E2E test: intercept network calls, verify no content flash, message sequence correct. Manual verification on prod-like environment.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T21:01:31.064Z"
      },
      {
        "id": "202",
        "title": "Refactor to Use Existing Hooks Library",
        "description": "Replace custom logic with useTimeout, useIsMounted, useFetch from hooks library (REQ-014)",
        "details": "Audit all auth components:\n- Replace custom setTimeout with useTimeout\n- Wrap API calls with useFetch AbortController\n- Use useIsMounted for cleanup\n```typescript\nconst { data, error, isLoading } = useFetch('/api/auth/v2/me', {\n  refetchOnWindowFocus: false\n});\nuseIsMountedEffect(() => {\n  if (data) setUser(data.user);\n});\n``` Remove custom implementations, rely on hooks/index.ts.",
        "testStrategy": "Code review: verify no custom timeout/AbortController/useEffect cleanup logic remains. Component tests: verify hooks prevent memory leaks.",
        "priority": "low",
        "dependencies": ["191", "196"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit Auth Components for Custom Logic",
            "description": "Review all authentication-related components to identify custom setTimeout, AbortController, and useEffect cleanup implementations.",
            "dependencies": [],
            "details": "Scan files like Login.tsx, AuthProvider.tsx, ProtectedRoute.tsx for manual setTimeout calls, fetch with AbortController, and useEffect without proper cleanup. Document locations in a checklist.\n<info added on 2026-01-02T21:05:15.177Z>\nAudit completed. No custom setTimeout, AbortController, or problematic useEffect cleanup logic found in auth components. Login.tsx, Register.tsx, and ForgotPassword.tsx contain no manual implementations. AuthCallback.tsx and ResetPassword.tsx are already refactored to use the useTimeout hook from the usehooks-ts library. ProtectedRoute.tsx, backendAuthStore.ts, and authService.ts follow established patterns using Zustand and the standard API wrapper. No further refactoring is required as the codebase already aligns with the target architecture.\n</info added on 2026-01-02T21:05:15.177Z>",
            "status": "done",
            "testStrategy": "Manual code review: grep for 'setTimeout', 'AbortController', 'useEffect' in auth files.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T21:05:15.273Z"
          },
          {
            "id": 2,
            "title": "Replace Custom setTimeout with useTimeout Hook",
            "description": "Refactor all identified custom setTimeout logic in auth components to use the useTimeout hook from hooks/index.ts.",
            "dependencies": [1],
            "details": "Import useTimeout from hooks/index.ts. Replace setTimeout(callback, delay) with useTimeout(callback, delay). Ensure proper cleanup by verifying hook handles clearTimeout internally.",
            "status": "done",
            "testStrategy": "Component tests: Verify timeout callbacks execute after delay and are cleared on unmount. Check no memory leaks.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T21:05:27.938Z"
          },
          {
            "id": 3,
            "title": "Refactor API Calls to Use useFetch Hook",
            "description": "Replace manual fetch calls in auth components with useFetch('/api/auth/v2/me', { refetchOnWindowFocus: false }).",
            "dependencies": [1],
            "details": "Update all auth API endpoints to useFetch pattern. Destructure { data, error, isLoading }. Remove manual AbortController and fetch logic. Handle data assignment safely.",
            "status": "done",
            "testStrategy": "Network tab verification: Single API call per component mount. Test loading/error states render correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T21:05:27.957Z"
          },
          {
            "id": 4,
            "title": "Implement useIsMounted for State Updates and Cleanup",
            "description": "Wrap all side-effect state updates in auth components with useIsMountedEffect to prevent updates on unmounted components.",
            "dependencies": [1, 3],
            "details": "Import useIsMountedEffect from hooks/index.ts. Wrap useEffect callbacks that set state: useIsMountedEffect(() => { if (data) setUser(data.user); }); Remove custom mounted flags.",
            "status": "done",
            "testStrategy": "Unmount during async operation: Verify no React warnings about setState on unmounted component.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T21:05:27.974Z"
          },
          {
            "id": 5,
            "title": "Remove Custom Implementations and Verify Completeness",
            "description": "Delete all custom timeout/AbortController/mounted logic. Perform final audit and update tests.",
            "dependencies": [2, 3, 4],
            "details": "Remove redundant code. Ensure hooks/index.ts provides all functionality. Run code review checklist. Update component tests to verify hooks prevent memory leaks per original test strategy.",
            "status": "done",
            "testStrategy": "Full code review: No custom timeout/AbortController/useEffect cleanup remains. Component tests pass. E2E: Verify auth flow works without regressions.",
            "parentId": "undefined",
            "updatedAt": "2026-01-02T21:05:27.991Z"
          }
        ],
        "updatedAt": "2026-01-02T21:05:27.991Z"
      },
      {
        "id": "203",
        "title": "USER-TEST-1: User Validation Checkpoint 1",
        "description": "Manually test functionality from Tasks 187-191 (Foundation & Critical Fixes)",
        "details": "",
        "testStrategy": "",
        "status": "deferred",
        "dependencies": ["191"],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-02T20:33:24.037Z"
      },
      {
        "id": "204",
        "title": "USER-TEST-2: User Validation Checkpoint 2",
        "description": "Manually test functionality from Tasks 192-196 (httpOnly Cookie Implementation)",
        "details": "",
        "testStrategy": "",
        "status": "deferred",
        "dependencies": ["196"],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-02T20:33:24.055Z"
      },
      {
        "id": "205",
        "title": "USER-TEST-3: User Validation Checkpoint 3",
        "description": "Manually test functionality from Tasks 197-199 (Comprehensive Testing)",
        "details": "",
        "testStrategy": "",
        "status": "deferred",
        "dependencies": ["199"],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-02T20:33:24.070Z"
      },
      {
        "id": "206",
        "title": "USER-TEST-4: User Validation Checkpoint 4",
        "description": "Manually test functionality from Tasks 200-202 (Polish & Optimization)",
        "details": "",
        "testStrategy": "",
        "status": "deferred",
        "dependencies": ["202"],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-02T20:33:24.086Z"
      },
      {
        "id": "207",
        "title": "Install Project Dependencies",
        "description": "Install new libraries required for the multi-agent system integration including LangChain, LangGraph, BullMQ, and Pino.",
        "details": "Execute 'npm install @langchain/core @langchain/langgraph @langchain/ollama @langchain/google-genai @langchain/groq bullmq pino'. Update package.json to ensure versions align with PRD specifications (LangGraph 0.2.x, BullMQ 5.x). Ensure 'engines' field in package.json is compatible with these libraries.",
        "testStrategy": "Run 'npm list' for each package to verify correct version installation. Run a smoke test by importing LangGraph in a script.",
        "priority": "high",
        "dependencies": [],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:39.618Z"
      },
      {
        "id": "208",
        "title": "Ollama Infrastructure Setup Script",
        "description": "Create a shell script to automate the provisioning of the Ollama server and download required models.",
        "details": "Create a script 'scripts/setup-ollama.sh' that: 1. Checks if Ollama is installed. 2. Pulls llama3.2:8b, mistral:7b, and phi3:mini. 3. Configures environment variables for OLLAMA_HOST and model aliases. Implement a health check utility to verify Ollama accessibility.",
        "testStrategy": "Execute the script on a development machine and verify using 'ollama list' that all three models are present and the health check utility returns 200.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:12:04.488Z"
      },
      {
        "id": "209",
        "title": "LangGraph Workflow Framework Skeleton",
        "description": "Initialize the core LangGraph structure and state management for the document processing pipeline.",
        "details": "Define the 'DocumentState' interface in 'src/multiagent/state.ts' including fields for document metadata, extracted data, classification, confidence scores, and processing logs. Create a base StateGraph instance in 'src/multiagent/workflow.ts'.",
        "testStrategy": "Unit test 'state.ts' to ensure state updates follow LangGraph immutability patterns using basic transition functions.",
        "priority": "high",
        "dependencies": ["207"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.189Z"
      },
      {
        "id": "210",
        "title": "Database Schema Extension for Multi-Agent State",
        "description": "Update the Prisma schema to support persistence for the multi-agent system, A/B testing, and shadow mode.",
        "details": "Add models to 'schema.prisma': MultiAgentProcessing (link to job ID, status), Checkpoint (binary state storage for LangGraph), ABTestAssignment (userId, variant, timestamp), UserFeedback (rating, comments), and ProcessingComparison (legacy vs multi-agent field diffs). Run 'prisma migrate dev'.",
        "testStrategy": "Verify database tables exist in PostgreSQL using 'prisma studio' and check the generated Prisma client for the new models.",
        "priority": "high",
        "dependencies": [],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:52.571Z"
      },
      {
        "id": "211",
        "title": "Feature Flag System Implementation",
        "description": "Implement a robust feature flag service to handle gradual rollout phases (Shadow, A/B, Primary).",
        "details": "Create 'src/services/FeatureFlagService.ts'. Implement logic to evaluate flags based on user context or random sampling: 'shadow-mode', 'multiagent-ab-test', 'multiagent-primary'. Use Prisma to store/retrieve flag configurations for runtime overrides.",
        "testStrategy": "Unit test FeatureFlagService to ensure 'multiagent-ab-test' returns true/false according to defined percentages and remains sticky for the same user.",
        "priority": "high",
        "dependencies": ["210"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.206Z"
      },
      {
        "id": "212",
        "title": "Migrate PoC Code to Main Repository",
        "description": "Refactor and move existing PoC agent logic into the quikadmin/src/multiagent directory.",
        "details": "Copy agent logic from PoC. Refactor to use current project logging (Pino) and error handling patterns. Update import paths to match 'quikadmin' structure. Resolve any TypeScript 'any' types introduced during PoC.",
        "testStrategy": "Run 'tsc' to ensure no compilation errors in the newly migrated files. Execute basic unit tests for individual agent utility functions.",
        "priority": "high",
        "dependencies": ["207", "209"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:39.636Z"
      },
      {
        "id": "213",
        "title": "BullMQ Multi-Agent Queue Initialization",
        "description": "Configure a new BullMQ instance to handle high-complexity multi-agent processing jobs separate from the legacy queue.",
        "details": "Create 'src/queues/multiagent.queue.ts'. Initialize BullMQ with the existing Upstash Redis connection. Configure worker options including concurrency limits (based on VRAM availability) and advanced retry strategies (exponential backoff).",
        "testStrategy": "Verify the queue connects to Redis using the BullMQ dashboard or by checking Redis keys 'bull:multiagent:*' via redis-cli.",
        "priority": "high",
        "dependencies": ["210"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.222Z"
      },
      {
        "id": "214",
        "title": "Document Classification Agent (Phi-3)",
        "description": "Implement the classification node using the Phi-3 Mini model for fast document type identification.",
        "details": "Implement 'classifyNode' in 'src/multiagent/nodes/classifier.ts'. Use @langchain/ollama to prompt Phi-3 with document snippets. Logic should output high-level categories (e.g., Invoice, ID, Contract). Set a confidence threshold for auto-routing.",
        "testStrategy": "Pass five different document text samples to the classifier and verify 100% accuracy for standard types.",
        "priority": "high",
        "dependencies": ["212"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:39.651Z"
      },
      {
        "id": "215",
        "title": "Extraction and Mapping Agents (Llama 8B / Mistral)",
        "description": "Implement extraction nodes using Llama 3.2 8B and field mapping nodes using Mistral 7B.",
        "details": "Create 'extractNode' and 'mapNode'. Extraction node uses Llama 8B for raw JSON output from OCR text. Mapping node uses Mistral to align extracted keys with the standard Prisma schema. Use JSON mode in LLM calls for structured output.",
        "testStrategy": "Compare extraction output against a ground truth JSON for a sample invoice and verify mapping accuracy.",
        "priority": "high",
        "dependencies": ["212"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:39.665Z"
      },
      {
        "id": "216",
        "title": "QA and Error Recovery Agents",
        "description": "Implement the QA agent (Llama 8B) for validation and Error Recovery agent for self-correction.",
        "details": "'qaNode' validates extraction against business rules (e.g., date formats, total sum math). 'errorRecoverNode' identifies specific failures and modifies prompts to re-attempt extraction/mapping. Integrate loop-back logic in LangGraph.",
        "testStrategy": "Inject a deliberate extraction error (e.g., mismatched total) and verify the QA node catches it and triggers the Recovery node.",
        "priority": "high",
        "dependencies": ["212"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:39.682Z"
      },
      {
        "id": "217",
        "title": "LangGraph Orchestrator Workflow Assembly",
        "description": "Assemble all agent nodes into a functional directed graph with conditional routing.",
        "details": "In 'src/multiagent/workflow.ts', connect nodes: classifier -> extractor -> mapper -> qa. Add conditional edges based on QA results (pass to finish, fail to errorRecover). Implement persistence using the Prisma-backed Checkpoint model.",
        "testStrategy": "Trace a full execution from classification to finish using a mock document and ensure all nodes are visited in order.",
        "priority": "high",
        "dependencies": ["214", "215", "216"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.237Z"
      },
      {
        "id": "218",
        "title": "Multi-Agent Queue Worker Service",
        "description": "Implement the BullMQ worker that executes the LangGraph workflow for each job.",
        "details": "Create 'src/workers/multiagent.worker.ts'. On job receive: 1. Fetch document from DB. 2. Initialize LangGraph state. 3. Execute workflow. 4. Update job progress in Redis/DB. 5. Emit 'processing:complete' event via RealtimeService.",
        "testStrategy": "Manually add a job to the multiagent queue and monitor logs to ensure the workflow completes and updates the database record.",
        "priority": "high",
        "dependencies": ["213", "217"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:39.697Z"
      },
      {
        "id": "219",
        "title": "Shadow Mode Logic Implementation",
        "description": "Hook into the existing document upload process to trigger the multi-agent pipeline in parallel with legacy processing.",
        "details": "In the main document controller, check 'shadow-mode' flag. If enabled, fire a non-blocking request to the multiagent-queue after the legacy queue job is dispatched. Do not wait for response to ensure zero latency impact on legacy path.",
        "testStrategy": "Upload a document and verify that two separate jobs are created: one in the Bull (Legacy) queue and one in the BullMQ (Multi-Agent) queue.",
        "priority": "medium",
        "dependencies": ["211", "218"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.253Z"
      },
      {
        "id": "220",
        "title": "Comparison Analytics Service",
        "description": "Develop a service to compare extraction results between legacy and multi-agent pipelines for accuracy validation.",
        "details": "Create 'src/services/ComparisonService.ts'. Logic should: 1. Wait for both pipelines to finish. 2. Fetch results. 3. Perform field-by-field diffing. 4. Calculate confidence delta. 5. Store report in 'ProcessingComparison' table.",
        "testStrategy": "Trigger a dual-process run and verify that a record is created in 'ProcessingComparison' with populated diff JSON.",
        "priority": "medium",
        "dependencies": ["219"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.267Z"
      },
      {
        "id": "221",
        "title": "A/B Test Routing Engine",
        "description": "Implement the logic to route a percentage of live traffic to the multi-agent system as the primary source of truth.",
        "details": "Modify document processing entry point. If 'multiagent-ab-test' is active and user is assigned to 'variant-b', skip the legacy pipeline and route exclusively to the multi-agent queue. Include fallback logic to legacy if the multi-agent system fails or times out.",
        "testStrategy": "Simulate 100 requests with a 10% A/B split and verify that approximately 10 requests are routed to the Multi-Agent pipeline.",
        "priority": "medium",
        "dependencies": ["211"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.282Z"
      },
      {
        "id": "222",
        "title": "Admin Control and Stats Endpoints",
        "description": "Create API endpoints for managing feature flags and viewing performance metrics.",
        "details": "Implement GET/PUT '/api/admin/ab-test/config' to update percentages. Implement GET '/api/admin/ab-test/stats' to aggregate data from 'ProcessingComparison' and 'UserFeedback' models. Restricted to 'admin' role.",
        "testStrategy": "Test endpoints with an admin JWT and verify they successfully update feature flag configurations in the database.",
        "priority": "medium",
        "dependencies": ["221"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.297Z"
      },
      {
        "id": "223",
        "title": "Cloud LLM Fallback Mechanism",
        "description": "Implement automatic failover to Gemini or Groq APIs when the local Ollama server is unavailable or slow.",
        "details": "Wrap Ollama calls in a 'ReliableLLM' service. Implement a circuit breaker pattern. If Ollama fails, switch to @langchain/google-genai or @langchain/groq using environment-stored API keys. Ensure identical prompt formatting across models.",
        "testStrategy": "Shut down the local Ollama service and verify that document processing continues using the Gemini API as a fallback.",
        "priority": "medium",
        "dependencies": ["207"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:52.586Z"
      },
      {
        "id": "224",
        "title": "Observability and Structured Logging",
        "description": "Integrate Pino logging and custom metrics for deep visibility into agent performance.",
        "details": "Implement structured logging with correlation IDs across all nodes. Export metrics for 'processing_time_per_node', 'llm_token_count', and 'agent_retry_count'. Configure Pino to omit any PII from logs.",
        "testStrategy": "Examine log output in the console to ensure structured JSON format and confirm no sensitive data (like user names/emails) is logged.",
        "priority": "medium",
        "dependencies": ["207"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:52.602Z"
      },
      {
        "id": "225",
        "title": "User Feedback Collection API",
        "description": "Implement endpoints to collect and store user feedback on processing accuracy for A/B testing evaluation.",
        "details": "Create POST '/api/feedback/processing' endpoint. Schema: jobId, accuracyRating (1-5), isCorrect (bool), userComments. Associate feedback with the 'ABTestAssignment' to differentiate between legacy and multi-agent satisfaction.",
        "testStrategy": "Submit a mock feedback request and verify the record is correctly linked to the processing job and test variant in the database.",
        "priority": "low",
        "dependencies": ["210"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.313Z"
      },
      {
        "id": "226",
        "title": "Final Integration and E2E Testing",
        "description": "Perform comprehensive end-to-end testing of the entire multi-agent pipeline under load.",
        "details": "Write Playwright/Jest E2E tests simulating document uploads across all phases (Shadow, A/B). Conduct a load test to ensure '100 concurrent jobs' requirement is met without VRAM exhaustion. Verify fallback logic triggers correctly.",
        "testStrategy": "Run the full suite of E2E tests in a staging environment. Verify that the final 'Success Metrics' (latency <30s) are met during a 50-document burst.",
        "priority": "medium",
        "dependencies": ["218", "223"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:55:07.779Z"
      },
      {
        "id": "227",
        "title": "Security: Remove Authentication Bypass in MultiAgent-PoC",
        "description": "Remove the hardcoded authentication bypass in the PoC middleware to ensure all requests are authenticated before processing.",
        "details": "Locate 'IntelliFill-MultiAgent-PoC/src/server/middleware/apiKeyAuth.ts'. Identify the logic on lines 37-41 that returns 'next()' regardless of API key validity. Remove this block to enforce a 'fail-closed' security posture. \n\nPseudo-code:\n// Before\nif (process.env.NODE_ENV === 'development') { return next(); }\n// After\nif (!apiKey || !isValid(apiKey)) { return res.status(401).send('Unauthorized'); }",
        "testStrategy": "Attempt to access PoC endpoints without an API key or with an invalid key. Verify that the server returns a 401 Unauthorized status instead of proceeding.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-02T19:06:23.355Z"
      },
      {
        "id": "228",
        "title": "Security: Implement Prompt Injection Sanitization Strategy",
        "description": "Add a sanitization utility function for document text before it is interpolated into LLM prompts to prevent prompt injection attacks. Create a simple, single-function solution (~10 lines) without Strategy pattern, interfaces, or classes.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "SIMPLIFIED PER PRD v2.0: Create a single utility function in 'quikadmin/src/utils/sanitizeLLMInput.ts'.\n\nImplementation:\n```typescript\n/**\n * Sanitizes user-provided text before interpolating into LLM prompts.\n * Removes template injections, bracket injections, and prompt override attempts.\n */\nexport function sanitizeLLMInput(input: string): string {\n  if (!input || typeof input !== 'string') return '';\n  \n  return input\n    // Remove template injection patterns ({{...}}, {%...%}, ${...})\n    .replace(/\\{\\{[^}]*\\}\\}/g, '')\n    .replace(/\\{%[^%]*%\\}/g, '')\n    .replace(/\\$\\{[^}]*\\}/g, '')\n    // Remove XML-style bracket injections (<system>, </system>, etc.)\n    .replace(/<\\/?\\s*(system|user|assistant|prompt|instruction)[^>]*>/gi, '')\n    // Remove common prompt override phrases (case-insensitive)\n    .replace(/ignore\\s+(all\\s+)?(previous|prior|above)\\s+(instructions?|prompts?)/gi, '')\n    .replace(/disregard\\s+(all\\s+)?(previous|prior|above)\\s+(instructions?|prompts?)/gi, '')\n    .replace(/forget\\s+(all\\s+)?(previous|prior|above)\\s+(instructions?|prompts?)/gi, '')\n    // Clean up extra whitespace\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n```\n\nFile location: quikadmin/src/utils/sanitizeLLMInput.ts\n\nIntegration points:\n- Used by multiagent workflow nodes in quikadmin/src/multiagent/workflow.ts before passing document text to LLM prompts\n- Follows existing utility pattern in quikadmin/src/utils/ (similar to piiSanitizer.ts but simpler)\n- NO Strategy pattern, NO interface, NO class - just ONE exported function",
        "testStrategy": "Create unit tests in quikadmin/src/utils/__tests__/sanitizeLLMInput.test.ts:\n\n1. Template injection tests:\n   - '{{system}}' → ''\n   - 'Hello {{ignore}}' → 'Hello'\n   - 'Text ${variable} more' → 'Text more'\n   - '{%template%}' → ''\n\n2. Bracket injection tests:\n   - '<system>override</system>' → 'override'\n   - '<SYSTEM>bypass</SYSTEM>' → 'bypass'\n   - '</assistant>' → ''\n   - '<prompt>' → ''\n\n3. Prompt override tests:\n   - 'Ignore previous instructions' → ''\n   - 'IGNORE ALL PRIOR PROMPTS' → ''\n   - 'disregard above instructions' → ''\n   - 'forget previous prompt' → ''\n\n4. Edge cases:\n   - null/undefined → ''\n   - Empty string → ''\n   - Normal text 'Hello world' → 'Hello world'\n   - Mixed: 'Valid {{inject}} text <system>bad</system>' → 'Valid text bad'\n\n5. Whitespace normalization:\n   - 'Multiple   spaces' → 'Multiple spaces'",
        "subtasks": [
          {
            "id": 1,
            "title": "Create sanitizeLLMInput.ts utility file",
            "description": "Create the sanitizeLLMInput.ts file in quikadmin/src/utils/ with the sanitizeLLMInput function",
            "dependencies": [],
            "details": "Create quikadmin/src/utils/sanitizeLLMInput.ts with a single exported function that:\n1. Handles null/undefined/non-string input by returning empty string\n2. Removes template injections: {{...}}, {%...%}, ${...}\n3. Removes XML bracket injections: <system>, </system>, <user>, <assistant>, <prompt>, <instruction>\n4. Removes prompt override phrases: 'ignore previous instructions', 'disregard prior prompts', etc.\n5. Normalizes whitespace and trims\n\nKeep it simple - approximately 10-15 lines of actual logic.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Write unit tests for sanitizeLLMInput",
            "description": "Create comprehensive unit tests in quikadmin/src/utils/__tests__/sanitizeLLMInput.test.ts",
            "dependencies": [],
            "details": "Test all sanitization patterns:\n- Template injections ({{...}}, {%...%}, ${...})\n- Bracket injections (<system>, </system>, <user>, etc.)\n- Prompt override phrases (ignore previous, disregard, forget)\n- Edge cases (null, undefined, empty string, normal text)\n- Whitespace normalization\n- Combined attack patterns\n\nFollow existing test patterns in quikadmin/src/utils/__tests__/piiSanitizer.test.ts",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Document usage and integration points",
            "description": "Add JSDoc comments to the function and document integration with multiagent workflow",
            "dependencies": [],
            "details": "Add clear JSDoc documentation explaining:\n- Purpose: Prevent prompt injection attacks\n- When to use: Before interpolating user/document text into LLM prompts\n- Integration: Used by multiagent workflow nodes (classifier, extractor, mapper, qa)\n- Example usage in workflow.ts nodes\n\nNote: Actual integration into workflow.ts is a separate task - this just documents how it should be used.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T19:41:00.776Z"
      },
      {
        "id": "229",
        "title": "Dependency Alignment: Express Downgrade and Tesseract Upgrade",
        "description": "Align Express and Tesseract versions across the project to ensure compatibility with the existing IntelliFill environment.",
        "details": "1. Downgrade PoC package.json Express from 5.x to 4.18.x. \n2. Upgrade Tesseract.js in both PoC and target codebase to 7.x. \n3. Update 'quikadmin/package.json' and 'IntelliFill-MultiAgent-PoC/package.json'. \n4. Audit async error handlers in PoC code since Express 4 doesn't support async errors by default (wrap in try-catch/next).",
        "testStrategy": "Run 'npm install' and ensure no peer dependency conflicts. Verify Tesseract 7 initialization in a small script.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-02T19:34:27.561Z"
      },
      {
        "id": "230",
        "title": "Database Schema: MultiAgentProcessingRecord Model",
        "description": "Add a new Prisma model to track the status and results of multi-agent document processing tasks.",
        "details": "Update 'schema.prisma' with the 'MultiAgentProcessingRecord' model as specified in the PRD. \n\nPseudo-code:\nmodel MultiAgentProcessingRecord {\n  id String @id @default(uuid())\n  documentId String\n  userId String\n  status String // pending, processing, completed, failed\n  extractedData Json?\n  processingTimeMs Int?\n  error String?\n  createdAt DateTime @default(now())\n  completedAt DateTime?\n  @@index([documentId])\n  @@index([userId])\n}",
        "testStrategy": "Run 'prisma migrate dev' to apply changes. Verify table creation in the database using a GUI or Prisma Studio.",
        "priority": "medium",
        "dependencies": ["229"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.329Z"
      },
      {
        "id": "231",
        "title": "Core Integration: Define MultiAgent Interfaces",
        "description": "Create the core interfaces for document processing following the program-to-interfaces principle.",
        "details": "Create 'quikadmin/src/services/multiagent/interfaces.ts'. \n\nPseudo-code:\nexport interface IProcessingResult { success: boolean; data?: any; error?: string; }\nexport interface IDocumentProcessor {\n  process(documentId: string, userId: string): Promise<IProcessingResult>;\n}",
        "testStrategy": "No execution. Static type check using TypeScript compiler.",
        "priority": "medium",
        "dependencies": [],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.345Z"
      },
      {
        "id": "232",
        "title": "Service: Create MultiAgentAdapter Implementation",
        "description": "Implement the Adapter pattern to bridge the MultiAgent-PoC logic with the IntelliFill IDocumentProcessor interface.",
        "details": "Location: 'quikadmin/src/services/multiagent/MultiAgentAdapter.ts'. This service will wrap the PoC's main entry point, converting its output format into the IntelliFill format.\n\nPseudo-code:\nclass MultiAgentAdapter implements IDocumentProcessor {\n  async process(docId: string, userId: string) {\n    const pocResult = await pocRunner.run(docId);\n    return { success: true, data: this.mapToStandard(pocResult) };\n  }\n  private mapToStandard(pocData: any) { /* mapping logic */ }\n}",
        "testStrategy": "Unit test 'process' method with mocked PoC runner to ensure it returns correctly mapped data objects.",
        "priority": "medium",
        "dependencies": ["231", "228"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.360Z"
      },
      {
        "id": "233",
        "title": "Service: Implement ProcessingService with Strategy Pattern",
        "description": "Create a ProcessingService that allows switching between legacy and multi-agent processing strategies.",
        "details": "Location: 'quikadmin/src/services/ProcessingService.ts'. \n\nPseudo-code:\nclass ProcessingService {\n  private strategy: IDocumentProcessor;\n  constructor(strategy: IDocumentProcessor) { this.strategy = strategy; }\n  setStrategy(strategy: IDocumentProcessor) { this.strategy = strategy; }\n  async execute(docId: string, userId: string) { return this.strategy.process(docId, userId); }\n}",
        "testStrategy": "Verify that swapping strategies at runtime changes the execution path using unit tests.",
        "priority": "medium",
        "dependencies": ["232"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T18:42:21.374Z"
      },
      {
        "id": "234",
        "title": "Queue: Register multiAgentProcess Job Type",
        "description": "Update the existing knowledgeQueue to support the new multi-agent processing job type.",
        "details": "Modify 'quikadmin/src/queues/knowledgeQueue.ts'. \n1. Add 'multiAgentProcess' to the KnowledgeJobType union. \n2. Add a helper function 'addMultiAgentProcessJob(data)' using the Bull queue instance.\n\nPseudo-code:\nexport type KnowledgeJobType = 'single' | 'batch' | 'multiAgentProcess';\nexport const addMultiAgentProcessJob = (data: any) => knowledgeQueue.add('multiAgentProcess', data);",
        "testStrategy": "Call 'addMultiAgentProcessJob' in a test script and verify that the job appears in the Bull queue (e.g., via Bull-Board or Redis CLI).",
        "priority": "medium",
        "dependencies": ["233"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-02T20:10:33.654Z"
      },
      {
        "id": "235",
        "title": "Worker: MultiAgent Queue Processor",
        "description": "Add inline queue processor to multiagentQueue.ts that handles 'multiAgentProcess' jobs using the LangGraph processDocument workflow and updates the Document model.",
        "status": "done",
        "dependencies": ["234"],
        "priority": "medium",
        "details": "**SIMPLIFIED PER PRD v2.0**: No separate worker file, no Command pattern.\n\n**Location**: `quikadmin/src/queues/multiagentQueue.ts` (existing file)\n\n**Implementation**:\n1. Add a BullMQ Worker directly in `multiagentQueue.ts`\n2. Import `processDocument` from `../multiagent`\n3. Create inline processor that:\n   - Updates Document status to 'PROCESSING' on job start\n   - Calls `processDocument(job.data.documentId, job.data.userId, job.id, job.data.filePath, job.data.fileName, job.data.fileType, job.data.fileSize)`\n   - On success: Update Document with extracted data, confidence, processedAt, status='COMPLETED'\n   - On failure: Update Document status='FAILED' with error message\n\n**Code structure**:\n```typescript\n// In multiagentQueue.ts, after queue initialization\nimport { processDocument } from '../multiagent';\n\nlet multiagentWorker: Worker<MultiAgentProcessingJob, MultiAgentProcessingResult> | null = null;\n\nexport async function startMultiagentWorker(): Promise<void> {\n  if (!isMultiagentQueueAvailable()) {\n    logger.warn('Cannot start worker - queue not available');\n    return;\n  }\n\n  multiagentWorker = new Worker<MultiAgentProcessingJob, MultiAgentProcessingResult>(\n    'multiagent-processing',\n    async (job) => {\n      const { documentId, userId, filePath, fileName, fileType, fileSize } = job.data;\n      \n      // Update status to processing\n      await prisma.document.update({\n        where: { id: documentId },\n        data: { status: 'PROCESSING' },\n      });\n\n      try {\n        // Execute LangGraph workflow\n        const result = await processDocument(\n          documentId,\n          userId,\n          job.id || `job-${Date.now()}`,\n          filePath,\n          fileName,\n          fileType,\n          fileSize\n        );\n\n        // Update document with results\n        await prisma.document.update({\n          where: { id: documentId },\n          data: {\n            status: result.results.success ? 'COMPLETED' : 'FAILED',\n            extractedData: result.results.finalData,\n            confidence: result.results.confidence.overall,\n            processedAt: new Date(),\n          },\n        });\n\n        return {\n          documentId,\n          success: result.results.success,\n          extractedData: result.results.finalData,\n          confidence: result.results.confidence.overall,\n          processingTimeMs: result.results.processingTimeMs,\n        };\n      } catch (error) {\n        await prisma.document.update({\n          where: { id: documentId },\n          data: {\n            status: 'FAILED',\n            extractedData: { error: error instanceof Error ? error.message : 'Unknown error' },\n          },\n        });\n        throw error;\n      }\n    },\n    {\n      connection: redisConfig,\n      concurrency: 2, // Limit based on VRAM availability\n    }\n  );\n\n  multiagentWorker.on('completed', (job, result) => {\n    logger.info('Multi-agent job completed by worker', { jobId: job.id, documentId: result.documentId });\n  });\n\n  multiagentWorker.on('failed', (job, error) => {\n    logger.error('Multi-agent job failed', { jobId: job?.id, error: error.message });\n  });\n\n  logger.info('Multi-agent worker started');\n}\n```\n\n**Files to modify**:\n- `quikadmin/src/queues/multiagentQueue.ts` - Add Worker implementation inline\n\n**NO separate files needed**:\n- ~~`quikadmin/src/workers/multiAgentProcessor.ts`~~ (not needed per PRD v2.0)\n- ~~Command pattern~~ (not needed per PRD v2.0)\n- ~~MultiAgentProcessingRecord model~~ (use existing Document model)",
        "testStrategy": "1. Unit test: Mock the `processDocument` function and verify worker calls it with correct parameters\n2. Integration test: Add a job via `enqueueMultiagentProcessing()` and verify:\n   - Document status changes to 'PROCESSING' immediately\n   - `processDocument` is invoked with correct job data\n   - Document status changes to 'COMPLETED' with extractedData populated\n3. Error handling test: Simulate `processDocument` failure and verify Document status='FAILED'\n4. Concurrency test: Verify only 2 jobs process simultaneously",
        "subtasks": [
          {
            "id": 1,
            "title": "Import processDocument and Worker from dependencies",
            "description": "Add necessary imports to multiagentQueue.ts for the LangGraph workflow and BullMQ Worker",
            "dependencies": [],
            "details": "Add imports at top of multiagentQueue.ts:\n- `import { processDocument } from '../multiagent';`\n- Ensure `Worker` is imported from 'bullmq' (already imported but verify)\n- Add worker instance variable: `let multiagentWorker: Worker<...> | null = null;`",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement startMultiagentWorker function with inline processor",
            "description": "Create the worker function that processes multiagent jobs by calling processDocument and updating Document status",
            "dependencies": [],
            "details": "Implement `startMultiagentWorker()` function that:\n1. Creates BullMQ Worker with 'multiagent-processing' queue name\n2. Updates Document.status to 'PROCESSING' on job start\n3. Calls `processDocument(documentId, userId, jobId, filePath, fileName, fileType, fileSize)`\n4. On success: Updates Document with extractedData, confidence, processedAt, status='COMPLETED'\n5. On failure: Updates Document status='FAILED' with error in extractedData\n6. Uses concurrency: 2 to limit parallel processing",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add worker event handlers for logging",
            "description": "Attach event handlers to the worker for completed/failed job logging",
            "dependencies": [],
            "details": "Add event handlers to multiagentWorker:\n- `worker.on('completed', ...)` - Log success with jobId and documentId\n- `worker.on('failed', ...)` - Log error with jobId and error message\n- `worker.on('error', ...)` - Log worker-level errors",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add closeMultiagentWorker function for graceful shutdown",
            "description": "Implement cleanup function to gracefully close the worker on process termination",
            "dependencies": [],
            "details": "Add `closeMultiagentWorker()` function that:\n1. Calls `multiagentWorker.close()` if worker exists\n2. Sets `multiagentWorker = null`\n3. Update existing `closeMultiagentQueue()` to also call `closeMultiagentWorker()`\n4. Ensure SIGTERM/SIGINT handlers close both queue and worker",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Export worker functions from multiagentQueue.ts",
            "description": "Export the new worker functions for use in app initialization",
            "dependencies": [],
            "details": "Add exports:\n- `export { startMultiagentWorker, closeMultiagentWorker }`\n- Update module exports if needed for proper initialization flow\n- Document that `startMultiagentWorker()` should be called after `initializeMultiagentQueue()`",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T20:47:27.453Z"
      },
      {
        "id": "236",
        "title": "API: Implementation of MultiAgent Endpoints",
        "description": "Create the new API routes for initiating multi-agent processing and checking status.",
        "details": "Location: 'quikadmin/src/api/multiagent.routes.ts'. \n1. POST '/api/process/multiagent': Creates record, adds job to queue. \n2. GET '/api/process/multiagent/:jobId/status': Returns current DB record status.\n\nPseudo-code:\nrouter.post('/multiagent', async (req, res) => {\n  const record = await prisma.multiAgentProcessingRecord.create({ data: { ... } });\n  await addMultiAgentProcessJob({ recordId: record.id, ... });\n  res.json({ jobId: record.id });\n});",
        "testStrategy": "Use Postman or Curl to hit POST /api/process/multiagent. Verify 200 OK and receipt of jobId. Hit GET status endpoint with jobId to verify 'pending' state.",
        "priority": "medium",
        "dependencies": ["235"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-02T20:51:03.900Z"
      },
      {
        "id": "237",
        "title": "Testing: Unit Tests for Integration Components",
        "description": "Write comprehensive unit tests for the Adapter, Strategy, and Sanitizer components.",
        "details": "Target 80% coverage. Focus on 'MultiAgentAdapter.ts' (mapping accuracy), 'Sanitizer.ts' (injection prevention), and 'ProcessingService.ts' (strategy switching logic). Use Jest or Mocha as per project standards.",
        "testStrategy": "Run 'npm run test:unit' and review the coverage report to ensure target percentage is met for the new files in 'quikadmin/src/services/multiagent'.",
        "priority": "medium",
        "dependencies": ["232", "233"],
        "status": "cancelled",
        "subtasks": [],
        "updatedAt": "2026-01-02T20:52:08.861Z"
      },
      {
        "id": "238",
        "title": "Testing: Integration and Smoke Tests",
        "description": "Perform end-to-end integration testing of the document processing pipeline using real document samples.",
        "details": "1. Run integration tests covering the Queue -> Worker -> DB flow. \n2. Perform smoke tests with three document types: passport, invoice, and ID card. \n3. Validate that processing time for P95 is under 30 seconds.",
        "testStrategy": "Trigger the full flow via API and monitor logs/database until completion. Use a timer to measure performance and verify extracted JSON accuracy for each document type.",
        "priority": "medium",
        "dependencies": ["236", "237"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-02T20:56:54.777Z"
      },
      {
        "id": "239",
        "title": "Add multiAgentResult Column to Document Model",
        "description": "Add a single optional Json column `multiAgentResult` to the existing Document model in the Prisma schema to store multi-agent processing results alongside the legacy extractedData field.",
        "details": "## Implementation Steps\n\n### 1. Update Prisma Schema\nEdit `quikadmin/prisma/schema.prisma` and add the new column to the Document model (around line 315-316, after `extractedData`):\n\n```prisma\nmodel Document {\n  id                 String         @id @default(uuid())\n  userId             String\n  user               User           @relation(fields: [userId], references: [id], onDelete: Cascade)\n  fileName           String\n  fileType           String\n  fileSize           Int\n  storageUrl         String\n  status             DocumentStatus @default(PENDING)\n  extractedText      String?\n  extractedData      Json?\n  multiAgentResult   Json?          @map(\"multi_agent_result\")  // NEW: Multi-agent pipeline results\n  confidence         Float?\n  templateId         String?\n  template           Template?      @relation(fields: [templateId], references: [id])\n  processedAt        DateTime?\n  reprocessCount     Int            @default(0) @map(\"reprocess_count\")\n  lastReprocessedAt  DateTime?      @map(\"last_reprocessed_at\")\n  reprocessingHistory Json?         @map(\"reprocessing_history\")\n  createdAt          DateTime       @default(now())\n  updatedAt          DateTime       @updatedAt\n\n  @@map(\"documents\")\n}\n```\n\n### 2. Expected JSON Structure for multiAgentResult\nThe column should store data matching the `DocumentState.results` structure from `quikadmin/src/multiagent/types/state.ts`:\n\n```typescript\ninterface MultiAgentResult {\n  success: boolean;\n  finalData: Record<string, unknown>;  // Extracted fields\n  confidence: {\n    overall: number;  // 0-100\n    byField: Record<string, number>;\n  };\n  processingTimeMs: number;\n  needsReview: boolean;\n  reviewReasons: string[];\n  // Optional metadata\n  pipelineVersion?: string;\n  agentHistory?: Array<{\n    agent: string;\n    status: string;\n    processingTimeMs: number;\n  }>;\n}\n```\n\n### 3. Run Prisma Migration\nExecute the migration from the quikadmin directory:\n\n```bash\ncd quikadmin\nnpx prisma migrate dev --name add_multi_agent_result_to_document\n```\n\n### 4. Regenerate Prisma Client\nThe migration command automatically regenerates the client, but if needed:\n\n```bash\nnpx prisma generate\n```\n\n## Key Considerations\n\n- **Minimal Change**: This is a non-breaking additive change - existing code continues to work\n- **Column Mapping**: Use `@map(\"multi_agent_result\")` for snake_case in the database while keeping camelCase in TypeScript\n- **Nullable**: The `Json?` type ensures the column is nullable, so existing documents won't be affected\n- **No New Model**: Per requirements, this adds to the existing Document model rather than creating a new MultiAgentProcessingRecord model\n- **Relationship with Existing Models**: The `MultiAgentProcessing` model (line 650) already tracks job-level data separately - this column stores the final results directly on the Document for quick access",
        "testStrategy": "## Verification Steps\n\n### 1. Migration Success\n```bash\ncd quikadmin\nnpx prisma migrate dev --name add_multi_agent_result_to_document\n```\n- Confirm migration completes without errors\n- Check `.prisma/migrations/` for new migration file\n\n### 2. Database Verification\nUse Prisma Studio to verify:\n```bash\nnpx prisma studio\n```\n- Navigate to the `documents` table\n- Confirm `multi_agent_result` column exists\n- Verify column is nullable (NULL values allowed)\n- Verify column type is `jsonb` (PostgreSQL)\n\n### 3. TypeScript Type Check\n```bash\nnpm run typecheck\n# or\nnpx tsc --noEmit\n```\n- Ensure no TypeScript errors related to Prisma client\n- Verify `PrismaClient.document` type includes `multiAgentResult: Prisma.JsonValue | null`\n\n### 4. Test CRUD Operations\nCreate a simple test script or use Prisma Studio:\n```typescript\n// Test write\nawait prisma.document.update({\n  where: { id: 'test-doc-id' },\n  data: {\n    multiAgentResult: {\n      success: true,\n      finalData: { name: 'Test' },\n      confidence: { overall: 95, byField: {} },\n      processingTimeMs: 1500,\n      needsReview: false,\n      reviewReasons: []\n    }\n  }\n});\n\n// Test read\nconst doc = await prisma.document.findUnique({\n  where: { id: 'test-doc-id' },\n  select: { multiAgentResult: true }\n});\nconsole.log(doc?.multiAgentResult);\n```\n\n### 5. Existing Functionality Regression Test\n- Verify existing document upload/processing still works\n- Confirm `extractedData` field is unaffected\n- Run any existing document-related tests",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-02T19:47:25.245Z"
      },
      {
        "id": "240",
        "title": "Create MultiAgentService Thin Wrapper",
        "description": "Create a minimal MultiAgentService class in quikadmin/src/services/MultiAgentService.ts that sanitizes input and delegates to the multiagent PoC's CompatibilityLayer for document processing.",
        "details": "## Implementation Details\n\nCreate a thin wrapper service class (~30 lines) at `quikadmin/src/services/MultiAgentService.ts`:\n\n### File Structure\n```typescript\nimport { processDocument, DocumentState } from '../multiagent';\nimport { sanitizeLLMInput } from '../utils/sanitizeLLMInput';\n\nexport interface MultiAgentProcessInput {\n  documentId: string;\n  userId: string;\n  rawText: string;\n  jobId?: string;\n  filePath?: string;\n  fileName?: string;\n  fileType?: string;\n  fileSize?: number;\n}\n\nexport class MultiAgentService {\n  /**\n   * Process a document through the multi-agent pipeline.\n   * Sanitizes input before delegating to CompatibilityLayer.\n   */\n  async process(input: MultiAgentProcessInput): Promise<DocumentState> {\n    const sanitizedText = sanitizeLLMInput(input.rawText);\n    \n    return processDocument(\n      input.documentId,\n      input.userId,\n      input.jobId || `job-${Date.now()}`,\n      input.filePath || '',\n      input.fileName || 'unknown',\n      input.fileType || 'application/octet-stream',\n      input.fileSize || 0\n    );\n  }\n}\n```\n\n### Key Considerations\n\n1. **Import Path**: Use relative import from `../multiagent` which exports `processDocument` from `quikadmin/src/multiagent/index.ts`\n\n2. **Dependency on sanitizeLLMInput**: This utility must be created first (SEC-02 task) at `quikadmin/src/utils/sanitizeLLMInput.ts`\n\n3. **No Additional Abstractions**: Per the dev PRD, do NOT add:\n   - Strategy pattern\n   - Factory pattern\n   - Additional adapter layers\n   - Interface files (use types from multiagent module directly)\n\n4. **Type Reuse**: Import `DocumentState` from the multiagent module as the return type to maintain type safety without creating duplicate interfaces\n\n5. **Optional Fields**: The `jobId`, `filePath`, `fileName`, `fileType`, and `fileSize` parameters have sensible defaults for cases where only documentId, userId, and rawText are available\n\n### Why This Approach\n\n- **KISS Principle**: Single responsibility - sanitize and delegate\n- **YAGNI**: No unnecessary patterns or abstractions\n- **Uses Existing Infrastructure**: Leverages the already-implemented multiagent workflow\n- **Testable**: Easy to mock the `processDocument` function for unit testing",
        "testStrategy": "## Test Strategy\n\n### Unit Tests (quikadmin/src/services/__tests__/MultiAgentService.test.ts)\n\n1. **Input Sanitization Verification**\n   - Mock `sanitizeLLMInput` and `processDocument`\n   - Call `service.process()` with input containing injection patterns\n   - Verify `sanitizeLLMInput` was called with the raw text\n   - Verify `processDocument` received sanitized text\n\n2. **Delegation to processDocument**\n   - Mock `processDocument` to return a known `DocumentState`\n   - Call `service.process()` with valid input\n   - Verify all parameters are passed correctly to `processDocument`\n   - Verify the return value matches the mock result\n\n3. **Default Parameter Handling**\n   - Call `service.process()` with minimal input (only documentId, userId, rawText)\n   - Verify default values are used for optional fields\n\n4. **Error Propagation**\n   - Mock `processDocument` to throw an error\n   - Verify the error propagates correctly to the caller\n\n### Integration Tests\n\n1. **End-to-End Flow**\n   - Use real multiagent module (if Ollama is available in test environment)\n   - Process a small test document\n   - Verify DocumentState result structure\n\n### Test Commands\n```bash\n# Run unit tests\nnpm test -- --testPathPattern=\"MultiAgentService\"\n\n# Run with coverage\nnpm test -- --coverage --testPathPattern=\"MultiAgentService\"\n```\n\n### Expected Coverage: 90%+ for this service (it's a thin wrapper, so high coverage is easily achievable)",
        "status": "done",
        "dependencies": ["208"],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-02T19:51:36.976Z"
      },
      {
        "id": "241",
        "title": "Link MultiAgent-PoC as Local npm Package",
        "description": "Configure IntelliFill-MultiAgent-PoC as a local dependency in quikadmin/package.json using file: protocol or npm link, ensuring CompatibilityLayer is exported from the PoC package for import as @intellifill/multiagent-poc.",
        "details": "## Implementation Details\n\n### 1. Package Location Configuration\n\nThe MultiAgent-PoC must be accessible as a sibling directory to the IntelliFill project. Expected structure:\n```\nN:\\\n├── IntelliFill/\n│   └── quikadmin/\n│       └── package.json  ← Will reference PoC\n└── IntelliFill-MultiAgent-PoC/\n    ├── package.json      ← Must export CompatibilityLayer\n    └── src/\n        └── index.ts      ← Main entry with exports\n```\n\n### 2. Update PoC package.json\n\nEnsure the PoC package exports correctly:\n```json\n{\n  \"name\": \"@intellifill/multiagent-poc\",\n  \"version\": \"1.0.0\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n  }\n}\n```\n\n### 3. Create/Verify PoC Exports (src/index.ts)\n\nThe PoC must export CompatibilityLayer:\n```typescript\n// IntelliFill-MultiAgent-PoC/src/index.ts\nexport { CompatibilityLayer } from './compatibility/CompatibilityLayer';\nexport { DocumentState } from './types/state';\n// ... other needed exports\n```\n\n### 4. Add Local Dependency to quikadmin/package.json\n\n**Option A (Recommended): file: protocol**\n```json\n{\n  \"dependencies\": {\n    \"@intellifill/multiagent-poc\": \"file:../../IntelliFill-MultiAgent-PoC\"\n  }\n}\n```\n\n**Option B: npm link (development)**\n```bash\n# In PoC directory\ncd N:\\IntelliFill-MultiAgent-PoC\nnpm link\n\n# In quikadmin directory\ncd N:\\IntelliFill\\quikadmin\nnpm link @intellifill/multiagent-poc\n```\n\n### 5. Build PoC Before Linking\n\nThe PoC must be built before linking:\n```bash\ncd N:\\IntelliFill-MultiAgent-PoC\nnpm install\nnpm run build  # Generates dist/ with compiled JS\n```\n\n### 6. TypeScript Configuration\n\nUpdate quikadmin/tsconfig.json if needed:\n```json\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@intellifill/multiagent-poc\": [\"../../IntelliFill-MultiAgent-PoC/dist\"]\n    }\n  }\n}\n```\n\n### 7. Verify Import Works\n\nAfter linking, this import should work in quikadmin:\n```typescript\n// quikadmin/src/services/MultiAgentService.ts\nimport { CompatibilityLayer, DocumentState } from '@intellifill/multiagent-poc';\n```\n\n### 8. CompatibilityLayer Interface Requirements\n\nThe CompatibilityLayer class must expose:\n```typescript\nexport class CompatibilityLayer {\n  async processDocument(input: {\n    documentId: string;\n    userId: string;\n    rawText: string;\n  }): Promise<ProcessingResult>;\n}\n```\n\n### 9. Handling npm vs pnpm/bun\n\nSince quikadmin uses npm (per package.json scripts), use file: protocol which is npm-native. For bun-based frontend, ensure compatibility:\n```bash\n# In quikadmin\nnpm install  # Will resolve file: dependency\n```\n\n### 10. .gitignore Consideration\n\nAdd node_modules linking artifacts if using npm link:\n```gitignore\n# Local package links\n.pnp.*\n```",
        "testStrategy": "## Verification Steps\n\n### 1. Package Resolution Test\n```bash\ncd N:\\IntelliFill\\quikadmin\nnpm ls @intellifill/multiagent-poc\n```\nExpected: Shows local file path, no errors\n\n### 2. Import Verification\nCreate a test file:\n```typescript\n// quikadmin/src/__test_import__.ts\nimport { CompatibilityLayer } from '@intellifill/multiagent-poc';\nconst layer = new CompatibilityLayer();\nconsole.log('Import successful:', typeof layer.processDocument === 'function');\n```\nRun: `npx ts-node src/__test_import__.ts`\nExpected: \"Import successful: true\"\n\n### 3. TypeScript Compilation Check\n```bash\ncd N:\\IntelliFill\\quikadmin\nnpx tsc --noEmit\n```\nExpected: No errors related to @intellifill/multiagent-poc imports\n\n### 4. Build Verification\n```bash\nnpm run build\n```\nExpected: Build completes without module resolution errors\n\n### 5. Runtime Test\n```bash\nnpm run dev\n# In another terminal:\ncurl -X POST http://localhost:3002/api/health\n```\nExpected: Server starts without import errors\n\n### 6. Verify CompatibilityLayer Export\n```bash\nnode -e \"const pkg = require('@intellifill/multiagent-poc'); console.log('CompatibilityLayer:', typeof pkg.CompatibilityLayer)\"\n```\nExpected: \"CompatibilityLayer: function\"\n\n### 7. Clean Install Test\n```bash\nrm -rf node_modules\nnpm install\nnpm run build\n```\nExpected: Fresh install correctly resolves local package",
        "status": "done",
        "dependencies": ["208"],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-02T20:05:08.556Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-02T21:05:27.993Z",
      "taskCount": 55,
      "completedCount": 27,
      "tags": ["master"]
    }
  }
}
