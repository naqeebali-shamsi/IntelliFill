{
  "master": {
    "tasks": [
      {
        "id": "157",
        "title": "Documentation Discovery and Inventory",
        "description": "Audit all existing documentation files across the IntelliFill codebase to create a comprehensive inventory of documentation assets, their locations, types, and metadata.",
        "details": "## Implementation Steps\n\n### 1. Scan All Documentation Locations\n```bash\n# Primary locations to scan\ndocs/                          # Main documentation hub (50+ files)\nCLAUDE.local.md               # Root AI context\nquikadmin/CLAUDE.md           # Backend context (1500+ lines)\nquikadmin-web/CLAUDE.md       # Frontend context (550+ lines)\n.claude/skills/               # 15 skill files\n**/README.md                  # Project READMEs\n```\n\n### 2. Create Inventory Schema\n```typescript\ninterface DocInventory {\n  path: string;\n  title: string;\n  category: 'tutorial' | 'how-to' | 'reference' | 'explanation' | 'ai-context' | 'skill';\n  format: 'markdown' | 'json';\n  lines: number;\n  lastModified: Date;\n  frontmatter: boolean;\n  crossReferences: string[];\n  status: 'active' | 'draft' | 'deprecated' | 'archived';\n}\n```\n\n### 3. Document Categories Found\n- **docs/tutorials/** - Learning-oriented (getting-started.md, first-document.md, understanding-workflow.md)\n- **docs/how-to/** - Problem-oriented (deployment, development, troubleshooting)\n- **docs/reference/** - Technical specs (api, architecture, database, configuration)\n- **docs/explanation/** - Conceptual (data-flow.md, security-model.md, architecture-decisions.md)\n- **docs/ai-development/** - AI agent guides (agentic-workflows.md, mcp-integration.md)\n- **docs/.meta/** - Templates and migration guides\n- **docs/prd/** - PRD documents\n- **docs/architecture/** - Architecture docs (dynamic-pii-architecture.md)\n- **docs/strategy/** - Go-to-market, feasibility analysis\n- **docs/claude-audit/** - Setup reports\n- **docs/debug/** - Debug evidence\n- **docs/sales/** - Sales prompts\n- **docs/tech-debt/** - Tech stability audit\n\n### 4. CLAUDE.md File Analysis\n- Root: CLAUDE.local.md (~65 lines) - concise, optimized\n- quikadmin/CLAUDE.md (~1500 lines) - comprehensive backend context\n- quikadmin-web/CLAUDE.md (~555 lines) - frontend patterns\n- quikadmin/.taskmaster/CLAUDE.md - Task Master integration\n\n### 5. Skills Directory Analysis\n15 skills covering: auth-flow, backend-api, browser-testing, docker-devops, documentation, e2e-testing, file-upload, frontend-component, frontend-design, prisma-database, queue-worker, testing, ui-components, zustand-store\n\n### 6. Output Format\nGenerate `docs/.meta/inventory.json` with complete file listing",
        "testStrategy": "1. Verify inventory captures all 50+ docs files\n2. Confirm all CLAUDE.md variants are catalogued\n3. Validate all 15 skills are documented\n4. Check inventory JSON validates against schema\n5. Cross-reference with `find docs/ -name \"*.md\" | wc -l` to ensure completeness\n6. Verify no node_modules README files are incorrectly included",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scan and Catalog All Documentation File Locations",
            "description": "Recursively scan the entire IntelliFill codebase to identify all documentation files across primary locations (docs/, CLAUDE.md files, .claude/skills/, README.md files) and capture file metadata including path, size, and modification date.",
            "dependencies": [],
            "details": "Execute a comprehensive file system scan targeting:\n- docs/ directory (55 markdown files identified)\n- Root CLAUDE.local.md\n- quikadmin/CLAUDE.md (~1500 lines)\n- quikadmin-web/CLAUDE.md (~555 lines)\n- quikadmin/.taskmaster/CLAUDE.md\n- .claude/skills/ directory (15 SKILL.md files + README.md)\n- **/README.md files (quikadmin/README.md, quikadmin-web/README.md)\n\nFor each file, capture: absolute path, filename, extension, file size in bytes, last modified timestamp. Store results in a structured format for processing in subsequent steps.",
            "status": "pending",
            "testStrategy": "Verify scan captures all 55+ docs files, 4 CLAUDE.md variants, 15 skills, and project READMEs. Cross-reference with `find docs/ -name '*.md' | wc -l` output.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Parse File Content and Extract Metadata",
            "description": "Read each catalogued documentation file to extract content metadata including YAML frontmatter, title, category, line count, presence of code examples, and internal cross-references.",
            "dependencies": [
              1
            ],
            "details": "For each file from Step 1:\n1. Read file content and count lines\n2. Detect and parse YAML frontmatter (title, description, category, tags, lastUpdated, status)\n3. Identify document category using Diataxis framework: 'tutorial', 'how-to', 'reference', 'explanation', 'ai-context', 'skill'\n4. Detect code blocks (```language) and count examples\n5. Extract internal markdown links to other documentation files\n6. Identify status indicators (active, draft, deprecated, archived)\n7. Parse last updated dates from frontmatter or file metadata\n\nSkills follow SKILL.md pattern, CLAUDE.md files are ai-context category.",
            "status": "pending",
            "testStrategy": "Validate frontmatter parsing on 10 random files. Confirm all 15 skills are categorized as 'skill'. Verify CLAUDE.md files marked as 'ai-context'.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Map Cross-References and Document Relationships",
            "description": "Analyze all documentation files to build a dependency graph showing which documents reference others, identifying orphaned documents and key hub documents.",
            "dependencies": [
              2
            ],
            "details": "Process extracted cross-references from Step 2:\n1. Build adjacency list of document relationships (source -> [targets])\n2. Identify hub documents with high inbound links (docs/README.md, CLAUDE.local.md)\n3. Detect orphaned documents (no inbound links except from indexes)\n4. Map the documentation reading flow as defined in docs/.meta/STRUCTURE_DIAGRAM.md\n5. Categorize relationships: 'parent-child', 'related', 'depends-on', 'summarizes'\n6. Identify broken internal links (references to non-existent files)\n7. Track external links for later validation\n\nOutput relationship data compatible with docs/.meta/relationships.json format.",
            "status": "pending",
            "testStrategy": "Verify docs/README.md shows as hub with highest inbound links. Confirm no false orphan detection for intentionally standalone files. Check relationship types are correctly classified.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Classify Documents by Diataxis Category and AI Priority",
            "description": "Apply consistent categorization to all documents using the Diataxis framework (tutorials, how-to, reference, explanation) plus AI-specific categories (ai-context, skill), and assign AI consumption priority levels.",
            "dependencies": [
              2
            ],
            "details": "For each document:\n1. Assign primary Diataxis category based on path and content:\n   - docs/tutorials/* -> 'tutorial'\n   - docs/how-to/* -> 'how-to'\n   - docs/reference/* -> 'reference'\n   - docs/explanation/* -> 'explanation'\n   - docs/ai-development/* -> 'ai-development'\n   - .claude/skills/* -> 'skill'\n   - **/CLAUDE.md, CLAUDE.local.md -> 'ai-context'\n   - docs/prd/* -> 'prd'\n   - docs/architecture/* -> 'architecture'\n   - docs/strategy/* -> 'strategy'\n2. Assign AI priority level: 'critical' (CLAUDE.md, quick-start), 'important' (architecture, api), 'reference' (database, config), 'archive' (debug, claude-audit)\n3. Map to proposed structure from docs/.meta/STRUCTURE_DIAGRAM.md\n4. Flag documents needing migration to new numbered structure (00-quick-start through 06-archive)",
            "status": "pending",
            "testStrategy": "Validate all tutorials are categorized as 'tutorial'. Confirm CLAUDE.md files have 'critical' AI priority. Verify category distribution matches expected Diataxis quadrants.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Generate Inventory JSON and Summary Report",
            "description": "Compile all discovered documentation data into a structured inventory.json file and generate a human-readable summary report with statistics, category breakdowns, and actionable insights.",
            "dependencies": [
              3,
              4
            ],
            "details": "Generate docs/.meta/inventory.json with schema:\n```typescript\ninterface DocInventory {\n  generatedAt: string;\n  totalFiles: number;\n  files: Array<{\n    path: string;\n    title: string;\n    category: string;\n    format: 'markdown' | 'json';\n    lines: number;\n    lastModified: string;\n    hasFrontmatter: boolean;\n    crossReferences: string[];\n    status: 'active' | 'draft' | 'deprecated' | 'archived';\n    aiPriority: 'critical' | 'important' | 'reference' | 'archive';\n  }>;\n  statistics: {\n    byCategory: Record<string, number>;\n    byStatus: Record<string, number>;\n    byPriority: Record<string, number>;\n    totalLines: number;\n    avgLinesPerFile: number;\n  };\n}\n```\nAlso generate summary.md with: file counts, category distribution, CLAUDE.md stats, skills overview, and recommendations for Task 158.",
            "status": "pending",
            "testStrategy": "Validate inventory.json against defined TypeScript schema. Confirm totalFiles matches file system count. Verify summary.md includes all required sections and accurate statistics.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-30T07:58:11.578Z"
      },
      {
        "id": "158",
        "title": "Documentation Quality and Gap Analysis",
        "description": "Analyze all discovered documentation for content quality, accuracy, completeness, duplication, and identify gaps requiring attention.",
        "details": "## Implementation Steps\n\n### 1. Quality Metrics to Evaluate\n```typescript\ninterface QualityReport {\n  file: string;\n  metrics: {\n    hasYamlFrontmatter: boolean;\n    hasLastUpdated: boolean;\n    codeExamplesValid: boolean;\n    linksValid: boolean;\n    contentFreshness: 'fresh' | 'stale' | 'outdated'; // <30d, 30-90d, >90d\n    readabilityScore: number;\n  };\n  issues: string[];\n  recommendations: string[];\n}\n```\n\n### 2. Identify Duplicated Content\nKnown duplications to investigate:\n- `docs/README.md` vs `docs/MAINTENANCE.md` (overlapping update triggers)\n- `docs/reference/architecture/system-overview.md` vs content in `quikadmin/CLAUDE.md`\n- Multiple environment variable references across files\n- API endpoint documentation scattered across multiple files\n\n### 3. Check for Outdated Content\n- Compare `lastUpdated` timestamps (many files show 2025-11-25 or earlier)\n- Validate code examples against current codebase\n- Check for references to non-existent files/endpoints\n- Verify tech stack versions match package.json\n\n### 4. Identify Documentation Gaps\n- **Missing**: No dedicated troubleshooting guide for frontend\n- **Missing**: No comprehensive error codes reference\n- **Missing**: Environment-specific deployment guides incomplete\n- **Incomplete**: docs/claude-audit/ appears to be partial setup reports\n- **Incomplete**: docs/debug/ contains evidence_bundle.md only\n\n### 5. Analyze CLAUDE.md Files\n- `quikadmin/CLAUDE.md` is 1500+ lines - may be over-optimized for single file\n- Contains numbered prefix system (00-06) that doesn't match actual structure\n- References non-existent paths like `docs/00-quick-start/ai-agent-setup.md`\n\n### 6. Cross-Reference Validation\n- Check all internal markdown links resolve\n- Verify YAML frontmatter consistency\n- Validate code reference paths exist\n\n### 7. Generate Report\nCreate `docs/.meta/quality-report.md` with:\n- Summary statistics\n- High-priority issues\n- Duplication map\n- Gap analysis\n- Recommendations",
        "testStrategy": "1. Run markdown link checker on all docs\n2. Validate all code examples compile/run\n3. Verify frontmatter on random sample of 10 files\n4. Cross-check tech versions against package.json\n5. Manual review of top 5 most-referenced documents\n6. Confirm all recommended paths in CLAUDE.md exist",
        "priority": "high",
        "dependencies": [
          "157"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Documentation Quality Metrics Analyzer",
            "description": "Create a TypeScript script that analyzes each documentation file for quality metrics including YAML frontmatter presence, lastUpdated timestamps, content freshness classification, and generates structured quality reports.",
            "dependencies": [],
            "details": "Create `scripts/doc-quality-analyzer.ts` that:\n1. Scans all 55+ markdown files in `docs/` directory\n2. Parses YAML frontmatter to check for required fields (title, description, category, tags, lastUpdated)\n3. Classifies content freshness: 'fresh' (<30 days), 'stale' (30-90 days), 'outdated' (>90 days) based on lastUpdated\n4. Currently only 3 files have proper frontmatter - flag all others\n5. Check for valid markdown structure (headings, code blocks)\n6. Output results as JSON to `docs/.meta/quality-metrics.json` with per-file QualityReport objects\n7. Use the interface from task details: hasYamlFrontmatter, hasLastUpdated, codeExamplesValid, linksValid, contentFreshness, readabilityScore\n8. Most files currently show lastUpdated: 2025-11-25 which is stale (>30 days old)",
            "status": "pending",
            "testStrategy": "Run analyzer on `docs/` directory, verify output JSON contains entries for all 55 files, validate frontmatter detection correctly identifies the 3 files with proper frontmatter, confirm freshness classification marks 2025-11-25 files as 'stale'",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Detect and Map Duplicate Content Across Documentation",
            "description": "Analyze documentation files to identify content duplication, overlapping information, and redundant sections across the docs/ directory, quikadmin/CLAUDE.md (1500+ lines), and .claude/skills/ files.",
            "dependencies": [
              1
            ],
            "details": "Create duplication analysis focusing on known overlaps:\n1. Compare `docs/README.md` update triggers table with `docs/MAINTENANCE.md` triggers (lines 19-28 vs 39-58)\n2. Analyze overlap between `docs/reference/architecture/system-overview.md` and `quikadmin/CLAUDE.md` architecture sections\n3. Find environment variable references scattered across: CLAUDE.local.md, docs/reference/configuration/environment.md, quikadmin/CLAUDE.md\n4. Check API endpoint documentation in `docs/reference/api/endpoints.md` vs `quikadmin/docs/01-current-state/api/endpoints/`\n5. Compare 15 skill files in `.claude/skills/` for overlapping patterns\n6. Use content similarity hashing or paragraph fingerprinting\n7. Output duplication map to `docs/.meta/duplication-map.json` showing file pairs, overlap percentage, and specific duplicated sections\n8. Flag `quikadmin/docs/` which has 90+ files potentially duplicating main docs/",
            "status": "pending",
            "testStrategy": "Verify duplication map identifies known duplicates (README.md vs MAINTENANCE.md table), confirm overlap detection between system-overview.md and CLAUDE.md, validate all 90+ quikadmin/docs files are analyzed for duplicates",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Validate Internal Links and Code References",
            "description": "Check all internal markdown links, code file references, and path references across documentation to identify broken links and non-existent file references.",
            "dependencies": [
              1
            ],
            "details": "Create link validator that:\n1. Parse all markdown files for internal links [text](./path) and relative references\n2. Check `quikadmin/CLAUDE.md` lines 50-51 which reference `docs/00-quick-start/ai-agent-setup.md` - this path doesn't exist in current structure\n3. Validate references like `docs/01-current-state/` mentioned in CLAUDE.md exist with expected content\n4. Check `docs/.meta/STRUCTURE_DIAGRAM.md` proposed paths vs actual existing paths\n5. Verify code file references like `src/routes/auth/`, `prisma/schema.prisma` actually exist\n6. Validate cross-references in docs/README.md to ../AGENTS.md, ../CLAUDE.local.md, ../quikadmin/docs/\n7. Check that `quikadmin/docs/06-archive/` references are properly archived\n8. Output broken links report to `docs/.meta/broken-links.json` with source file, broken reference, and suggested fix\n9. Run equivalent to `npx markdown-link-check` on all 55 docs files",
            "status": "pending",
            "testStrategy": "Confirm broken link detection catches `docs/00-quick-start/ai-agent-setup.md` reference in CLAUDE.md, verify AGENTS.md reference is flagged if missing, validate all 55 docs files are scanned, ensure output includes actionable fix suggestions",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Identify Documentation Gaps and Missing Content",
            "description": "Analyze the documentation structure to identify missing guides, incomplete sections, and gaps in coverage based on codebase features and Diátaxis framework requirements.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Perform gap analysis for:\n1. **Missing guides identified in task**: No frontend troubleshooting guide (only auth-issues.md, database-issues.md exist), no error codes reference, incomplete environment-specific deployment guides\n2. **Incomplete directories**: `docs/claude-audit/` has 3 partial setup reports, `docs/debug/` only has evidence_bundle.md\n3. **CLAUDE.md numbered system mismatch**: References `00-06` prefix directories but actual docs/ uses Diátaxis (tutorials/, how-to/, reference/, explanation/)\n4. Check `docs/.meta/STRUCTURE_DIAGRAM.md` proposed structure vs what actually exists\n5. Identify features in codebase not documented: Bull queues, Redis caching, Tesseract.js OCR config, pdf-lib form filling options\n6. Check if `quikadmin-web/docs/` and `quikadmin/docs/` (mentioned as having 50+ files) are properly linked\n7. Verify all 15 skill files in `.claude/skills/` have complete documentation\n8. Output gap analysis to `docs/.meta/gap-analysis.json` with priority rankings",
            "status": "pending",
            "testStrategy": "Verify gap analysis identifies frontend troubleshooting as missing, confirms claude-audit/ is incomplete, flags mismatch between numbered prefix system and actual Diátaxis structure, validates all skill files are checked",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Generate Comprehensive Quality Report with Recommendations",
            "description": "Consolidate all quality analysis findings into a comprehensive markdown report at docs/.meta/quality-report.md with summary statistics, prioritized issues, and actionable recommendations.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create `docs/.meta/quality-report.md` containing:\n1. **Summary statistics**: Total files analyzed (55+ in docs/, 90+ in quikadmin/docs/), frontmatter compliance rate (currently ~5%), freshness distribution, link validity rate\n2. **High-priority issues**: Ordered list of critical problems including stale timestamps (most files 2025-11-25), missing frontmatter on 50+ files, broken internal references\n3. **Duplication map summary**: Visual table of overlapping content from subtask 2, estimated token waste from duplicates\n4. **Gap analysis summary**: Missing documentation areas with business impact assessment\n5. **CLAUDE.md analysis**: Note 1500+ line length, recommend splitting, identify invalid path references\n6. **Recommendations section**: Prioritized action items including frontmatter standardization script, link fixes, consolidation targets, archive candidates\n7. **Cross-reference tech versions**: Compare package.json versions (Node 18, Express 4.18, Prisma 6, React 18, etc.) with docs/reference/architecture/system-overview.md versions\n8. Include visual markdown tables and mermaid diagrams where helpful",
            "status": "pending",
            "testStrategy": "Review generated quality-report.md for completeness, verify all sections from implementation details are present, confirm recommendations are actionable, validate statistics match actual file counts, cross-check version numbers against package.json",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-30T08:07:47.188Z"
      },
      {
        "id": "159",
        "title": "Design Optimal Documentation Structure",
        "description": "Design an optimal folder hierarchy and organizational structure following Diataxis framework, Claude Code best practices, and token-efficient patterns for AI consumption.",
        "details": "## Implementation Steps\n\n### 1. Proposed Directory Structure\nBased on existing `.meta/STRUCTURE_DIAGRAM.md` and Diataxis framework:\n\n```\ndocs/\n├── README.md                    # Main hub (entry point)\n├── MAINTENANCE.md               # Keep - valuable maintenance guide\n│\n├── tutorials/                   # KEEP - Learning-oriented (existing)\n│   ├── README.md\n│   ├── getting-started.md\n│   ├── first-document.md\n│   └── understanding-workflow.md\n│\n├── how-to/                      # KEEP - Problem-oriented (existing)\n│   ├── README.md\n│   ├── deployment/\n│   ├── development/\n│   └── troubleshooting/\n│\n├── reference/                   # KEEP - Information-oriented (existing)\n│   ├── README.md\n│   ├── api/\n│   ├── architecture/\n│   ├── configuration/\n│   ├── database/\n│   ├── monitoring/\n│   └── security/\n│\n├── explanation/                 # KEEP - Understanding-oriented (existing)\n│   ├── README.md\n│   ├── adr/                     # Architecture Decision Records\n│   ├── data-flow.md\n│   ├── security-model.md\n│   └── architecture-decisions.md\n│\n├── ai-development/              # KEEP - AI agent guides (existing)\n│   ├── README.md\n│   ├── agentic-workflows.md\n│   └── mcp-integration.md\n│\n├── guides/                      # MOVE to how-to/ or merge\n│   └── (merge with how-to/)\n│\n├── prd/                         # KEEP - Product requirements\n├── strategy/                    # KEEP - Strategic docs\n├── decisions/                   # CONSOLIDATE with explanation/adr/\n├── architecture/                # CONSOLIDATE with reference/architecture/\n│\n└── _archive/                    # NEW - Deprecated content\n    ├── claude-audit/\n    ├── debug/\n    ├── sales/\n    └── tech-debt/\n```\n\n### 2. CLAUDE.md Optimization Strategy\n```markdown\n## Root Level: CLAUDE.local.md\n- Keep concise (~65 lines) - GOOD\n- Focus on quick reference\n- Link to detailed docs\n\n## Backend: quikadmin/CLAUDE.md\n- Currently 1500+ lines - TOO LONG\n- Split into:\n  - Essential context (300 lines max)\n  - Link to docs/ for details\n  - Remove duplicate documentation protocols\n\n## Frontend: quikadmin-web/CLAUDE.md\n- Currently ~555 lines - ACCEPTABLE\n- Keep pattern examples\n- Remove redundant info\n```\n\n### 3. Token Optimization Strategies\n- Use index files (README.md) as navigation hubs\n- Implement lazy-loading documentation pattern\n- Keep CLAUDE.md files under 500 lines\n- Reference docs/ instead of duplicating\n\n### 4. Cross-Reference Design\n```yaml\n# Each doc should have\nfrontmatter:\n  title: string\n  category: tutorials|how-to|reference|explanation\n  relatedDocs: string[]\n  lastUpdated: date\n  status: active|deprecated\n```\n\n### 5. Output Deliverables\n- `docs/.meta/proposed-structure.md` - Visual structure diagram\n- `docs/.meta/migration-plan.md` - Step-by-step migration\n- Updated `docs/.meta/STRUCTURE_DIAGRAM.md`",
        "testStrategy": "1. Validate proposed structure against Diataxis principles\n2. Estimate token savings from CLAUDE.md optimization\n3. Review with stakeholders for practical concerns\n4. Test navigation flow for common developer tasks\n5. Verify all existing content has a home in new structure\n6. Measure estimated tokens for root CLAUDE context load",
        "priority": "medium",
        "dependencies": [
          "157",
          "158"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit Current vs Proposed Structure and Create Reconciliation Matrix",
            "description": "Compare the existing Diataxis-based structure (tutorials, how-to, reference, explanation, ai-development) with the proposed numbered structure in STRUCTURE_DIAGRAM.md (00-quick-start through 06-archive). Create a reconciliation matrix mapping current folders to optimal target locations.",
            "dependencies": [],
            "details": "Analyze discrepancy between current docs/ structure and proposed .meta/STRUCTURE_DIAGRAM.md numbered structure. Current structure follows Diataxis (tutorials/, how-to/, reference/, explanation/, ai-development/) while proposed uses numbered prefixes (00-quick-start/ through 06-archive/). Create docs/.meta/proposed-structure.md with: 1) Decision on which naming convention to adopt (numbered vs semantic Diataxis names), 2) Mapping of all 55+ existing docs to their target locations, 3) Identification of orphaned content (claude-audit/, debug/, sales/, tech-debt/, architecture/, decisions/, prd/, strategy/, guides/) that needs archival or consolidation. Consider that current README.md already references Diataxis structure correctly.",
            "status": "pending",
            "testStrategy": "Verify mapping covers all 55+ files from glob results. Validate decision aligns with Diataxis principles. Ensure no content is orphaned without a designated target.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Design CLAUDE.md Token Optimization Strategy with Line Budgets",
            "description": "Create concrete optimization plan for reducing backend CLAUDE.md from 1137 lines to under 500 lines while preserving critical context. Define line budgets for each section and identify content to extract to docs/.",
            "dependencies": [
              1
            ],
            "details": "Backend CLAUDE.md (1137 lines) needs reduction to ~300-500 lines. Frontend CLAUDE.md (448 lines) is acceptable. Strategy document should include: 1) Section-by-section line budget (e.g., Quick Reference: 50 lines, Architecture: 100 lines, Development Protocols: 80 lines), 2) Identification of content to extract (detailed code examples, extensive command references, duplicated docs info), 3) Link replacement strategy using format 'See docs/reference/X.md for details', 4) Preserve: critical file paths, common commands, security protocols, testing patterns. Create docs/.meta/claude-md-optimization-plan.md with before/after line counts per section and extraction targets.",
            "status": "pending",
            "testStrategy": "Calculate estimated token savings (target: 40-50% reduction). Verify all extracted content has valid target paths in docs/. Ensure remaining content provides sufficient context for AI agents.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Design Cross-Reference and Metadata Schema for Documents",
            "description": "Define YAML frontmatter schema, cross-reference patterns, and navigation index structure to enable AI agents to efficiently traverse documentation while minimizing token consumption.",
            "dependencies": [
              1
            ],
            "details": "Design comprehensive metadata system: 1) YAML frontmatter schema with fields: title, category (tutorials|how-to|reference|explanation), status (active|deprecated|draft), priority (critical|important|reference), relatedDocs[], codeReferences[], lastUpdated, aiHints{readFirst, skipFor, dependencies}. 2) Create docs/.meta/index.json structure for complete documentation graph with navigation hints. 3) Design ai-context.json format for lazy-loading documentation hints. 4) Specify README.md hub pattern for each major section with consistent navigation. Document in docs/.meta/metadata-schema.md. Consider existing templates in docs/.meta/templates/.",
            "status": "pending",
            "testStrategy": "Validate schema covers all use cases from existing frontmatter in doc templates. Test navigation flow from entry point to any document in 3 or fewer hops. Verify AI agents can determine document relevance from metadata alone.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Migration Plan with Consolidation Rules and Archive Strategy",
            "description": "Develop step-by-step migration plan document specifying file moves, content merges, link updates, and archive procedures. Include rollback strategy and verification checkpoints.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create docs/.meta/migration-plan.md with: 1) Phase 1: Create archive structure (_archive/claude-audit/, _archive/debug/, _archive/sales/, _archive/tech-debt/), 2) Phase 2: Consolidate duplicates - merge docs/architecture/ (2 files) into reference/architecture/, merge docs/decisions/ (1 ADR) into explanation/adr/, merge docs/guides/ content into how-to/, 3) Phase 3: Update all cross-references (identify ~20 internal links needing updates), 4) Phase 4: CLAUDE.md optimization - extract content per subtask 2 plan, 5) Phase 5: Validate with markdown-link-check. Include git commands for each move, verification steps after each phase, and rollback instructions. Estimate: 15-20 file moves, 3 content merges, 1 CLAUDE.md rewrite.",
            "status": "pending",
            "testStrategy": "Dry-run migration commands in test branch. Run npx markdown-link-check on migrated docs. Verify archived content remains accessible. Confirm CLAUDE.md files under 500 lines post-migration.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-30T08:08:57.413Z"
      },
      {
        "id": "160",
        "title": "Execute Documentation Consolidation",
        "description": "Execute the restructuring plan by merging duplicates, reorganizing files, updating cross-references, ensuring consistent formatting, and archiving obsolete content.",
        "details": "## Implementation Steps\n\n### 1. Create Archive Structure\n```bash\nmkdir -p docs/_archive/{claude-audit,debug,sales,tech-debt}\n\n# Move non-essential docs to archive\nmv docs/claude-audit/* docs/_archive/claude-audit/\nmv docs/debug/* docs/_archive/debug/\nmv docs/sales/* docs/_archive/sales/\nmv docs/tech-debt/* docs/_archive/tech-debt/\n```\n\n### 2. Consolidate Architecture Documentation\n```bash\n# Merge duplicate architecture docs\n# docs/architecture/*.md -> docs/reference/architecture/\nmv docs/architecture/dynamic-pii-architecture*.md docs/reference/architecture/\n\n# Update docs/decisions/ -> docs/explanation/adr/\nmv docs/decisions/*.md docs/explanation/adr/\n```\n\n### 3. Merge Duplicate Content\nPriority merges:\n1. Environment variables: Single source in `docs/reference/configuration/environment.md`\n2. API endpoints: Consolidate to `docs/reference/api/endpoints.md`\n3. Architecture overview: Single source in `docs/reference/architecture/system-overview.md`\n\n### 4. Optimize CLAUDE.md Files\n\n```markdown\n## quikadmin/CLAUDE.md Refactoring\n\nKEEP:\n- Project Overview section\n- Architecture Quick Reference  \n- Development Protocols (condensed)\n- Common Commands\n\nMOVE TO docs/:\n- Documentation Protocols (1000+ lines)\n- Detailed PR requirements\n- Detailed testing guidelines\n- CI/CD check examples\n\nTarget: ~500 lines\n```\n\n### 5. Update All Cross-References\n```typescript\n// Script to update internal links\nconst linkUpdates = {\n  'docs/architecture/current/': 'docs/reference/architecture/',\n  'docs/decisions/': 'docs/explanation/adr/',\n  'docs/getting-started/': 'docs/tutorials/',\n  // ... all path changes\n};\n```\n\n### 6. Add Missing Frontmatter\nEnsure all docs have:\n```yaml\n---\ntitle: Document Title\ndescription: Brief description\ncategory: tutorials|how-to|reference|explanation\nlastUpdated: 2025-12-30\nstatus: active\n---\n```\n\n### 7. Update Root Documentation Hub\nUpdate `docs/README.md` with:\n- Clear navigation structure\n- Quick links for common tasks\n- AI agent reading order\n- Updated last modified date\n\n### 8. Validate Internal Consistency\n```bash\n# Run link validation\nnpx markdown-link-check docs/**/*.md\n\n# Verify frontmatter\nfor file in docs/**/*.md; do\n  head -20 \"$file\" | grep -q '^---' || echo \"Missing frontmatter: $file\"\ndone\n```",
        "testStrategy": "1. Run `npx markdown-link-check` on all docs - 0 broken links\n2. Validate all moved files have correct path references\n3. Verify CLAUDE.md files are under 500 lines (except comprehensive backend)\n4. Test navigation from docs/README.md to all major sections\n5. Confirm archived content is still accessible but clearly marked\n6. Verify no duplicate content exists (grep for key phrases)\n7. Test AI agent context loading with new structure\n8. Confirm all code examples in docs still reference valid paths",
        "priority": "medium",
        "dependencies": [
          "159"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Archive Structure and Move Non-Essential Documentation",
            "description": "Create the docs/_archive/ directory hierarchy and move claude-audit/, debug/, sales/, and tech-debt/ directories to archive with proper README index",
            "dependencies": [],
            "details": "Create docs/_archive/ with subdirectories: claude-audit, debug, sales, tech-debt. Move 6 files total: claude_setup_report.md, claude_setup_addendum.md, taskmaster_provider_check.md (claude-audit), evidence_bundle.md (debug), gemini-prompts.md (sales), tech-stability-audit-2025-12.md (tech-debt). Create docs/_archive/README.md index explaining archived content is retained for reference but not actively maintained. Update any cross-references in other docs (check .meta/DOCUMENTATION_MIGRATION_GUIDE.md). Remove empty source directories after move.",
            "status": "pending",
            "testStrategy": "Verify all 6 files moved correctly, _archive/README.md exists, no broken links to archived content, empty source directories removed",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Consolidate Architecture and ADR Documentation",
            "description": "Merge duplicate architecture docs into reference/architecture/ and move decisions/ content to explanation/adr/ following Diataxis structure",
            "dependencies": [
              1
            ],
            "details": "Move docs/architecture/dynamic-pii-architecture.md and dynamic-pii-architecture-options.md to docs/reference/architecture/. Move docs/decisions/ADR-001-document-relationship-design.md to docs/explanation/adr/ alongside existing ADR-001-document-processing-pipeline.md. Update docs/explanation/architecture-decisions.md to reference the consolidated ADR location. Remove empty architecture/ and decisions/ directories. Update cross-references in any files that link to old paths. Ensure proper YAML frontmatter on all moved files.",
            "status": "pending",
            "testStrategy": "Verify 3 files moved to correct locations, old directories removed, architecture-decisions.md references new ADR paths, run grep to confirm no remaining links to old paths",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Missing Frontmatter and Standardize Metadata",
            "description": "Ensure all docs have consistent YAML frontmatter with title, description, category, lastUpdated, and status fields",
            "dependencies": [
              1,
              2
            ],
            "details": "Scan all ~55 markdown files in docs/ for frontmatter presence using grep/head. For files missing frontmatter, add standard YAML header: title (from H1), description (one-line summary), category (tutorials|how-to|reference|explanation|ai-development), lastUpdated (2025-12-30), status (active). Priority files: tutorials/README.md, all moved architecture files, explanation/ files. Use consistent date format YYYY-MM-DD. Update lastUpdated on any files modified during consolidation. Create validation script or document checklist for future frontmatter compliance.",
            "status": "pending",
            "testStrategy": "Run 'head -20 docs/**/*.md | grep -c \"^---\"' to count frontmatter presence, verify all active docs have required fields, sample 10 random files for compliance",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update Cross-References and Internal Links",
            "description": "Find and update all internal documentation links affected by file moves, ensuring navigation remains intact",
            "dependencies": [
              1,
              2
            ],
            "details": "Create mapping of path changes: docs/architecture/* -> docs/reference/architecture/*, docs/decisions/* -> docs/explanation/adr/*, docs/claude-audit/* -> docs/_archive/claude-audit/*, docs/debug/* -> docs/_archive/debug/*, docs/sales/* -> docs/_archive/sales/*, docs/tech-debt/* -> docs/_archive/tech-debt/*. Grep all .md files for old paths and update to new paths. Update docs/README.md quick links section. Update .meta/DOCUMENTATION_MIGRATION_GUIDE.md with completed migrations. Check CLAUDE.local.md and quikadmin/CLAUDE.md for any docs references. Verify no broken relative links remain.",
            "status": "pending",
            "testStrategy": "Run 'npx markdown-link-check docs/**/*.md' for all docs, grep for old paths returns 0 results, manually test navigation from docs/README.md to major sections",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update Documentation Hub and Validate Consolidation",
            "description": "Update docs/README.md hub with current structure, clear navigation, and run final validation to ensure zero broken links",
            "dependencies": [
              3,
              4
            ],
            "details": "Update docs/README.md: refresh Documentation Structure section with current hierarchy, add _archive section noting archived content, update Quick Links for any path changes, set lastUpdated to 2025-12-30, verify AI agent reading order still valid. Add note about archived vs active content distinction. Update Project Structure diagram if needed. Run comprehensive validation: npx markdown-link-check on all docs, verify frontmatter with grep, test all tutorial/how-to links work. Document token savings if CLAUDE.md optimization was done. Create summary of consolidation changes for future reference.",
            "status": "pending",
            "testStrategy": "npx markdown-link-check returns 0 broken links, docs/README.md accurately reflects directory structure, navigation from hub reaches all major sections in 2 clicks, archived content accessible but clearly marked",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-30T08:12:52.537Z"
      },
      {
        "id": "161",
        "title": "Add YAML Frontmatter to Documentation Files",
        "description": "Batch-add consistent YAML frontmatter to approximately 48 documentation files in the main docs/ directory that are missing it, using the template from docs/.meta/templates/document-template.md.",
        "details": "## Implementation Details\n\n### Scope\n- Target: ~48 files in main docs/ (61 total - 13 with existing frontmatter)\n- Template: Use simplified frontmatter from docs/.meta/templates/document-template.md\n- Batch approach: Process by directory to avoid context limits\n\n### Frontmatter Format\n```yaml\n---\ntitle: \"Document Title\"\ndescription: \"Brief description of the document content\"\ncategory: \"tutorials|how-to|reference|explanation|ai-development\"\nlastUpdated: \"2025-12-30\"\nstatus: \"active\"\n---\n```\n\n### Processing Order (Priority)\n1. `docs/tutorials/` - 4 files\n2. `docs/how-to/` - 10 files (deployment, development, troubleshooting subdirs)\n3. `docs/reference/` - 10 files (api, architecture, configuration, database, design, monitoring, security subdirs)\n4. `docs/explanation/` - 6 files (including adr/ subdir)\n5. `docs/ai-development/` - 3 files\n6. `docs/guides/` - 2 files\n7. Root docs files - 5 files (README.md, PRD.md, MAINTENANCE.md, etc.)\n8. `docs/prd/`, `docs/strategy/` - remaining files\n\n### Implementation Steps\n1. Read each markdown file\n2. Check if frontmatter exists (starts with ---)\n3. If missing, prepend frontmatter:\n   - Extract title from first # heading\n   - Generate description from first paragraph\n   - Assign category based on directory\n   - Set lastUpdated to 2025-12-30\n   - Set status to 'active'\n4. Write updated file\n5. Verify file structure not broken\n\n### Edge Cases\n- Files starting with `# ` in YAML (like the template) - skip these\n- Files in _archive/ - status should be 'archived'\n- Files in .meta/ - skip (internal tooling)\n\n### Pseudo-code\n```typescript\nconst categories = {\n  'tutorials': 'tutorials',\n  'how-to': 'how-to',\n  'reference': 'reference',\n  'explanation': 'explanation',\n  'ai-development': 'ai-development',\n  'guides': 'how-to',\n  '_archive': 'archived'\n};\n\nfor (const file of markdownFiles) {\n  if (file.includes('.meta/')) continue;\n  \n  const content = await readFile(file);\n  if (content.startsWith('---')) continue; // Already has frontmatter\n  \n  const title = extractTitle(content); // First # heading\n  const description = extractDescription(content); // First paragraph\n  const category = determineCategory(file, categories);\n  const status = file.includes('_archive') ? 'archived' : 'active';\n  \n  const frontmatter = `---\ntitle: \"${title}\"\ndescription: \"${description}\"\ncategory: \"${category}\"\nlastUpdated: \"2025-12-30\"\nstatus: \"${status}\"\n---\n\n`;\n  \n  await writeFile(file, frontmatter + content);\n}\n```",
        "testStrategy": "## Validation Approach\n\n### Automated Checks\n1. **Frontmatter Parser Test**: Use a YAML parser to validate all files have valid YAML frontmatter\n2. **Required Fields Check**: Verify each file has: title, description, category, lastUpdated, status\n3. **Category Validation**: Ensure category is one of: tutorials, how-to, reference, explanation, ai-development, archived\n\n### Manual Verification\n1. Spot-check 5 files from each category for correct metadata\n2. Verify file content not corrupted (compare line counts before/after)\n3. Check that existing frontmatter files were not modified\n\n### Verification Script\n```bash\n# Count files with valid frontmatter\ngrep -l '^---$' docs/**/*.md | wc -l\n# Should equal ~61 after completion\n\n# Validate YAML structure\nfor f in docs/**/*.md; do\n  head -20 \"$f\" | grep -q 'title:' && \\\n  head -20 \"$f\" | grep -q 'description:' && \\\n  head -20 \"$f\" | grep -q 'category:' && \\\n  head -20 \"$f\" | grep -q 'lastUpdated:' && \\\n  head -20 \"$f\" | grep -q 'status:' || echo \"Missing fields: $f\"\ndone\n```\n\n### Success Criteria\n- [ ] All 48 files in docs/ have valid YAML frontmatter\n- [ ] No files with corrupted content\n- [ ] Categories match directory locations\n- [ ] Build/lint passes if applicable",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-30T11:39:47.597Z"
      },
      {
        "id": "162",
        "title": "Migrate Unique Files from quikadmin/docs/",
        "description": "Migrate 15 unique documentation files from quikadmin/docs/ to the main docs/ directory as identified in docs/.meta/quikadmin-docs-review.md, update cross-references, and remove migrated files from source.",
        "details": "## Implementation Details\n\n### Files to Migrate (from quikadmin-docs-review.md)\n\n| Source | Target | Priority |\n|--------|--------|----------|\n| `00-quick-start/ai-agent-setup.md` | `docs/ai-development/agent-setup.md` | High |\n| `01-current-state/architecture/quick-reference.md` | `docs/reference/architecture/quick-reference.md` | High |\n| `02-guides/development/implementing-auth.md` | `docs/how-to/development/implementing-auth.md` | High |\n| `02-guides/development/ocr-implementation.md` | `docs/how-to/development/ocr-implementation.md` | Medium |\n| `02-guides/development/pdf-implementation.md` | `docs/how-to/development/pdf-implementation.md` | Medium |\n| `02-guides/user/document-reprocessing.md` | `docs/tutorials/document-reprocessing.md` | Medium |\n| `02-guides/user/templates.md` | `docs/tutorials/template-usage.md` | Medium |\n| `research/pdf-library-comparison.md` | `docs/explanation/pdf-library-research.md` | Low |\n| `design/design-system.md` | `docs/reference/design/design-system.md` | Medium |\n\n### Content to Merge (into existing files)\n| Source | Target |\n|--------|--------|\n| `01-current-state/api/endpoints/profile.md` | Merge into `docs/reference/api/endpoints.md` |\n| `01-current-state/api/endpoints/templates.md` | Merge into `docs/reference/api/endpoints.md` |\n| `01-current-state/api/endpoints/document-reprocessing.md` | Merge into `docs/reference/api/endpoints.md` |\n| `01-current-state/architecture/system-overview.md` | Merge detailed content into `docs/reference/architecture/system-overview.md` |\n\n### Implementation Steps\n\n1. **Create target directories**\n```bash\nmkdir -p docs/reference/design\n# Other dirs already exist\n```\n\n2. **For each standalone migration**:\n   - Read source file\n   - Add YAML frontmatter (if missing)\n   - Update internal links (../../ -> ../ patterns)\n   - git mv to preserve history\n   - Update any files that referenced the old location\n\n3. **For merge operations**:\n   - Read both source and target files\n   - Identify unique content in source\n   - Append/integrate unique sections to target\n   - Delete source file after verification\n\n4. **Update cross-references**:\n   - Search all docs for references to old paths\n   - Update to new paths\n   - Update quikadmin/CLAUDE.md if it references migrated files\n\n### Pseudo-code\n```typescript\n// Standalone migrations\nconst migrations = [\n  { src: 'quikadmin/docs/00-quick-start/ai-agent-setup.md', \n    dest: 'docs/ai-development/agent-setup.md' },\n  // ... other migrations\n];\n\nfor (const m of migrations) {\n  // Use git mv to preserve history\n  await exec(`git mv \"${m.src}\" \"${m.dest}\"`);\n  \n  // Update internal links in migrated file\n  let content = await readFile(m.dest);\n  content = updateRelativeLinks(content, m.src, m.dest);\n  await writeFile(m.dest, content);\n}\n\n// Update references in all docs\nconst allDocs = await glob('docs/**/*.md');\nfor (const doc of allDocs) {\n  let content = await readFile(doc);\n  for (const m of migrations) {\n    content = content.replace(\n      new RegExp(escapeRegex(m.src), 'g'),\n      m.dest\n    );\n  }\n  await writeFile(doc, content);\n}\n```\n\n### Files to Keep in quikadmin/docs/ (Backend-Specific)\n- `03-reference/TEST_CREDENTIALS.md`\n- `01-current-state/architecture/SECURITY_ROTATION.md`",
        "testStrategy": "## Validation Approach\n\n### Pre-Migration Checklist\n1. Verify all source files exist\n2. Verify target directories exist\n3. Backup current state (git stash or commit first)\n\n### Post-Migration Verification\n1. **File Existence Check**:\n   - All 15 target files exist in docs/\n   - Source files removed (except backend-specific ones)\n\n2. **Link Integrity Test**:\n```bash\n# Find broken internal links\nfor f in docs/**/*.md; do\n  grep -oP '\\]\\(\\./[^)]+\\)' \"$f\" | while read link; do\n    target=$(echo $link | sed 's/.*\\.\\/\\([^)]*\\).*/\\1/')\n    dir=$(dirname \"$f\")\n    if [[ ! -f \"$dir/$target\" ]]; then\n      echo \"Broken link in $f: $target\"\n    fi\n  done\ndone\n```\n\n3. **Git History Check**:\n```bash\n# Verify git history preserved for migrated files\ngit log --follow docs/ai-development/agent-setup.md\n```\n\n4. **Reference Update Check**:\n```bash\n# No references to old paths should exist\ngrep -r \"quikadmin/docs/00-quick-start\" docs/ # Should return nothing\ngrep -r \"quikadmin/docs/02-guides\" docs/ # Should return nothing\n```\n\n### Success Criteria\n- [ ] All 15 unique files migrated to correct locations\n- [ ] Git history preserved for migrated files\n- [ ] No broken internal links in docs/\n- [ ] No references to old quikadmin/docs/ paths\n- [ ] quikadmin/CLAUDE.md updated if needed\n- [ ] Merged content integrated into target files",
        "priority": "high",
        "dependencies": [
          "161"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-30T12:13:32.882Z"
      },
      {
        "id": "163",
        "title": "Archive Duplicate Files from quikadmin/docs/",
        "description": "Archive approximately 95 duplicate/outdated files from quikadmin/docs/ to quikadmin/docs/_archive/, preserving git history and keeping approximately 10 backend-specific files in place.",
        "details": "## Implementation Details\n\n### Files to Archive (~95 files)\n\n**By Directory:**\n\n1. **06-archive/** and **archive/** (~30 files) - ARCHIVE ALL\n   - Old numbered sections (100-700 series)\n   - Historical implementation plans\n   - Upgrade reports and test results\n\n2. **.meta/** (~22 files) - ARCHIVE ALL\n   - `CLEANUP_*.md`\n   - `PHASE*_COMPLETION_SUMMARY.md`\n   - `DOCUMENTATION_ARCHITECTURE_*.md`\n   - `TASK-*.md`\n\n3. **04-future-vision/** (~4 files) - ARCHIVE ALL\n   - Vision documentation explicitly marked \"NOT IMPLEMENTED\"\n\n4. **Duplicates from other sections** (~39 files)\n   - `00-quick-start/README.md`, `project-overview.md`\n   - `01-current-state/` duplicates\n   - `02-guides/development/DEV_SETUP.md`, `TESTING_PLAN.md`\n   - `getting-started/` - all 6 files\n   - `infrastructure/` and `deployment/` - 5 files\n\n### Files to KEEP in quikadmin/docs/ (~10 files)\n- `03-reference/TEST_CREDENTIALS.md`\n- `01-current-state/architecture/SECURITY_ROTATION.md`\n- Supabase middleware implementation details\n- Any files referenced by migrated docs in Task 162\n\n### Archive Structure\n```\nquikadmin/docs/_archive/\n├── README.md              # Explains archive status\n├── numbered-sections/     # Old 100-700 series\n├── meta-historical/       # .meta completion summaries\n├── future-vision/         # Unimplemented vision docs\n├── duplicates/            # Content duplicated in main docs/\n└── historical/            # Implementation plans, upgrade reports\n```\n\n### Implementation Steps\n\n1. **Create archive structure**:\n```bash\nmkdir -p quikadmin/docs/_archive/{numbered-sections,meta-historical,future-vision,duplicates,historical}\n```\n\n2. **Create archive README**:\n```markdown\n# Archived Documentation\n\n**Archived Date:** 2025-12-30\n**Reason:** Documentation consolidation - content migrated to main `docs/` directory\n\nThis directory contains historical/duplicate documentation preserved for reference.\n\n## Current Documentation\nSee the main `docs/` directory at the project root for current documentation.\n\n## Structure\n- `numbered-sections/` - Old numbered documentation (100-700 series)\n- `meta-historical/` - Task completion summaries and cleanup logs  \n- `future-vision/` - Unimplemented architecture visions\n- `duplicates/` - Content now in main docs/\n- `historical/` - Implementation plans and upgrade reports\n\n## Backend-Specific Documentation\nSee `quikadmin/CLAUDE.md` for backend-specific context.\nActive backend docs remain in `quikadmin/docs/` (not in _archive).\n```\n\n3. **Move files using git mv**:\n```bash\n# Use git mv to preserve history\ngit mv quikadmin/docs/06-archive/* quikadmin/docs/_archive/numbered-sections/\ngit mv quikadmin/docs/archive/* quikadmin/docs/_archive/historical/\ngit mv quikadmin/docs/.meta/*.md quikadmin/docs/_archive/meta-historical/\ngit mv quikadmin/docs/04-future-vision/* quikadmin/docs/_archive/future-vision/\n```\n\n4. **Update quikadmin/docs/README.md**:\n```markdown\n# Backend Documentation\n\nThis directory contains backend-specific documentation.\n\n## Main Documentation\nFor comprehensive project documentation, see the main `docs/` directory.\n\n## Backend-Specific Docs\n- `03-reference/TEST_CREDENTIALS.md` - Test credentials (sensitive)\n- `01-current-state/architecture/SECURITY_ROTATION.md` - Credential rotation\n\n## Archived Content\nSee `_archive/` for historical documentation.\n```\n\n5. **Clean up empty directories**:\n```bash\nfind quikadmin/docs -type d -empty -delete\n```\n\n### Pseudo-code\n```typescript\nconst archiveMappings = {\n  '06-archive': '_archive/numbered-sections',\n  'archive': '_archive/historical',\n  '.meta': '_archive/meta-historical',\n  '04-future-vision': '_archive/future-vision',\n};\n\n// Create archive structure\nawait exec('mkdir -p quikadmin/docs/_archive/{numbered-sections,meta-historical,future-vision,duplicates,historical}');\n\n// Move directories\nfor (const [src, dest] of Object.entries(archiveMappings)) {\n  const srcPath = `quikadmin/docs/${src}`;\n  const destPath = `quikadmin/docs/${dest}`;\n  if (await exists(srcPath)) {\n    await exec(`git mv \"${srcPath}\"/* \"${destPath}/\"`);\n  }\n}\n\n// Handle individual duplicate files\nconst duplicates = [\n  'quikadmin/docs/00-quick-start/README.md',\n  'quikadmin/docs/00-quick-start/project-overview.md',\n  // ... list from review\n];\n\nfor (const dup of duplicates) {\n  await exec(`git mv \"${dup}\" quikadmin/docs/_archive/duplicates/`);\n}\n\n// Clean up empty directories\nawait exec('find quikadmin/docs -type d -empty -delete');\n```",
        "testStrategy": "## Validation Approach\n\n### Pre-Archive Verification\n1. **List files to archive**: Generate complete list before operation\n2. **Verify keep-list**: Confirm backend-specific files will remain\n3. **Check dependencies**: Ensure no active code references files being archived\n\n### Post-Archive Verification\n\n1. **File Count Check**:\n```bash\n# Count files in archive\nfind quikadmin/docs/_archive -name \"*.md\" | wc -l\n# Should be ~95\n\n# Count remaining active files\nfind quikadmin/docs -name \"*.md\" -not -path \"*/_archive/*\" | wc -l\n# Should be ~10\n```\n\n2. **Git History Check**:\n```bash\n# Verify history preserved\ngit log --follow quikadmin/docs/_archive/historical/test-results/SMOKE_TEST_RESULTS.md\n```\n\n3. **README Verification**:\n```bash\n# Archive README exists\ncat quikadmin/docs/_archive/README.md\n\n# Main README updated\ncat quikadmin/docs/README.md\n```\n\n4. **No Broken References**:\n```bash\n# Search for references to archived paths in active docs\ngrep -r \"06-archive\" docs/ quikadmin/docs/*.md 2>/dev/null || echo \"Clean\"\ngrep -r \"04-future-vision\" docs/ quikadmin/docs/*.md 2>/dev/null || echo \"Clean\"\n```\n\n5. **Backend-Specific Files Remain**:\n```bash\n# Verify key files still exist\ntest -f quikadmin/docs/03-reference/TEST_CREDENTIALS.md && echo \"OK\" || echo \"MISSING\"\ntest -f quikadmin/docs/01-current-state/architecture/SECURITY_ROTATION.md && echo \"OK\" || echo \"MISSING\"\n```\n\n### Success Criteria\n- [ ] ~95 files moved to _archive/ structure\n- [ ] ~10 backend-specific files remain in place\n- [ ] Git history preserved for all moved files\n- [ ] _archive/README.md explains archive status\n- [ ] quikadmin/docs/README.md points to main docs/\n- [ ] No empty directories remain\n- [ ] No broken references in active documentation",
        "priority": "medium",
        "dependencies": [
          "162"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-01T04:33:37.594Z"
      },
      {
        "id": "164",
        "title": "Enforce Prisma Singleton Pattern Across Codebase",
        "description": "Replace all per-request PrismaClient instantiation with singleton import from utils/prisma.ts to prevent connection pool exhaustion",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-31T09:41:14.413Z"
      },
      {
        "id": "165",
        "title": "Register Audit Middleware Globally",
        "description": "Register createAuditMiddleware globally in index.ts to ensure 100% audit coverage for all API endpoints with configurable exclusions",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-31T09:41:20.628Z"
      },
      {
        "id": "166",
        "title": "Fix RLS Context Error Handling",
        "description": "Make RLS set_user_context failures visible with ERROR logging, metrics tracking, and configurable 500 response in production",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-31T09:41:26.796Z"
      },
      {
        "id": "167",
        "title": "Implement Circuit Breaker for Supabase Auth",
        "description": "Add circuit breaker pattern using opossum for supabaseAdmin.auth.getUser() to handle Supabase outages gracefully",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-31T09:54:07.379Z"
      },
      {
        "id": "168",
        "title": "Add Token Caching Layer",
        "description": "Implement Redis-backed token cache with SHA256 key hashing, 5-min TTL, and in-memory fallback to reduce Supabase calls",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-31T10:47:38.495Z"
      },
      {
        "id": "169",
        "title": "Create Organization Context Middleware",
        "description": "Create dedicated middleware for organizationId extraction, validation, and consistent enforcement across org-scoped endpoints",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-31T15:13:39.893Z"
      },
      {
        "id": "170",
        "title": "Enhance Health Endpoint with Connection Metrics",
        "description": "Add /health/detailed endpoint exposing Supabase connectivity, Prisma pool stats, Redis status, and RLS failure counts",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-31T16:02:42.675Z"
      },
      {
        "id": "171",
        "title": "Normalize Rate Limiter Key Generation",
        "description": "Create shared generateRateLimitKey function with user/org/ip scopes and consistent validation across all rate limiters",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "low",
        "subtasks": [],
        "updatedAt": "2025-12-31T16:13:17.565Z"
      },
      {
        "id": "172",
        "title": "Consolidate .env files to single root configuration",
        "description": "Secure and clarify .env file structure: Remove duplicate Supabase keys from root .env (security fix - SERVICE_ROLE_KEY should NOT be in root), keep root .env only for AI tool keys (TaskMaster: PERPLEXITY, GROQ, GOOGLE, etc), add startup validation in backend to catch missing env vars, and document which file is authoritative for which keys.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "REVISED APPROACH: Keep separate .env structure but improve security and clarity.\n\n**Current state analysis**:\n- Root `.env` contains duplicate Supabase keys including SERVICE_ROLE_KEY (SECURITY ISSUE)\n- `quikadmin/.env` is authoritative for all backend configuration\n- `quikadmin-web/.env` is authoritative for frontend VITE_ prefixed vars\n- Root `.env` should only contain AI tool keys for TaskMaster/Claude\n\n**Key files**:\n- Root `.env` (lines 1-10): Currently has Supabase keys + AI tool keys\n- `quikadmin/.env` (lines 1-32): Full backend config\n- `quikadmin-web/.env` (lines 1-7): Frontend VITE_ vars\n- `quikadmin/src/config/index.ts` (lines 78-203): Config loading and validation\n- `docs/reference/configuration/environment.md`: Documentation to update\n\n**Security fix**: SERVICE_ROLE_KEY in root .env is a security risk - this key grants admin access and should only exist in backend .env file.",
        "testStrategy": "1. Verify root .env contains ONLY AI tool keys (no SUPABASE_* vars). 2. Verify backend starts successfully with proper validation errors for missing vars. 3. Verify frontend loads correctly with VITE_ vars from quikadmin-web/.env. 4. Test startup with missing critical vars (DATABASE_URL, JWT_SECRET) to confirm helpful error messages. 5. Review documentation for accuracy.",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove duplicate Supabase keys from root .env (security fix)",
            "description": "Remove SUPABASE_URL, SUPABASE_ANON_KEY, and critically SUPABASE_SERVICE_ROLE_KEY from root .env file. The SERVICE_ROLE_KEY should ONLY exist in quikadmin/.env as it grants admin-level database access.",
            "dependencies": [],
            "details": "Edit root `.env` (N:\\IntelliFill\\.env) to remove lines 1-4 containing Supabase credentials. Keep only the AI tool section (lines 6-10): PERPLEXITY_API_KEY, GOOGLE_API_KEY, GEMINI_API_KEY, GROQ_API_KEY. Update comment from 'For Claude' to 'AI Tool Keys (TaskMaster, Claude Code, etc)'. This is a critical security fix - SERVICE_ROLE_KEY bypasses RLS and should never be in a shared/root location.",
            "status": "pending",
            "testStrategy": "Run `grep -r 'SERVICE_ROLE_KEY' .env` from root to confirm it only appears in quikadmin/.env. Verify backend still starts (it reads from quikadmin/.env).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Enhance backend startup validation with clear error messages",
            "description": "Add comprehensive startup validation in quikadmin/src/config/index.ts that provides clear, actionable error messages when required environment variables are missing, including which .env file to check.",
            "dependencies": [],
            "details": "Enhance the `getEnv()` function in quikadmin/src/config/index.ts (line 78-84) to provide better error messages that indicate the source file. Add a new `validateRequiredEnvVars()` function that runs early in loadConfig() and lists ALL missing required vars at once (not fail-fast) so developers can fix all issues in one pass. Required vars: DATABASE_URL, JWT_SECRET, JWT_REFRESH_SECRET, SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY. Include suggestion text: 'Check quikadmin/.env - see docs/reference/configuration/environment.md for details'.",
            "status": "pending",
            "testStrategy": "Temporarily remove DATABASE_URL from quikadmin/.env and verify error message mentions the file location and docs link. Test with multiple missing vars to confirm all are reported.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Document authoritative source for each environment variable",
            "description": "Update docs/reference/configuration/environment.md with a new section that clearly documents which .env file is authoritative for which variables, preventing duplication confusion.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add new section '## File Authority Reference' to docs/reference/configuration/environment.md (after line 14) with a clear table:\n\n| File | Authority | Variables |\n|------|-----------|----------|\n| `.env` (root) | AI Tools only | PERPLEXITY_API_KEY, GOOGLE_API_KEY, GEMINI_API_KEY, GROQ_API_KEY |\n| `quikadmin/.env` | Backend | DATABASE_URL, JWT_*, SUPABASE_*, REDIS_URL, R2_*, CORS_ORIGINS, etc. |\n| `quikadmin-web/.env` | Frontend | VITE_API_URL, VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY, VITE_USE_BACKEND_AUTH |\n\nAdd explicit warning: 'SECURITY: SUPABASE_SERVICE_ROLE_KEY must ONLY exist in quikadmin/.env. Never duplicate this key to root .env or frontend files.'",
            "status": "pending",
            "testStrategy": "Review documentation for accuracy against actual file contents. Verify no conflicting information in existing sections.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update CLAUDE.local.md with .env file authority reference",
            "description": "Update CLAUDE.local.md to reference the new environment documentation structure and clarify which .env file to edit for different variable types.",
            "dependencies": [
              3
            ],
            "details": "Update the 'Environment Config' section in N:\\IntelliFill\\CLAUDE.local.md to include a quick reference table similar to the full docs, and add a link to docs/reference/configuration/environment.md for complete details. Add note: 'Root .env is for AI tools only (TaskMaster keys). Backend config goes in quikadmin/.env.'",
            "status": "pending",
            "testStrategy": "Verify links work and information is consistent with the detailed documentation.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create .env.example templates that reflect the authority model",
            "description": "Update root .env.example (create if needed) and verify quikadmin/.env.example and quikadmin-web/.env.example accurately reflect their authoritative scope without overlapping variables.",
            "dependencies": [
              3
            ],
            "details": "Create/update root .env.example with ONLY AI tool keys section. Verify quikadmin/.env.example contains all backend vars without duplicating to root. Verify quikadmin-web/.env.example contains only VITE_ prefixed frontend vars. Remove any duplicate Supabase entries that may exist across .env.example files. Add header comments to each .env.example explaining the file's purpose and authority scope.",
            "status": "pending",
            "testStrategy": "Compare all .env.example files to ensure no variable duplication (except public anon keys which frontend needs). Verify a fresh clone can set up environment by following examples.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-01T12:55:45.631Z"
      },
      {
        "id": "173",
        "title": "Create Custom React Hooks Library Foundation",
        "description": "Create foundational custom React hooks (useToggle, useLocalStorage, useTimeout, useInterval) in quikadmin-web/src/hooks/ as the base library for codebase-wide refactoring of 53+ usage sites.",
        "details": "## Implementation Details\n\n### Overview\nCreate four foundational hooks following the existing pattern in `useDebounce.ts` with proper TypeScript types, JSDoc documentation, memory leak prevention, and comprehensive test coverage.\n\n### Directory Structure\n```\nquikadmin-web/src/hooks/\n├── useToggle.ts          # NEW - 25+ usage sites\n├── useLocalStorage.ts    # NEW - 19 usage sites  \n├── useTimeout.ts         # NEW - 5 usage sites\n├── useInterval.ts        # NEW - 4 usage sites\n├── index.ts              # NEW - barrel export\n├── useDebounce.ts        # EXISTS - reference pattern\n└── __tests__/\n    ├── useToggle.test.tsx\n    ├── useLocalStorage.test.tsx\n    ├── useTimeout.test.tsx\n    └── useInterval.test.tsx\n```\n\n### 1. useToggle Hook (`useToggle.ts`)\n\n**Target usage sites (25+):**\n- `AppLayout.tsx:144-145` - sidebarOpen, sidebarCollapsed\n- `autocomplete-field.tsx:95-99` - isOpen, isLoading, isFocused\n- `Register.tsx:40-42` - form toggles\n- `ResetPassword.tsx:29-35` - showPassword, showConfirmPassword, isLoading, resetSuccess\n- `Login.tsx:35` - showPassword\n- `ProfileDetail.tsx:94` - isEditing\n- `bulk-actions-toolbar.tsx:88,201` - showDeleteDialog\n\n**Implementation:**\n```typescript\nimport { useState, useCallback } from 'react'\n\n/**\n * Toggle boolean state with stable callbacks\n * @param initialValue - Initial boolean value (default: false)\n * @returns [value, toggle, setValue] tuple\n */\nexport function useToggle(initialValue: boolean = false): [\n  boolean,\n  () => void,\n  React.Dispatch<React.SetStateAction<boolean>>\n] {\n  const [value, setValue] = useState(initialValue)\n  const toggle = useCallback(() => setValue(v => !v), [])\n  return [value, toggle, setValue]\n}\n```\n\n### 2. useLocalStorage Hook (`useLocalStorage.ts`)\n\n**Target usage sites (19):**\n- `theme-provider.tsx:30,54` - theme persistence\n- `stores/index.ts:94-105` - auth/ui storage\n- `stores/migrationUtils.ts:20-77` - token handling\n- `documentService.ts:171,190,212` - auth token retrieval\n\n**Implementation:**\n```typescript\nimport { useState, useEffect, useCallback } from 'react'\n\n/**\n * Sync state with localStorage with SSR safety\n * @param key - localStorage key\n * @param initialValue - Initial value if no stored value exists\n * @returns [storedValue, setValue, removeValue] tuple\n */\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T\n): [T, (value: T | ((prev: T) => T)) => void, () => void] {\n  // SSR-safe initial state getter\n  const readValue = useCallback((): T => {\n    if (typeof window === 'undefined') return initialValue\n    try {\n      const item = window.localStorage.getItem(key)\n      return item ? (JSON.parse(item) as T) : initialValue\n    } catch (error) {\n      console.warn(`Error reading localStorage key \"${key}\":`, error)\n      return initialValue\n    }\n  }, [key, initialValue])\n\n  const [storedValue, setStoredValue] = useState<T>(readValue)\n\n  const setValue = useCallback((value: T | ((prev: T) => T)) => {\n    try {\n      const valueToStore = value instanceof Function ? value(storedValue) : value\n      setStoredValue(valueToStore)\n      if (typeof window !== 'undefined') {\n        window.localStorage.setItem(key, JSON.stringify(valueToStore))\n        // Dispatch event for cross-tab sync\n        window.dispatchEvent(new StorageEvent('storage', { key, newValue: JSON.stringify(valueToStore) }))\n      }\n    } catch (error) {\n      console.warn(`Error setting localStorage key \"${key}\":`, error)\n    }\n  }, [key, storedValue])\n\n  const removeValue = useCallback(() => {\n    try {\n      if (typeof window !== 'undefined') {\n        window.localStorage.removeItem(key)\n        setStoredValue(initialValue)\n      }\n    } catch (error) {\n      console.warn(`Error removing localStorage key \"${key}\":`, error)\n    }\n  }, [key, initialValue])\n\n  // Cross-tab synchronization\n  useEffect(() => {\n    const handleStorageChange = (e: StorageEvent) => {\n      if (e.key === key && e.newValue !== null) {\n        try {\n          setStoredValue(JSON.parse(e.newValue))\n        } catch {\n          setStoredValue(initialValue)\n        }\n      }\n    }\n    window.addEventListener('storage', handleStorageChange)\n    return () => window.removeEventListener('storage', handleStorageChange)\n  }, [key, initialValue])\n\n  return [storedValue, setValue, removeValue]\n}\n```\n\n### 3. useTimeout Hook (`useTimeout.ts`)\n\n**Target usage sites (5):**\n- `ResetPassword.tsx:125-129` - redirect after success\n- `AuthCallback.tsx:56-72` - auth redirect delay\n- `VerifyEmail.tsx:72-78` - verify redirect\n- `useUpload.ts:200-207` - retry delay\n- `autocomplete-field.tsx:179` - debounce close\n\n**Implementation:**\n```typescript\nimport { useEffect, useRef, useCallback } from 'react'\n\n/**\n * Safe setTimeout with automatic cleanup\n * @param callback - Function to execute\n * @param delay - Delay in ms (null to pause)\n */\nexport function useTimeout(callback: () => void, delay: number | null): void {\n  const savedCallback = useRef(callback)\n  \n  // Remember latest callback\n  useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n\n  useEffect(() => {\n    if (delay === null) return\n    const id = setTimeout(() => savedCallback.current(), delay)\n    return () => clearTimeout(id)\n  }, [delay])\n}\n\n/**\n * Returns a timeout controller for imperative usage\n * @returns { set, clear, isActive }\n */\nexport function useTimeoutFn(): {\n  set: (callback: () => void, delay: number) => void\n  clear: () => void\n  isActive: boolean\n} {\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null)\n  const isActiveRef = useRef(false)\n\n  const clear = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current)\n      timeoutRef.current = null\n      isActiveRef.current = false\n    }\n  }, [])\n\n  const set = useCallback((callback: () => void, delay: number) => {\n    clear()\n    isActiveRef.current = true\n    timeoutRef.current = setTimeout(() => {\n      isActiveRef.current = false\n      callback()\n    }, delay)\n  }, [clear])\n\n  // Cleanup on unmount\n  useEffect(() => clear, [clear])\n\n  return { set, clear, isActive: isActiveRef.current }\n}\n```\n\n### 4. useInterval Hook (`useInterval.ts`)\n\n**Target usage sites (4):**\n- `useApiData.ts:76` - 2min data refresh\n- `useApiData.ts:122` - 1min job polling\n- `useApiData.ts:189` - 1min metrics refresh\n- `KnowledgeBase.tsx:230` - document polling\n\n**Implementation:**\n```typescript\nimport { useEffect, useRef } from 'react'\n\n/**\n * Safe setInterval with automatic cleanup and pause support\n * @param callback - Function to execute on each interval\n * @param delay - Interval in ms (null to pause)\n */\nexport function useInterval(callback: () => void, delay: number | null): void {\n  const savedCallback = useRef(callback)\n\n  // Remember latest callback to avoid stale closures\n  useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n\n  useEffect(() => {\n    if (delay === null) return\n    const id = setInterval(() => savedCallback.current(), delay)\n    return () => clearInterval(id)\n  }, [delay])\n}\n\n/**\n * Interval with immediate first call option\n * @param callback - Function to execute\n * @param delay - Interval in ms (null to pause)\n * @param immediate - Run callback immediately on start\n */\nexport function useIntervalImmediate(\n  callback: () => void,\n  delay: number | null,\n  immediate: boolean = true\n): void {\n  const savedCallback = useRef(callback)\n  const hasRun = useRef(false)\n\n  useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n\n  useEffect(() => {\n    if (delay === null) return\n    \n    if (immediate && !hasRun.current) {\n      savedCallback.current()\n      hasRun.current = true\n    }\n    \n    const id = setInterval(() => savedCallback.current(), delay)\n    return () => clearInterval(id)\n  }, [delay, immediate])\n}\n```\n\n### 5. Barrel Export (`index.ts`)\n\n```typescript\n// Existing hooks\nexport * from './useDebounce'\nexport * from './useApiData'\nexport * from './useDocuments'\nexport * from './useDocumentActions'\nexport * from './useDocumentDetail'\nexport * from './useDocumentStats'\nexport * from './useJobPolling'\nexport * from './useUpload'\n\n// New foundation hooks\nexport * from './useToggle'\nexport * from './useLocalStorage'\nexport * from './useTimeout'\nexport * from './useInterval'\n```\n\n### Code Quality Requirements\n\n1. **Follow existing patterns** from `useDebounce.ts`:\n   - JSDoc comments with @param, @returns, @example\n   - Proper TypeScript generics where applicable\n   - `import * as React from 'react'` style (match codebase)\n\n2. **Memory leak prevention**:\n   - All timeouts/intervals must have cleanup functions\n   - Use useRef for mutable values to avoid stale closures\n   - Proper unmount cleanup via useEffect return\n\n3. **SSR compatibility**:\n   - Guard `window` and `localStorage` access with typeof checks\n   - Return sensible defaults during SSR\n\n4. **Performance optimizations**:\n   - Wrap callbacks in useCallback\n   - Use useRef for values that shouldn't trigger re-renders\n   - Avoid unnecessary re-renders in hook consumers",
        "testStrategy": "## Test Strategy\n\n### Test Framework\nUse Vitest with `@testing-library/react` following the existing pattern in `__tests__/useUpload.test.tsx`.\n\n### 1. useToggle Tests (`__tests__/useToggle.test.tsx`)\n```typescript\ndescribe('useToggle', () => {\n  it('initializes with default false value')\n  it('initializes with provided initial value')\n  it('toggles value when toggle() is called')\n  it('allows direct setValue calls')\n  it('toggle function is stable across renders (useCallback)')\n  it('works with React StrictMode double-render')\n})\n```\n\n### 2. useLocalStorage Tests (`__tests__/useLocalStorage.test.tsx`)\n```typescript\ndescribe('useLocalStorage', () => {\n  beforeEach(() => localStorage.clear())\n  \n  it('returns initial value when localStorage is empty')\n  it('returns stored value when localStorage has data')\n  it('updates localStorage when setValue is called')\n  it('handles JSON parsing errors gracefully')\n  it('supports functional updates like setState')\n  it('removeValue clears localStorage and resets to initial')\n  it('syncs across tabs via storage event')\n  it('handles SSR (typeof window === undefined) safely')\n})\n```\n\n### 3. useTimeout Tests (`__tests__/useTimeout.test.tsx`)\n```typescript\ndescribe('useTimeout', () => {\n  beforeEach(() => vi.useFakeTimers())\n  afterEach(() => vi.useRealTimers())\n  \n  it('calls callback after specified delay')\n  it('does not call callback when delay is null')\n  it('clears timeout on unmount (no memory leak)')\n  it('uses latest callback reference (no stale closure)')\n  it('resets timeout when delay changes')\n})\n\ndescribe('useTimeoutFn', () => {\n  it('set() starts a new timeout')\n  it('clear() cancels active timeout')\n  it('isActive reflects timeout state')\n  it('clears previous timeout when set() called again')\n})\n```\n\n### 4. useInterval Tests (`__tests__/useInterval.test.tsx`)\n```typescript\ndescribe('useInterval', () => {\n  beforeEach(() => vi.useFakeTimers())\n  afterEach(() => vi.useRealTimers())\n  \n  it('calls callback repeatedly at interval')\n  it('does not run when delay is null (paused)')\n  it('clears interval on unmount (no memory leak)')\n  it('uses latest callback reference (no stale closure)')\n  it('restarts interval when delay changes')\n})\n\ndescribe('useIntervalImmediate', () => {\n  it('runs callback immediately when immediate=true')\n  it('waits for first interval when immediate=false')\n  it('only runs immediate callback once even with re-renders')\n})\n```\n\n### 5. Integration Verification\n1. **Type checking**: `bun run typecheck` must pass\n2. **Lint**: `bun run lint` must pass with no new warnings\n3. **Build**: `bun run build` must succeed\n4. **All tests**: `bun run test` must pass including new tests\n\n### 6. Manual Verification\n1. Import hooks in a test component to verify barrel export works\n2. Verify hooks work in React StrictMode (double invocation)\n3. Check browser console for memory leak warnings after unmount\n\n### Expected Test Coverage\n- Each hook: 90%+ line coverage\n- Each hook: 100% branch coverage for critical paths (cleanup, null handling)",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-01T12:59:23.462Z"
      },
      {
        "id": "174",
        "title": "Implement useIntersectionObserver for Lazy Rendering in Grid Views",
        "description": "Create a useIntersectionObserver hook for lazy rendering of list items and integrate it into DocumentLibrary.tsx, ProfileList.tsx, Templates.tsx, and SearchInterface.tsx grid views to reduce DOM bloat by 60-70%.",
        "details": "## Implementation Details\n\n### Overview\nCreate a performant `useIntersectionObserver` hook following the established pattern in `quikadmin-web/src/hooks/useDebounce.ts` and integrate a wrapper component for lazy rendering in 4 grid view locations that currently render all items at once.\n\n### 1. Create useIntersectionObserver Hook (`quikadmin-web/src/hooks/useIntersectionObserver.ts`)\n\n```typescript\n/**\n * IntersectionObserver hook for lazy rendering and visibility detection\n * @module hooks/useIntersectionObserver\n */\n\nimport * as React from 'react'\n\nexport interface UseIntersectionObserverOptions {\n  /** IntersectionObserver threshold (0-1), default 0 */\n  threshold?: number | number[]\n  /** Root margin for early loading, default '100px 0px' */\n  rootMargin?: string\n  /** Element to use as viewport, default null (browser viewport) */\n  root?: Element | null\n  /** Freeze visibility state once visible (for lazy load), default true */\n  freezeOnceVisible?: boolean\n  /** Callback when visibility changes */\n  onVisibilityChange?: (isVisible: boolean) => void\n}\n\nexport interface UseIntersectionObserverReturn {\n  /** Ref to attach to the target element */\n  ref: React.RefCallback<Element>\n  /** Whether element is currently visible */\n  isVisible: boolean\n  /** The observed entry */\n  entry: IntersectionObserverEntry | null\n}\n\n/**\n * Hook to observe element visibility using IntersectionObserver API\n * \n * @example\n * ```tsx\n * function LazyCard({ children }) {\n *   const { ref, isVisible } = useIntersectionObserver({\n *     rootMargin: '200px 0px',\n *     freezeOnceVisible: true\n *   })\n *   \n *   return (\n *     <div ref={ref}>\n *       {isVisible ? children : <Skeleton />}\n *     </div>\n *   )\n * }\n * ```\n */\nexport function useIntersectionObserver({\n  threshold = 0,\n  rootMargin = '100px 0px',\n  root = null,\n  freezeOnceVisible = true,\n  onVisibilityChange\n}: UseIntersectionObserverOptions = {}): UseIntersectionObserverReturn\n```\n\nKey implementation points:\n- Use `React.useRef` for observer instance and frozen state\n- Use `React.useState` for `isVisible` and `entry`\n- Use `React.useCallback` for ref callback to handle element changes\n- Clean up observer on unmount via `React.useEffect`\n- Support SSR by checking `typeof IntersectionObserver !== 'undefined'`\n\n### 2. Create LazyRender Wrapper Component (`quikadmin-web/src/components/ui/lazy-render.tsx`)\n\n```typescript\ninterface LazyRenderProps {\n  children: React.ReactNode\n  /** Placeholder while not visible (default: null) */\n  placeholder?: React.ReactNode\n  /** Height for placeholder to prevent layout shift */\n  placeholderHeight?: number | string\n  /** Class for placeholder container */\n  placeholderClassName?: string\n  /** IntersectionObserver options */\n  rootMargin?: string\n  threshold?: number\n}\n\nexport function LazyRender({ \n  children, \n  placeholder,\n  placeholderHeight = 'auto',\n  placeholderClassName,\n  rootMargin = '200px 0px',\n  threshold = 0\n}: LazyRenderProps)\n```\n\n### 3. Integration Sites\n\n#### A. DocumentLibrary.tsx (lines 445-481)\nCurrent implementation renders all `DocumentCard` components at once in grid view.\n\n```typescript\n// Before: documents.map((doc) => <DocumentCard ... />)\n\n// After:\n{documents.map((doc) => (\n  <motion.div key={doc.id} variants={itemVariants} layoutId={doc.id} className=\"relative group\">\n    <LazyRender \n      placeholderHeight={256} // h-64\n      placeholderClassName=\"bg-muted/40 rounded-xl\"\n    >\n      {/* Selection Checkbox Overlay */}\n      <div className={cn(...)}>\n        <input type=\"checkbox\" ... />\n      </div>\n      <DocumentCard ... />\n    </LazyRender>\n  </motion.div>\n))}\n```\n\n#### B. ProfileList.tsx (lines 432-442)\nCurrent: `profiles.map((profile) => <ProfileCard ... />)`\n\nWrap each ProfileCard with LazyRender, using `placeholderHeight={180}` for grid cards.\n\n#### C. Templates.tsx (lines 514-522)\nCurrent: `filteredTemplates.map((template) => <TemplateCard ... />)`\n\nWrap each TemplateCard with LazyRender, using `placeholderHeight={280}` for template cards.\n\n#### D. SearchInterface.tsx (lines 382-384)\nCurrent: `searchResults.map((result, index) => <SearchResultCard ... />)`\n\nWrap each SearchResultCard with LazyRender, using `placeholderHeight={120}` for result cards.\n\n### 4. Memory Optimization Considerations\n\n- Use `freezeOnceVisible: true` to prevent re-observing after first render\n- Use appropriate `rootMargin` (200px default) for smooth scrolling\n- Consider batch rendering for very large lists (100+ items)\n- Maintain existing Framer Motion animations by placing LazyRender inside motion.div\n\n### 5. Export from Hooks Index\n\nCreate `quikadmin-web/src/hooks/index.ts` if not exists, or update to include:\n```typescript\nexport * from './useIntersectionObserver'\nexport * from './useDebounce'\n// ... other hooks\n```\n\n### 6. Test Setup Update\n\nThe test setup at `quikadmin-web/src/test/setup.tsx` (lines 116-121) already mocks IntersectionObserver but needs enhancement:\n\n```typescript\nglobal.IntersectionObserver = class IntersectionObserver {\n  callback: IntersectionObserverCallback\n  constructor(callback: IntersectionObserverCallback) {\n    this.callback = callback\n  }\n  observe(target: Element) {\n    // Immediately trigger with isIntersecting: true for tests\n    this.callback([{ isIntersecting: true, target } as IntersectionObserverEntry], this)\n  }\n  unobserve() {}\n  disconnect() {}\n} as any\n```",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useIntersectionObserver (`__tests__/useIntersectionObserver.test.tsx`)\n\n```typescript\nimport { renderHook, act } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { useIntersectionObserver } from '../useIntersectionObserver'\n\ndescribe('useIntersectionObserver', () => {\n  let mockObserver: any\n  let mockCallback: IntersectionObserverCallback\n\n  beforeEach(() => {\n    mockObserver = {\n      observe: vi.fn(),\n      unobserve: vi.fn(),\n      disconnect: vi.fn(),\n    }\n    global.IntersectionObserver = vi.fn((callback) => {\n      mockCallback = callback\n      return mockObserver\n    }) as any\n  })\n\n  it('initializes with isVisible false')\n  it('sets isVisible true when element intersects')\n  it('freezes visibility state when freezeOnceVisible is true')\n  it('toggles visibility when freezeOnceVisible is false')\n  it('calls onVisibilityChange callback when visibility changes')\n  it('cleans up observer on unmount')\n  it('handles ref reassignment correctly')\n  it('respects custom threshold and rootMargin options')\n  it('handles SSR gracefully (no IntersectionObserver)')\n})\n```\n\n### 2. Unit Tests for LazyRender Component (`__tests__/lazy-render.test.tsx`)\n\n```typescript\ndescribe('LazyRender', () => {\n  it('renders placeholder when not visible')\n  it('renders children when visible')\n  it('applies placeholderHeight style')\n  it('applies placeholderClassName to placeholder container')\n  it('maintains children after becoming visible (freeze behavior)')\n})\n```\n\n### 3. Integration Tests for Page Components\n\n#### DocumentLibrary Integration\n```typescript\n// quikadmin-web/src/pages/__tests__/DocumentLibrary.test.tsx\ndescribe('DocumentLibrary lazy rendering', () => {\n  it('renders placeholder skeletons for off-screen documents')\n  it('renders DocumentCard when scrolled into view')\n  it('maintains functionality after lazy load (click, select, etc.)')\n})\n```\n\n### 4. Performance Verification\n\nManual testing checklist:\n- [ ] Open DevTools Performance tab\n- [ ] Navigate to DocumentLibrary with 50+ documents\n- [ ] Verify initial DOM nodes reduced (compare before/after)\n- [ ] Scroll through list - confirm cards render smoothly\n- [ ] No visual glitches or layout shifts during lazy loading\n- [ ] Memory usage does not spike with large datasets\n\n### 5. DOM Node Count Verification\n\n```bash\n# In browser console before changes:\ndocument.querySelectorAll('[data-slot=\"document-card\"]').length\n# Should equal total document count\n\n# After changes (on initial load):\ndocument.querySelectorAll('[data-slot=\"document-card\"]').length  \n# Should be ~10-15 (visible + buffer) instead of total\n\n# After scrolling through all:\ndocument.querySelectorAll('[data-slot=\"document-card\"]').length\n# Should equal total (all have been rendered once)\n```\n\n### 6. Accessibility Verification\n\n- [ ] Keyboard navigation still works through lazy-loaded items\n- [ ] Screen readers can navigate the list\n- [ ] Focus management works correctly when items load\n\n### 7. Edge Cases\n\n- [ ] Empty list renders correctly\n- [ ] Single item list works\n- [ ] Rapid scrolling doesn't cause issues\n- [ ] Window resize triggers re-evaluation\n- [ ] Works with Framer Motion animations",
        "status": "done",
        "dependencies": [
          "173"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-01T15:11:52.526Z"
      },
      {
        "id": "175",
        "title": "Apply useDebouncedValue Hook to KnowledgeBase and DataTable Search Filters",
        "description": "Integrate the existing useDebouncedValue hook from hooks/useDebounce.ts into KnowledgeBase.tsx filter input and DataTable search input to reduce unnecessary filter computations by approximately 85% during rapid typing.",
        "details": "## Implementation Details\n\n### Overview\nThis is a quick-win optimization that applies the existing `useDebouncedValue` hook to two high-frequency filter/search inputs that currently trigger immediate computations on every keystroke.\n\n### 1. KnowledgeBase.tsx Filter (lines 157, 167-175, 322-330)\n\n**Current State:**\n```typescript\n// Line 157 - immediate state update triggers useMemo on every keystroke\nconst [searchFilter, setSearchFilter] = React.useState('')\n\n// Lines 167-175 - useMemo recomputes on every searchFilter change\nconst filteredSources = React.useMemo(() => {\n  if (!searchFilter) return sources\n  const lower = searchFilter.toLowerCase()\n  return sources.filter(\n    (s) =>\n      s.title.toLowerCase().includes(lower) ||\n      s.filename.toLowerCase().includes(lower)\n  )\n}, [sources, searchFilter])\n```\n\n**Required Changes:**\n```typescript\n// Add import at top of file\nimport { useDebouncedValue } from '@/hooks/useDebounce'\n\n// After line 157, add debounced value\nconst [searchFilter, setSearchFilter] = React.useState('')\nconst debouncedFilter = useDebouncedValue(searchFilter, 300) // 300ms delay\n\n// Update useMemo dependency to use debounced value\nconst filteredSources = React.useMemo(() => {\n  if (!debouncedFilter) return sources\n  const lower = debouncedFilter.toLowerCase()\n  return sources.filter(\n    (s) =>\n      s.title.toLowerCase().includes(lower) ||\n      s.filename.toLowerCase().includes(lower)\n  )\n}, [sources, debouncedFilter]) // Change dependency from searchFilter to debouncedFilter\n```\n\n**Note:** Keep using `searchFilter` (not debounced) for:\n- Input value display (line 327)\n- Empty state checks that show \"No documents match your filter\" (lines 346, 348, 353)\n- Clear filter button logic (line 356)\n\n### 2. DataTable Search (lines 150, 180-189, 229-235, 278-284)\n\n**Current State:**\n```typescript\n// Line 150 - immediate state update\nconst [searchQuery, setSearchQuery] = React.useState(\"\")\n\n// Lines 180-189 - filters on every keystroke\nconst filteredData = React.useMemo(() => {\n  if (!searchQuery) return data\n  return data.filter((row) =>\n    columns.some((column) => {\n      const value = row[column.key]\n      return value?.toString().toLowerCase().includes(searchQuery.toLowerCase())\n    })\n  )\n}, [data, searchQuery, columns])\n```\n\n**Required Changes:**\n```typescript\n// Add import at top of file\nimport { useDebouncedValue } from '@/hooks/useDebounce'\n\n// After line 150, add debounced value\nconst [searchQuery, setSearchQuery] = React.useState(\"\")\nconst debouncedQuery = useDebouncedValue(searchQuery, 300)\n\n// Update filteredData useMemo to use debounced value\nconst filteredData = React.useMemo(() => {\n  if (!debouncedQuery) return data\n  return data.filter((row) =>\n    columns.some((column) => {\n      const value = row[column.key]\n      return value?.toString().toLowerCase().includes(debouncedQuery.toLowerCase())\n    })\n  )\n}, [data, debouncedQuery, columns]) // Change dependency from searchQuery to debouncedQuery\n\n// Update handleSearch - keep immediate state for input display\nconst handleSearch = (query: string) => {\n  setSearchQuery(query)\n  setCurrentPage(1) // Still reset page immediately for UX\n  // Note: onSearch callback might need debounced value for external filtering\n  if (onSearch) {\n    // Consider: should this use debouncedQuery? Depends on use case\n    onSearch(query)\n  }\n}\n```\n\n**Note:** Keep using `searchQuery` (not debounced) for:\n- Input value display (line 280)\n- Empty state message check (line 301)\n\n### 3. Performance Consideration\n\nThe 300ms debounce delay matches the existing pattern in DocumentLibrary.tsx (line 103) and provides:\n- Immediate visual feedback (input shows typed characters instantly)\n- Reduced filter computations (filters only run 300ms after typing stops)\n- Approximately 85% reduction in filter function calls during rapid typing\n- No perceptible delay for users (300ms is below human perception threshold for \"lag\")\n\n### Files to Modify\n1. `quikadmin-web/src/pages/KnowledgeBase.tsx` - Add import, debounced value, update useMemo\n2. `quikadmin-web/src/components/features/data-table.tsx` - Add import, debounced value, update useMemo",
        "testStrategy": "## Test Strategy\n\n### 1. Manual Testing - KnowledgeBase Filter\n\n1. **Navigate to Knowledge Base page** with multiple document sources loaded\n2. **Type rapidly** in the filter input (e.g., \"test document\" quickly)\n3. **Verify:**\n   - Input text appears immediately (no typing lag)\n   - Filter results update approximately 300ms after stopping typing\n   - Filtered results are correct after debounce\n4. **Clear filter** - verify immediate response\n5. **Edge cases:**\n   - Empty filter returns all sources\n   - No matches shows \"No documents match your filter\" state\n   - Clear Filter button works correctly\n\n### 2. Manual Testing - DataTable Search\n\n1. **Navigate to any page using DataTable** (e.g., ProfileList or similar)\n2. **Type rapidly** in the search input\n3. **Verify:**\n   - Input text appears immediately\n   - Table filters approximately 300ms after stopping typing\n   - Pagination resets to page 1 on search\n   - Sort order is preserved after filtering\n4. **Edge cases:**\n   - Empty search returns all data\n   - No matches shows appropriate empty state\n\n### 3. Performance Verification\n\n1. **Add temporary console.log** inside the useMemo callbacks:\n   ```typescript\n   const filteredSources = React.useMemo(() => {\n     console.log('[KnowledgeBase] Filter computation triggered')\n     // ... rest of code\n   }, [sources, debouncedFilter])\n   ```\n2. **Type 10 characters rapidly** and count console logs\n3. **Expected:** 1-2 logs instead of 10 logs (85%+ reduction)\n4. **Remove console.log** after verification\n\n### 4. Unit Tests (Optional Enhancement)\n\nAdd test in `quikadmin-web/src/hooks/__tests__/useDebounce.test.tsx`:\n```typescript\ndescribe('useDebouncedValue', () => {\n  it('debounces rapid value changes', async () => {\n    const { result, rerender } = renderHook(\n      ({ value }) => useDebouncedValue(value, 300),\n      { initialProps: { value: '' } }\n    )\n    \n    // Rapid updates\n    rerender({ value: 'a' })\n    rerender({ value: 'ab' })\n    rerender({ value: 'abc' })\n    \n    // Value should still be empty (debouncing)\n    expect(result.current).toBe('')\n    \n    // Wait for debounce\n    await act(async () => {\n      await new Promise(resolve => setTimeout(resolve, 350))\n    })\n    \n    // Now should have final value\n    expect(result.current).toBe('abc')\n  })\n})\n```\n\n### 5. Regression Testing\n\n1. **Verify DocumentLibrary.tsx** still works (uses same pattern)\n2. **Verify SearchInterface.tsx** still works (uses same hook)\n3. **Run existing frontend tests**: `bun run test`\n4. **Run type checking**: `bun run typecheck`",
        "status": "done",
        "dependencies": [
          "173"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-01T13:17:41.251Z"
      },
      {
        "id": "176",
        "title": "Implement Batch Polling with Exponential Backoff for KnowledgeBase Processing Status",
        "description": "Refactor the N+1 polling anti-pattern in KnowledgeBase.tsx (lines 222-235) that currently makes individual API calls for each processing document every 5 seconds. Implement batch refresh using useInterval hook with jitter and exponential backoff to reduce API calls by ~80%.",
        "details": "## Implementation Details\n\n### Overview\nThe current implementation in `KnowledgeBase.tsx:222-235` calls `refreshSource(id)` for **each** processing document individually every 5 seconds, causing a thundering herd problem when multiple documents are processing simultaneously. This needs to be replaced with:\n1. A single batch API call to refresh all processing sources at once\n2. A `useInterval` hook with jitter and exponential backoff\n\n### 1. Create useInterval Hook (`quikadmin-web/src/hooks/useInterval.ts`)\n\nFollow the pattern established in `useDebounce.ts`:\n\n```typescript\n/**\n * Interval hook with jitter and exponential backoff\n * @module hooks/useInterval\n */\nimport * as React from 'react'\n\ninterface UseIntervalOptions {\n  /** Base interval in milliseconds (default: 5000) */\n  delay: number\n  /** Enable/disable the interval (default: true) */\n  enabled?: boolean\n  /** Add random jitter to prevent thundering herd (0-1, default: 0.2 = ±20%) */\n  jitter?: number\n  /** Use exponential backoff on consecutive unchanged responses */\n  exponentialBackoff?: boolean\n  /** Maximum delay when using exponential backoff (default: 30000ms) */\n  maxDelay?: number\n  /** Backoff multiplier (default: 1.5) */\n  backoffMultiplier?: number\n}\n\nexport function useInterval(\n  callback: () => void | Promise<void>,\n  options: UseIntervalOptions\n): {\n  reset: () => void  // Reset backoff to initial delay\n  pause: () => void\n  resume: () => void\n} {\n  const { \n    delay, \n    enabled = true, \n    jitter = 0.2, \n    exponentialBackoff = false,\n    maxDelay = 30000,\n    backoffMultiplier = 1.5\n  } = options\n  \n  const savedCallback = React.useRef(callback)\n  const intervalRef = React.useRef<NodeJS.Timeout | null>(null)\n  const currentDelayRef = React.useRef(delay)\n  const isPausedRef = React.useRef(false)\n  \n  // Update callback ref on each render\n  React.useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n  \n  const calculateDelay = React.useCallback(() => {\n    let currentDelay = currentDelayRef.current\n    \n    // Apply jitter: ±jitter% of current delay\n    const jitterAmount = currentDelay * jitter\n    const jitteredDelay = currentDelay + (Math.random() * 2 - 1) * jitterAmount\n    \n    return Math.round(jitteredDelay)\n  }, [jitter])\n  \n  const scheduleNext = React.useCallback(() => {\n    if (!enabled || isPausedRef.current) return\n    \n    intervalRef.current = setTimeout(async () => {\n      await savedCallback.current()\n      \n      // Apply exponential backoff if enabled\n      if (exponentialBackoff) {\n        currentDelayRef.current = Math.min(\n          currentDelayRef.current * backoffMultiplier,\n          maxDelay\n        )\n      }\n      \n      scheduleNext()\n    }, calculateDelay())\n  }, [enabled, calculateDelay, exponentialBackoff, backoffMultiplier, maxDelay])\n  \n  const reset = React.useCallback(() => {\n    currentDelayRef.current = delay\n    if (intervalRef.current) {\n      clearTimeout(intervalRef.current)\n    }\n    scheduleNext()\n  }, [delay, scheduleNext])\n  \n  const pause = React.useCallback(() => {\n    isPausedRef.current = true\n    if (intervalRef.current) {\n      clearTimeout(intervalRef.current)\n    }\n  }, [])\n  \n  const resume = React.useCallback(() => {\n    isPausedRef.current = false\n    scheduleNext()\n  }, [scheduleNext])\n  \n  React.useEffect(() => {\n    if (enabled && !isPausedRef.current) {\n      scheduleNext()\n    }\n    \n    return () => {\n      if (intervalRef.current) {\n        clearTimeout(intervalRef.current)\n      }\n    }\n  }, [enabled, scheduleNext])\n  \n  return { reset, pause, resume }\n}\n```\n\n### 2. Add Batch Refresh to knowledgeService.ts\n\nAdd new batch endpoint function to `quikadmin-web/src/services/knowledgeService.ts`:\n\n```typescript\n/**\n * Batch refresh multiple document sources by IDs\n * More efficient than multiple individual calls\n */\nexport const getKnowledgeSourcesBatch = async (\n  sourceIds: string[]\n): Promise<{\n  success: boolean;\n  sources: (DocumentSource & { chunkCount: number })[];\n}> => {\n  if (sourceIds.length === 0) {\n    return { success: true, sources: [] }\n  }\n  const response = await api.post('/knowledge/sources/batch', { ids: sourceIds });\n  return response.data;\n};\n```\n\n### 3. Add Batch Refresh Action to knowledgeStore.ts\n\nAdd to `KnowledgeState` interface (around line 76):\n```typescript\nrefreshSourcesBatch: (sourceIds: string[]) => Promise<void>;\n```\n\nAdd implementation (after `refreshSource`):\n```typescript\nrefreshSourcesBatch: async (sourceIds) => {\n  if (sourceIds.length === 0) return;\n  \n  try {\n    const response = await knowledgeService.getKnowledgeSourcesBatch(sourceIds);\n    \n    set((state) => {\n      for (const source of response.sources) {\n        const index = state.sources.findIndex((s) => s.id === source.id);\n        if (index !== -1) {\n          state.sources[index] = source;\n        }\n      }\n    });\n  } catch (error) {\n    console.error('Failed to batch refresh sources:', error);\n  }\n},\n```\n\n### 4. Update Backend to Support Batch Endpoint (if not exists)\n\nCheck if `/api/knowledge/sources/batch` exists in backend. If not, add to `quikadmin/src/routes/knowledge.ts`:\n\n```typescript\n// POST /api/knowledge/sources/batch - Batch get sources by IDs\nrouter.post('/sources/batch', async (req, res) => {\n  const { ids } = req.body;\n  \n  if (!Array.isArray(ids) || ids.length === 0) {\n    return res.status(400).json({ success: false, error: 'IDs array required' });\n  }\n  \n  // Limit batch size to prevent abuse\n  if (ids.length > 50) {\n    return res.status(400).json({ success: false, error: 'Maximum 50 IDs per batch' });\n  }\n  \n  const sources = await prisma.documentSource.findMany({\n    where: { id: { in: ids }, organizationId: req.user.organizationId },\n    include: { _count: { select: { chunks: true } } }\n  });\n  \n  res.json({\n    success: true,\n    sources: sources.map(s => ({ ...s, chunkCount: s._count.chunks }))\n  });\n});\n```\n\n### 5. Refactor KnowledgeBase.tsx (lines 222-235)\n\nReplace the current N+1 polling implementation:\n\n```typescript\n// OLD CODE (DELETE):\n// React.useEffect(() => {\n//   const processingIds = sources\n//     .filter((s) => s.status === 'PROCESSING' || s.status === 'PENDING')\n//     .map((s) => s.id)\n//   if (processingIds.length === 0) return\n//   const interval = setInterval(() => {\n//     processingIds.forEach((id) => refreshSource(id))\n//   }, 5000)\n//   return () => clearInterval(interval)\n// }, [sources, refreshSource])\n\n// NEW CODE:\nimport { useInterval } from '@/hooks/useInterval'\n\n// Inside component, get batch refresh action:\nconst { refreshSourcesBatch } = useKnowledgeStore()\n\n// Track processing IDs with useMemo to avoid recalculating on every render\nconst processingIds = React.useMemo(() => \n  sources\n    .filter((s) => s.status === 'PROCESSING' || s.status === 'PENDING')\n    .map((s) => s.id),\n  [sources]\n)\n\n// Use the new useInterval hook with batch refresh\nconst { reset: resetPolling } = useInterval(\n  async () => {\n    if (processingIds.length > 0) {\n      await refreshSourcesBatch(processingIds)\n    }\n  },\n  {\n    delay: 5000,\n    enabled: processingIds.length > 0,\n    jitter: 0.2, // ±20% jitter to prevent thundering herd\n    exponentialBackoff: true,\n    maxDelay: 30000, // Max 30 seconds between polls\n    backoffMultiplier: 1.5\n  }\n)\n\n// Reset polling when a new document starts processing\nReact.useEffect(() => {\n  if (processingIds.length > 0) {\n    resetPolling()\n  }\n}, [processingIds.length, resetPolling])\n```\n\n### 6. Export from hooks/index.ts\n\nAdd to `quikadmin-web/src/hooks/index.ts`:\n```typescript\nexport { useInterval } from './useInterval'\n```\n\n### Files to Modify:\n1. `quikadmin-web/src/hooks/useInterval.ts` (NEW)\n2. `quikadmin-web/src/hooks/index.ts` (UPDATE - add export)\n3. `quikadmin-web/src/services/knowledgeService.ts` (ADD batch function)\n4. `quikadmin-web/src/stores/knowledgeStore.ts` (ADD refreshSourcesBatch action)\n5. `quikadmin-web/src/pages/KnowledgeBase.tsx` (REFACTOR lines 222-235)\n6. `quikadmin/src/routes/knowledge.ts` (ADD batch endpoint if missing)\n\n### API Call Reduction Math:\n- Before: 10 processing docs × 12 polls/min = 120 API calls/min\n- After: 1 batch call × 12 polls/min (reducing with backoff) = ~8-12 API calls/min\n- Savings: **~90% reduction in API calls**",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useInterval Hook (`__tests__/useInterval.test.tsx`)\n\n```typescript\nimport { renderHook, act, waitFor } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { useInterval } from '../useInterval'\n\ndescribe('useInterval', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n  })\n  \n  afterEach(() => {\n    vi.useRealTimers()\n  })\n  \n  it('calls callback at specified interval', async () => {\n    const callback = vi.fn()\n    renderHook(() => useInterval(callback, { delay: 1000 }))\n    \n    await act(async () => {\n      vi.advanceTimersByTime(3000)\n    })\n    \n    expect(callback).toHaveBeenCalledTimes(3)\n  })\n  \n  it('does not call callback when disabled', () => {\n    const callback = vi.fn()\n    renderHook(() => useInterval(callback, { delay: 1000, enabled: false }))\n    \n    vi.advanceTimersByTime(5000)\n    \n    expect(callback).not.toHaveBeenCalled()\n  })\n  \n  it('applies jitter to delay', async () => {\n    const callback = vi.fn()\n    const delays: number[] = []\n    \n    // Mock setTimeout to capture actual delays\n    const originalSetTimeout = globalThis.setTimeout\n    vi.spyOn(globalThis, 'setTimeout').mockImplementation((fn, delay) => {\n      delays.push(delay as number)\n      return originalSetTimeout(fn, delay)\n    })\n    \n    renderHook(() => useInterval(callback, { delay: 1000, jitter: 0.2 }))\n    \n    await act(async () => {\n      vi.advanceTimersByTime(5000)\n    })\n    \n    // Check delays are within jitter range (800-1200ms)\n    delays.forEach(d => {\n      expect(d).toBeGreaterThanOrEqual(800)\n      expect(d).toBeLessThanOrEqual(1200)\n    })\n  })\n  \n  it('applies exponential backoff', async () => {\n    const callback = vi.fn()\n    renderHook(() => useInterval(callback, { \n      delay: 1000, \n      exponentialBackoff: true,\n      backoffMultiplier: 2,\n      maxDelay: 10000\n    }))\n    \n    // After several iterations, delay should increase\n    await act(async () => {\n      vi.advanceTimersByTime(50000)\n    })\n    \n    // Verify backoff occurred (fewer calls than linear would produce)\n    expect(callback.mock.calls.length).toBeLessThan(50)\n  })\n  \n  it('reset() restores initial delay', async () => {\n    const callback = vi.fn()\n    const { result } = renderHook(() => useInterval(callback, { \n      delay: 1000, \n      exponentialBackoff: true,\n      maxDelay: 10000\n    }))\n    \n    await act(async () => {\n      vi.advanceTimersByTime(10000)\n    })\n    \n    act(() => {\n      result.current.reset()\n    })\n    \n    // After reset, should poll at initial rate again\n    const callsBefore = callback.mock.calls.length\n    await act(async () => {\n      vi.advanceTimersByTime(1000)\n    })\n    \n    expect(callback.mock.calls.length).toBeGreaterThan(callsBefore)\n  })\n  \n  it('pause() and resume() work correctly', () => {\n    const callback = vi.fn()\n    const { result } = renderHook(() => useInterval(callback, { delay: 1000 }))\n    \n    vi.advanceTimersByTime(2500)\n    expect(callback).toHaveBeenCalledTimes(2)\n    \n    act(() => result.current.pause())\n    vi.advanceTimersByTime(5000)\n    expect(callback).toHaveBeenCalledTimes(2) // No new calls\n    \n    act(() => result.current.resume())\n    vi.advanceTimersByTime(2000)\n    expect(callback).toHaveBeenCalledTimes(4)\n  })\n})\n```\n\n### 2. Integration Tests for KnowledgeBase Polling\n\n```typescript\n// In knowledgeStore.test.ts, add:\ndescribe('refreshSourcesBatch', () => {\n  it('batch updates multiple sources in single call', async () => {\n    const mockSources = [\n      { id: '1', title: 'Doc 1', status: 'READY', chunkCount: 5 },\n      { id: '2', title: 'Doc 2', status: 'READY', chunkCount: 3 },\n    ]\n    \n    vi.mocked(knowledgeService.getKnowledgeSourcesBatch).mockResolvedValue({\n      success: true,\n      sources: mockSources as any,\n    })\n    \n    // Set initial state with PROCESSING documents\n    useKnowledgeStore.setState({\n      sources: [\n        { id: '1', title: 'Doc 1', status: 'PROCESSING' },\n        { id: '2', title: 'Doc 2', status: 'PROCESSING' },\n      ] as any,\n    })\n    \n    await useKnowledgeStore.getState().refreshSourcesBatch(['1', '2'])\n    \n    expect(knowledgeService.getKnowledgeSourcesBatch).toHaveBeenCalledWith(['1', '2'])\n    expect(useKnowledgeStore.getState().sources[0].status).toBe('READY')\n    expect(useKnowledgeStore.getState().sources[1].status).toBe('READY')\n  })\n  \n  it('handles empty IDs array gracefully', async () => {\n    await useKnowledgeStore.getState().refreshSourcesBatch([])\n    expect(knowledgeService.getKnowledgeSourcesBatch).not.toHaveBeenCalled()\n  })\n})\n```\n\n### 3. Manual Testing Checklist\n\n1. **Upload 3+ documents simultaneously**\n   - [ ] Open browser DevTools Network tab\n   - [ ] Upload 3 documents at once\n   - [ ] Verify only ONE batch API call per poll interval (not 3 individual calls)\n   - [ ] Confirm all documents show processing status updates\n\n2. **Jitter Verification**\n   - [ ] Watch Network tab timing for batch calls\n   - [ ] Verify intervals vary slightly (±20% of 5 seconds = 4-6 seconds)\n   - [ ] Multiple browser tabs should NOT poll at exact same time\n\n3. **Exponential Backoff Test**\n   - [ ] Upload document, watch Network tab\n   - [ ] Initial polls: ~5 seconds apart\n   - [ ] After 30+ seconds: intervals should increase\n   - [ ] Maximum interval should not exceed 30 seconds\n\n4. **Backoff Reset Test**\n   - [ ] Let backoff increase to 20+ seconds\n   - [ ] Upload a new document\n   - [ ] Verify polling resets to 5-second interval\n\n5. **API Call Count Verification**\n   - [ ] Count API calls over 1 minute with 5 processing documents\n   - [ ] Before fix: ~60 calls (5 docs × 12 polls/min)\n   - [ ] After fix: ~12 calls or fewer (1 batch × 12 polls, decreasing with backoff)\n   - [ ] Reduction should be ~80-90%\n\n### 4. Backend Batch Endpoint Test\n\n```bash\n# Test batch endpoint directly\ncurl -X POST http://localhost:3002/api/knowledge/sources/batch \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"ids\": [\"source-id-1\", \"source-id-2\"]}'\n\n# Verify response contains both sources\n# Verify 400 error for empty array\n# Verify 400 error for array > 50 items\n```\n\n### 5. Performance Metrics\n\nMonitor these before/after metrics:\n- API calls per minute during processing\n- Backend request queue depth\n- Database query count for source lookups\n- Frontend re-render count (React DevTools Profiler)",
        "status": "done",
        "dependencies": [
          "173"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-01T14:59:32.646Z"
      },
      {
        "id": "177",
        "title": "Create useKeyPress Hook for Keyboard Shortcuts",
        "description": "Create a useKeyPress hook in quikadmin-web/src/hooks/ for declarative keyboard shortcut handling and apply it to DocumentLibrary.tsx (lines 191-216) and search-bar.tsx (lines 94-110) to replace manual window.addEventListener patterns with proper cleanup and improved maintainability.",
        "details": "## Implementation Details\n\n### Overview\nCreate a reusable `useKeyPress` hook following the established pattern in `quikadmin-web/src/hooks/useDebounce.ts` with proper TypeScript types, JSDoc documentation, and memory leak prevention. This hook will provide a declarative API for keyboard shortcuts, replacing the manual `window.addEventListener` patterns found in 2 locations.\n\n### 1. Create useKeyPress Hook (`quikadmin-web/src/hooks/useKeyPress.ts`)\n\n```typescript\n/**\n * Keyboard shortcut hook for React\n * @module hooks/useKeyPress\n */\n\nimport * as React from 'react'\n\nexport interface KeyPressOptions {\n  /** Key to listen for (e.g., 'a', 'Escape', 'Delete', 'k') */\n  key: string\n  /** Require Ctrl/Cmd modifier */\n  ctrlOrMeta?: boolean\n  /** Require Shift modifier */\n  shift?: boolean\n  /** Require Alt modifier */\n  alt?: boolean\n  /** Callback when key combination is pressed */\n  onPress: (event: KeyboardEvent) => void\n  /** Whether to prevent default browser behavior */\n  preventDefault?: boolean\n  /** Whether the shortcut is currently enabled */\n  enabled?: boolean\n  /** Target element (defaults to window) */\n  target?: EventTarget | null\n}\n\nexport interface KeyPressBinding {\n  key: string\n  ctrlOrMeta?: boolean\n  shift?: boolean\n  alt?: boolean\n  onPress: (event: KeyboardEvent) => void\n  preventDefault?: boolean\n  enabled?: boolean\n}\n\n/**\n * Hook for handling single keyboard shortcut\n *\n * @example\n * ```tsx\n * // Ctrl/Cmd + A to select all\n * useKeyPress({\n *   key: 'a',\n *   ctrlOrMeta: true,\n *   onPress: () => handleSelectAll(),\n *   enabled: documents.length > 0\n * })\n * ```\n */\nexport function useKeyPress(options: KeyPressOptions): void {\n  const { \n    key, \n    ctrlOrMeta = false, \n    shift = false, \n    alt = false,\n    onPress, \n    preventDefault = true,\n    enabled = true,\n    target\n  } = options\n\n  const savedCallback = React.useRef(onPress)\n  \n  // Update ref when callback changes\n  React.useLayoutEffect(() => {\n    savedCallback.current = onPress\n  }, [onPress])\n\n  React.useEffect(() => {\n    if (!enabled) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const keyMatch = e.key.toLowerCase() === key.toLowerCase()\n      const ctrlMatch = !ctrlOrMeta || (e.ctrlKey || e.metaKey)\n      const shiftMatch = !shift || e.shiftKey\n      const altMatch = !alt || e.altKey\n      \n      if (keyMatch && ctrlMatch && shiftMatch && altMatch) {\n        if (preventDefault) {\n          e.preventDefault()\n        }\n        savedCallback.current(e)\n      }\n    }\n\n    const eventTarget = target ?? window\n    eventTarget.addEventListener('keydown', handleKeyDown as EventListener)\n    \n    return () => {\n      eventTarget.removeEventListener('keydown', handleKeyDown as EventListener)\n    }\n  }, [key, ctrlOrMeta, shift, alt, preventDefault, enabled, target])\n}\n\n/**\n * Hook for handling multiple keyboard shortcuts\n *\n * @example\n * ```tsx\n * useKeyPressBindings([\n *   { key: 'a', ctrlOrMeta: true, onPress: handleSelectAll },\n *   { key: 'Escape', onPress: handleClear },\n *   { key: 'Delete', onPress: handleDelete, enabled: selectionCount > 0 },\n *   { key: 'f', ctrlOrMeta: true, onPress: focusSearch },\n * ])\n * ```\n */\nexport function useKeyPressBindings(bindings: KeyPressBinding[]): void {\n  const savedBindings = React.useRef(bindings)\n  \n  React.useLayoutEffect(() => {\n    savedBindings.current = bindings\n  }, [bindings])\n\n  React.useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      for (const binding of savedBindings.current) {\n        if (binding.enabled === false) continue\n        \n        const keyMatch = e.key.toLowerCase() === binding.key.toLowerCase()\n        const ctrlMatch = !binding.ctrlOrMeta || (e.ctrlKey || e.metaKey)\n        const shiftMatch = !binding.shift || e.shiftKey\n        const altMatch = !binding.alt || e.altKey\n        \n        if (keyMatch && ctrlMatch && shiftMatch && altMatch) {\n          if (binding.preventDefault !== false) {\n            e.preventDefault()\n          }\n          binding.onPress(e)\n          return // Only handle first matching binding\n        }\n      }\n    }\n\n    window.addEventListener('keydown', handleKeyDown)\n    return () => window.removeEventListener('keydown', handleKeyDown)\n  }, [])\n}\n```\n\n### 2. Refactor DocumentLibrary.tsx (lines 191-216)\n\n**Before (current manual implementation):**\n```typescript\nReact.useEffect(() => {\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if ((e.ctrlKey || e.metaKey) && e.key === 'a' && documents.length > 0) {\n      e.preventDefault();\n      handleSelectAll();\n    }\n    // ... more cases\n  };\n  window.addEventListener('keydown', handleKeyDown);\n  return () => window.removeEventListener('keydown', handleKeyDown);\n}, [documents, selectionCount, selectedDocumentId, handleSelectAll, clearSelection, handleBulkDelete]);\n```\n\n**After (using useKeyPressBindings):**\n```typescript\nimport { useKeyPressBindings } from '@/hooks/useKeyPress'\n\n// Replace lines 191-216 with:\nuseKeyPressBindings([\n  { \n    key: 'a', \n    ctrlOrMeta: true, \n    onPress: handleSelectAll,\n    enabled: documents.length > 0 \n  },\n  { \n    key: 'Escape', \n    onPress: () => {\n      if (selectedDocumentId) setSelectedDocumentId(null)\n      else if (selectionCount > 0) clearSelection()\n    },\n    preventDefault: false\n  },\n  { \n    key: 'Delete', \n    onPress: handleBulkDelete,\n    enabled: selectionCount > 0 \n  },\n  { \n    key: 'f', \n    ctrlOrMeta: true, \n    onPress: () => document.getElementById('document-search')?.focus()\n  },\n])\n```\n\n### 3. Refactor search-bar.tsx (lines 94-110)\n\n**Before (current manual implementation):**\n```typescript\nReact.useEffect(() => {\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if ((e.ctrlKey || e.metaKey) && e.key === \"k\") {\n      e.preventDefault()\n      inputRef.current?.focus()\n    }\n    if (e.key === \"Escape\" && value && document.activeElement === inputRef.current) {\n      onChange(\"\")\n      inputRef.current?.blur()\n    }\n  }\n  window.addEventListener(\"keydown\", handleKeyDown)\n  return () => window.removeEventListener(\"keydown\", handleKeyDown)\n}, [value, onChange])\n```\n\n**After (using useKeyPressBindings):**\n```typescript\nimport { useKeyPressBindings } from '@/hooks/useKeyPress'\n\n// Replace lines 94-110 with:\nuseKeyPressBindings([\n  { \n    key: 'k', \n    ctrlOrMeta: true, \n    onPress: () => inputRef.current?.focus()\n  },\n  { \n    key: 'Escape', \n    onPress: () => {\n      if (value && document.activeElement === inputRef.current) {\n        onChange(\"\")\n        inputRef.current?.blur()\n      }\n    },\n    preventDefault: false,\n    enabled: Boolean(value)\n  },\n])\n\n### 4. Export from hooks index (create if needed)\n\nIf `quikadmin-web/src/hooks/index.ts` doesn't exist, create it:\n```typescript\nexport * from './useDebounce'\nexport * from './useKeyPress'\nexport * from './useDocuments'\nexport * from './useDocumentDetail'\nexport * from './useDocumentStats'\nexport * from './useDocumentActions'\nexport * from './useUpload'\nexport * from './useJobPolling'\nexport * from './useApiData'\n```\n\n### Key Design Decisions\n\n1. **useRef for callbacks**: Prevents stale closure issues without requiring callback in deps array\n2. **useLayoutEffect for refs**: Ensures ref is updated synchronously before any effects run\n3. **enabled flag**: Allows conditional activation without remounting the effect\n4. **ctrlOrMeta**: Abstracts cross-platform modifier (Ctrl on Windows, Cmd on Mac)\n5. **preventDefault default true**: Most keyboard shortcuts should prevent browser defaults\n6. **Single handler in useKeyPressBindings**: More efficient than multiple event listeners",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useKeyPress (`__tests__/useKeyPress.test.tsx`)\n\n```typescript\nimport { renderHook, act } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { useKeyPress, useKeyPressBindings } from '../useKeyPress'\n\ndescribe('useKeyPress', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n  })\n\n  afterEach(() => {\n    vi.useRealTimers()\n  })\n\n  it('calls onPress when key is pressed', () => {\n    const onPress = vi.fn()\n    renderHook(() => useKeyPress({ key: 'a', onPress }))\n\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'a' }))\n    })\n\n    expect(onPress).toHaveBeenCalledTimes(1)\n  })\n\n  it('requires ctrlOrMeta when specified', () => {\n    const onPress = vi.fn()\n    renderHook(() => useKeyPress({ key: 'a', ctrlOrMeta: true, onPress }))\n\n    // Without modifier - should not trigger\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'a' }))\n    })\n    expect(onPress).not.toHaveBeenCalled()\n\n    // With Ctrl - should trigger\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'a', ctrlKey: true }))\n    })\n    expect(onPress).toHaveBeenCalledTimes(1)\n\n    // With Meta - should trigger\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'a', metaKey: true }))\n    })\n    expect(onPress).toHaveBeenCalledTimes(2)\n  })\n\n  it('does not call onPress when enabled is false', () => {\n    const onPress = vi.fn()\n    renderHook(() => useKeyPress({ key: 'Delete', onPress, enabled: false }))\n\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Delete' }))\n    })\n\n    expect(onPress).not.toHaveBeenCalled()\n  })\n\n  it('prevents default when preventDefault is true', () => {\n    const onPress = vi.fn()\n    renderHook(() => useKeyPress({ key: 'f', ctrlOrMeta: true, onPress, preventDefault: true }))\n\n    const event = new KeyboardEvent('keydown', { key: 'f', ctrlKey: true })\n    const preventDefaultSpy = vi.spyOn(event, 'preventDefault')\n\n    act(() => {\n      window.dispatchEvent(event)\n    })\n\n    expect(preventDefaultSpy).toHaveBeenCalled()\n  })\n\n  it('cleans up event listener on unmount', () => {\n    const onPress = vi.fn()\n    const removeEventListenerSpy = vi.spyOn(window, 'removeEventListener')\n    \n    const { unmount } = renderHook(() => useKeyPress({ key: 'Escape', onPress }))\n    unmount()\n\n    expect(removeEventListenerSpy).toHaveBeenCalledWith('keydown', expect.any(Function))\n  })\n})\n\ndescribe('useKeyPressBindings', () => {\n  it('handles multiple bindings', () => {\n    const onPressA = vi.fn()\n    const onPressEscape = vi.fn()\n    \n    renderHook(() => useKeyPressBindings([\n      { key: 'a', ctrlOrMeta: true, onPress: onPressA },\n      { key: 'Escape', onPress: onPressEscape },\n    ]))\n\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'a', ctrlKey: true }))\n    })\n    expect(onPressA).toHaveBeenCalledTimes(1)\n    expect(onPressEscape).not.toHaveBeenCalled()\n\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape' }))\n    })\n    expect(onPressEscape).toHaveBeenCalledTimes(1)\n  })\n\n  it('respects enabled flag per binding', () => {\n    const onPressDelete = vi.fn()\n    \n    const { rerender } = renderHook(\n      ({ enabled }) => useKeyPressBindings([\n        { key: 'Delete', onPress: onPressDelete, enabled }\n      ]),\n      { initialProps: { enabled: false } }\n    )\n\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Delete' }))\n    })\n    expect(onPressDelete).not.toHaveBeenCalled()\n\n    rerender({ enabled: true })\n    \n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Delete' }))\n    })\n    expect(onPressDelete).toHaveBeenCalledTimes(1)\n  })\n})\n```\n\n### 2. Integration Testing - DocumentLibrary.tsx\n\n1. **Navigate to Document Library** at `/documents`\n2. **Test Ctrl+A (Select All)**:\n   - With documents loaded, press Ctrl+A (Windows) or Cmd+A (Mac)\n   - Verify all documents are selected\n   - Verify browser's native select-all is prevented\n3. **Test Escape (Clear Selection)**:\n   - With documents selected, press Escape\n   - Verify selection is cleared\n   - With document detail panel open, press Escape\n   - Verify detail panel closes first\n4. **Test Delete (Bulk Delete)**:\n   - Select 2+ documents\n   - Press Delete key\n   - Verify delete confirmation appears\n5. **Test Ctrl+F (Focus Search)**:\n   - Press Ctrl+F (Windows) or Cmd+F (Mac)\n   - Verify search input is focused\n   - Verify browser's native find dialog is prevented\n\n### 3. Integration Testing - SearchBar Component\n\n1. **Test Ctrl+K (Focus Search)**:\n   - On any page with SearchBar\n   - Press Ctrl+K (Windows) or Cmd+K (Mac)\n   - Verify search input is focused\n2. **Test Escape (Clear and Blur)**:\n   - Type a search query\n   - Press Escape\n   - Verify input is cleared and blurred\n\n### 4. Memory Leak Verification\n\n1. Navigate between pages multiple times\n2. Check browser DevTools Memory panel for listener leaks\n3. Use React DevTools to verify hooks unmount cleanly\n\n### 5. Regression Testing\n\nRun the existing test suite to ensure no regressions:\n```bash\ncd quikadmin-web && bun run test\n```",
        "status": "cancelled",
        "dependencies": [
          "173"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-01T13:08:47.429Z"
      },
      {
        "id": "178",
        "title": "Refactor Boolean useState Patterns to useToggle Hook Across Codebase",
        "description": "Refactor 25+ boolean useState patterns throughout the frontend codebase to use the foundational useToggle hook from Task 173, reducing boilerplate code and improving consistency in state toggle patterns.",
        "details": "## Implementation Details\n\n### Overview\nThis task systematically replaces manual `useState(false)` / `useState(true)` patterns with the `useToggle` hook created in Task 173. The codebase contains 50+ instances of boolean useState patterns across 25+ files, with priority focus on 4 key files identified with highest impact.\n\n### 1. Priority File Refactors\n\n#### A. autocomplete-field.tsx (Lines 95-99) - 3 booleans\n**Current State:**\n```typescript\nconst [isOpen, setIsOpen] = React.useState(false);\nconst [isLoading, setIsLoading] = React.useState(false);\nconst [isFocused, setIsFocused] = React.useState(false);\n```\n\n**Refactored State:**\n```typescript\nimport { useToggle } from '@/hooks/useToggle';\n\nconst [isOpen, toggleOpen, setIsOpen] = useToggle(false);\nconst [isLoading, toggleLoading, setIsLoading] = useToggle(false);\nconst [isFocused, toggleFocused, setIsFocused] = useToggle(false);\n```\n\n**Usage Updates:**\n- Line 131: `setIsOpen(results.length > 0 && isFocused)` - keep using setIsOpen (conditional)\n- Line 169: `setIsOpen(true)` - keep using setIsOpen\n- Lines 167, 180-181: `setIsFocused(true/false)` - keep using setIsFocused\n- Line 122, 136: `setIsLoading(true/false)` - keep using setIsLoading\n\nNote: This file primarily uses direct set operations rather than toggles, but the hook provides both the setter and toggle function.\n\n#### B. AppLayout.tsx (Lines 144-145) - 2 booleans\n**Current State:**\n```typescript\nconst [sidebarOpen, setSidebarOpen] = React.useState(false);\nconst [sidebarCollapsed, setSidebarCollapsed] = React.useState(false);\n```\n\n**Refactored State:**\n```typescript\nimport { useToggle } from '@/hooks/useToggle';\n\nconst [sidebarOpen, toggleSidebarOpen, setSidebarOpen] = useToggle(false);\nconst [sidebarCollapsed, toggleSidebarCollapsed] = useToggle(false);\n```\n\n**Usage Updates:**\n- Line 148: `setSidebarCollapsed(!sidebarCollapsed)` → `toggleSidebarCollapsed()`\n- Line 76: `setSidebarOpen?.(false)` - keep using setSidebarOpen\n- Line 178, 196: `setSidebarOpen(...)` - keep using setSidebarOpen\n\n#### C. Register.tsx (Lines 40-42) - 3 booleans\n**Current State:**\n```typescript\nconst [showPassword, setShowPassword] = useState(false);\nconst [agreedToTerms, setAgreedToTerms] = useState(false);\nconst [marketingConsent, setMarketingConsent] = useState(false);\n```\n\n**Refactored State:**\n```typescript\nimport { useToggle } from '@/hooks/useToggle';\n\nconst [showPassword, toggleShowPassword] = useToggle(false);\nconst [agreedToTerms, , setAgreedToTerms] = useToggle(false);\nconst [marketingConsent, , setMarketingConsent] = useToggle(false);\n```\n\n**Usage Updates:**\n- Line 232: `setShowPassword(!showPassword)` → `toggleShowPassword()`\n- Lines 297, 315: `setAgreedToTerms/setMarketingConsent(checked as boolean)` - keep using setters\n\n#### D. ResetPassword.tsx (Lines 29-35) - 4 booleans\n**Current State:**\n```typescript\nconst [showPassword, setShowPassword] = useState(false);\nconst [showConfirmPassword, setShowConfirmPassword] = useState(false);\nconst [isLoading, setIsLoading] = useState(false);\nconst [isTokenValid, setIsTokenValid] = useState(true);\nconst [resetSuccess, setResetSuccess] = useState(false);\n```\n\n**Refactored State:**\n```typescript\nimport { useToggle } from '@/hooks/useToggle';\n\nconst [showPassword, toggleShowPassword] = useToggle(false);\nconst [showConfirmPassword, toggleShowConfirmPassword] = useToggle(false);\nconst [isLoading, , setIsLoading] = useToggle(false);\nconst [isTokenValid, , setIsTokenValid] = useToggle(true);\nconst [resetSuccess, , setResetSuccess] = useToggle(false);\n```\n\n**Usage Updates:**\n- Line 234: `setShowPassword(!showPassword)` → `toggleShowPassword()`\n- Line 275: `setShowConfirmPassword(!showConfirmPassword)` → `toggleShowConfirmPassword()`\n\n### 2. Secondary Files to Refactor (Lower Priority)\n\n| File | Booleans | Pattern |\n|------|----------|---------|\n| Login.tsx:35 | `showPassword` | Toggle pattern |\n| ForgotPassword.tsx:14-15 | `isLoading, emailSent` | Mixed setter/toggle |\n| VerifyEmail.tsx:39-42 | `isLoading, success, isResending` | Setter pattern |\n| ProfileDetail.tsx:94 | `isEditing` | Toggle pattern |\n| ProfileList.tsx:259 | `formModalOpen` | Setter pattern |\n| ProfileSettings.tsx:66 | `isAddFieldOpen` | Setter pattern |\n| Templates.tsx:243 | `createDialogOpen` | Setter pattern |\n| History.tsx:71-72 | `loading, statsLoading` | Setter pattern |\n| JobDetails.tsx:50 | `loading` | Setter pattern |\n| SimpleFillForm.tsx:160,165 | `filling, validatingForm` | Setter pattern |\n| FormFillDemo.tsx:73,75 | `isSubmitting, profileLoading` | Setter pattern |\n| bulk-actions-toolbar.tsx:88,201 | `showDeleteDialog` x2 | Setter pattern |\n| demo-login-button.tsx:73 | `isLoading` | Setter pattern |\n| demo-mode-indicator.tsx:65 | `dismissed` | Setter pattern |\n| document-filters.tsx:105 | `open` | Setter pattern |\n| form-preview.tsx:48 | `previewLoading` | Setter pattern |\n| profile-field-editor.tsx:58 | `isEditing` | Toggle pattern |\n| profile-fields-manager.tsx:193,480-481 | `isEditing, hasChanges, addDialogOpen` | Mixed |\n| profile-selector.tsx:118 | `showNoProfilesDialog` | Setter pattern |\n| search-bar.tsx:201 | `showResults` | Setter pattern |\n| template-manager.tsx:50 | `saveDialogOpen` | Setter pattern |\n| SearchInterface.tsx:71,250 | `expanded, showOptions` | Toggle pattern |\n| SuggestionPopover.tsx:204 | `open` | Setter pattern |\n\n### 3. Import Pattern\n\nAdd to hooks barrel export (create `hooks/index.ts` if needed):\n```typescript\n// hooks/index.ts\nexport { useDebouncedValue, useDebouncedCallback } from './useDebounce';\nexport { useToggle } from './useToggle';\n// ... other hooks from Task 173\n```\n\n### 4. Refactoring Guidelines\n\n1. **When to use toggle vs setter:**\n   - Use `toggle()` when the pattern is `setValue(!value)`\n   - Use `setValue()` when setting to a specific value or conditional\n\n2. **Destructuring patterns:**\n   - Full: `const [value, toggle, setValue] = useToggle(false);`\n   - Toggle only: `const [value, toggle] = useToggle(false);`\n   - Setter only: `const [value, , setValue] = useToggle(false);`\n\n3. **Migration order:**\n   - Start with priority files (autocomplete-field, AppLayout, Register, ResetPassword)\n   - Proceed to secondary files alphabetically by directory\n\n### 5. Code Reduction Estimate\n\n- **Before:** ~100 lines of `useState` + inline `!value` toggles\n- **After:** ~50 lines using `useToggle` with semantic toggle functions\n- **Estimated reduction:** 50% boilerplate reduction in toggle patterns",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for Refactored Components\n\nEach refactored component should maintain its existing test coverage. Verify behavior is unchanged:\n\n#### A. autocomplete-field.test.tsx (Existing)\n```typescript\ndescribe('AutocompleteField with useToggle', () => {\n  it('opens dropdown on focus when suggestions exist')\n  it('closes dropdown on blur')\n  it('shows loading indicator during fetch')\n  it('maintains focus state correctly')\n})\n```\n\n#### B. AppLayout Tests\n```typescript\ndescribe('AppLayout with useToggle', () => {\n  it('toggles sidebar collapsed state on button click')\n  it('opens mobile sidebar sheet')\n  it('closes sidebar when navigation link clicked')\n})\n```\n\n#### C. Register Tests\n```typescript\ndescribe('Register with useToggle', () => {\n  it('toggles password visibility')\n  it('maintains terms agreement state through checkbox')\n  it('maintains marketing consent state through checkbox')\n})\n```\n\n#### D. ResetPassword Tests\n```typescript\ndescribe('ResetPassword with useToggle', () => {\n  it('toggles password visibility for password field')\n  it('toggles password visibility for confirm password field')\n  it('sets loading state during submission')\n  it('sets success state after successful reset')\n})\n```\n\n### 2. Manual Testing Checklist\n\n#### Priority Files:\n- [ ] **autocomplete-field.tsx**\n  - [ ] Focus input → dropdown opens when suggestions available\n  - [ ] Blur input → dropdown closes\n  - [ ] Loading spinner appears during API fetch\n  - [ ] Typing triggers suggestion fetch after debounce\n\n- [ ] **AppLayout.tsx**\n  - [ ] Click collapse button → sidebar collapses\n  - [ ] Click expand button → sidebar expands\n  - [ ] Mobile: hamburger menu opens sidebar\n  - [ ] Mobile: clicking nav link closes sidebar\n\n- [ ] **Register.tsx**\n  - [ ] Click eye icon → password becomes visible\n  - [ ] Click eye icon again → password becomes hidden\n  - [ ] Check terms checkbox → enables submit button\n  - [ ] Uncheck terms checkbox → disables submit button\n  - [ ] Marketing checkbox toggles independently\n\n- [ ] **ResetPassword.tsx**\n  - [ ] Toggle password visibility for \"New Password\" field\n  - [ ] Toggle password visibility for \"Confirm Password\" field\n  - [ ] Submit shows loading state\n  - [ ] Success state displays correctly\n\n### 3. Regression Testing\n\nRun existing test suite to verify no regressions:\n```bash\ncd quikadmin-web\nbun run test\n```\n\n### 4. Visual Regression\n\n- [ ] No visual changes in components after refactoring\n- [ ] Animations and transitions work identically\n- [ ] Focus states render correctly\n- [ ] Loading indicators display properly\n\n### 5. Bundle Size Verification\n\nCheck that useToggle hook doesn't significantly increase bundle:\n```bash\ncd quikadmin-web\nbun run build\n# Compare bundle size before/after (should be negligible increase)\n```\n\n### 6. TypeScript Compilation\n\nEnsure all refactored files compile without errors:\n```bash\ncd quikadmin-web\nbun run typecheck\n```\n\n### 7. Integration Test Flow\n\nTest complete user flows that touch refactored components:\n1. **Authentication flow:** Register → Login → Password Reset\n2. **Navigation flow:** Dashboard → Documents → Use sidebar\n3. **Form filling:** Use autocomplete field with suggestions",
        "status": "done",
        "dependencies": [
          "173"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-01T13:24:26.304Z"
      },
      {
        "id": "179",
        "title": "Implement useClickAway Hook for Dropdown/Modal Close-on-Outside-Click Behavior",
        "description": "Apply the existing useOnClickOutside hook from usehooks-ts (already installed and re-exported via @/hooks) to search-bar.tsx (SearchBarWithResults dropdown at lines 206-221) and autocomplete-field.tsx (suggestion list with setTimeout workaround at lines 177-185) to replace manual document.addEventListener patterns and fragile setTimeout workarounds.",
        "status": "in-progress",
        "dependencies": [
          "173"
        ],
        "priority": "medium",
        "details": "## Implementation Details\n\n### Overview\nThe `useOnClickOutside` hook from usehooks-ts is already installed (v3.1.1) and re-exported from `@/hooks/index.ts` (line 43). This task involves applying this hook to two components to replace manual click-outside detection patterns.\n\n**Files to modify:**\n1. `quikadmin-web/src/components/features/search-bar.tsx:206-221` - Manual `document.addEventListener(\"mousedown\", handleClickOutside)` pattern\n2. `quikadmin-web/src/components/features/autocomplete-field.tsx:177-185` - Fragile `setTimeout` blur workaround with 200ms delay\n\n### useOnClickOutside Hook API (from usehooks-ts)\n\n```typescript\nuseOnClickOutside<T extends HTMLElement>(\n  ref: RefObject<T> | RefObject<T>[],\n  handler: (event: MouseEvent | TouchEvent | FocusEvent) => void,\n  eventType?: 'mousedown' | 'mouseup' | 'touchstart' | 'touchend' | 'focusin' | 'focusout',\n  eventListenerOptions?: AddEventListenerOptions\n): void\n```\n\n### 1. Refactor search-bar.tsx (SearchBarWithResults Component)\n\n**File:** `quikadmin-web/src/components/features/search-bar.tsx`\n\n**Current State (Lines 206-221):**\n```typescript\n// Close results when clicking outside\nReact.useEffect(() => {\n  const handleClickOutside = (event: MouseEvent) => {\n    if (\n      searchBarRef.current &&\n      !searchBarRef.current.contains(event.target as Node)\n    ) {\n      setShowResults(false)\n    }\n  }\n\n  if (showResults) {\n    document.addEventListener(\"mousedown\", handleClickOutside)\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside)\n  }\n}, [showResults])\n```\n\n**Refactored State:**\n```typescript\nimport { useOnClickOutside } from \"@/hooks\"\n\n// Inside SearchBarWithResults component (line ~202):\nconst searchBarRef = React.useRef<HTMLDivElement>(null)\n\n// Replace lines 206-221 with a single line:\nuseOnClickOutside(searchBarRef, () => setShowResults(false))\n```\n\n**Note:** The hook internally handles event attachment/cleanup, no need for `enabled` flag - the callback simply won't do anything meaningful when `showResults` is already false.\n\n### 2. Refactor autocomplete-field.tsx\n\n**File:** `quikadmin-web/src/components/features/autocomplete-field.tsx`\n\n**Current State (Lines 177-185):**\n```typescript\nconst handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n  // Delay to allow click events on suggestions\n  setTimeout(() => {\n    setIsFocused(false);\n    setIsOpen(false);\n    setSelectedIndex(-1);\n  }, 200);\n  onBlur?.(e);\n};\n```\n\n**Refactored State:**\n\n1. Add a container ref that wraps the entire component (input + dropdown):\n```typescript\nimport { useOnClickOutside } from \"@/hooks\"\n\n// Add container ref around line 101:\nconst containerRef = React.useRef<HTMLDivElement>(null)\n```\n\n2. Add useOnClickOutside hook (after dropdownRef, around line 105):\n```typescript\n// Handle click outside to close dropdown\nuseOnClickOutside(containerRef, () => {\n  setIsFocused(false)\n  setIsOpen(false)\n  setSelectedIndex(-1)\n})\n```\n\n3. Update handleBlur to remove setTimeout (lines 177-185):\n```typescript\nconst handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n  // Click-away handling is managed by useOnClickOutside hook\n  // Only propagate blur event to parent\n  onBlur?.(e);\n};\n```\n\n4. Wrap the component JSX with containerRef (line 280):\n```diff\n- return (\n-   <div className={cn('relative w-full', containerClassName)}>\n+ return (\n+   <div ref={containerRef} className={cn('relative w-full', containerClassName)}>\n```\n\n### 3. Import Updates\n\nBoth files need to import from `@/hooks`:\n\n**search-bar.tsx (line 11):**\n```diff\n- import { useDebouncedValue } from \"@/hooks/useDebounce\"\n+ import { useDebouncedValue, useOnClickOutside } from \"@/hooks\"\n```\n\n**autocomplete-field.tsx (line 20):**\n```diff\n- import { useDebouncedValue } from '@/hooks/useDebounce';\n+ import { useDebouncedValue, useOnClickOutside } from '@/hooks';\n```\n\n### Key Benefits of This Approach\n\n1. **No custom hook development** - Uses battle-tested usehooks-ts implementation\n2. **Automatic cleanup** - Hook handles event listener cleanup internally\n3. **Touch support** - Hook handles both mouse and touch events by default\n4. **Type safety** - Full TypeScript support from usehooks-ts\n5. **Removes setTimeout hack** - Cleaner, more reliable dropdown closing\n6. **Consistent pattern** - Same approach across both components",
        "testStrategy": "## Test Strategy\n\n### 1. Integration Tests for search-bar.tsx\n\n**File:** `quikadmin-web/src/components/features/__tests__/search-bar.test.tsx`\n\n```typescript\nimport { render, fireEvent, waitFor, screen } from '@testing-library/react'\nimport { describe, it, expect, vi } from 'vitest'\nimport { SearchBarWithResults } from '../search-bar'\n\ndescribe('SearchBarWithResults with useOnClickOutside', () => {\n  it('closes results when clicking outside the search bar', async () => {\n    render(\n      <SearchBarWithResults\n        value=\"test\"\n        onChange={() => {}}\n        results={[{ id: '1', label: 'Result 1' }]}\n      />\n    )\n    \n    // Focus to show results\n    const input = screen.getByRole('searchbox')\n    fireEvent.focus(input)\n    \n    // Results should be visible\n    expect(screen.getByText('Result 1')).toBeInTheDocument()\n    \n    // Click outside\n    fireEvent.mouseDown(document.body)\n    \n    // Results should be hidden\n    await waitFor(() => {\n      expect(screen.queryByText('Result 1')).not.toBeInTheDocument()\n    })\n  })\n\n  it('keeps results open when clicking inside the dropdown', async () => {\n    const onResultSelect = vi.fn()\n    render(\n      <SearchBarWithResults\n        value=\"test\"\n        onChange={() => {}}\n        results={[{ id: '1', label: 'Result 1' }]}\n        onResultSelect={onResultSelect}\n      />\n    )\n    \n    const input = screen.getByRole('searchbox')\n    fireEvent.focus(input)\n    \n    // Click on result - should select it\n    fireEvent.click(screen.getByText('Result 1'))\n    \n    expect(onResultSelect).toHaveBeenCalledWith({ id: '1', label: 'Result 1' })\n  })\n})\n```\n\n### 2. Integration Tests for autocomplete-field.tsx\n\n**File:** `quikadmin-web/src/components/features/__tests__/autocomplete-field.test.tsx`\n\nUpdate existing tests to verify:\n1. Suggestions close immediately on outside click (no 200ms delay)\n2. Suggestions remain open when clicking inside the dropdown\n3. Selecting a suggestion works correctly\n\n### 3. Manual Testing Checklist\n\n#### SearchBarWithResults Component:\n- [ ] Type in search bar, verify results appear\n- [ ] Click outside search bar, verify results close immediately\n- [ ] Click on a result, verify it's selected (not closed prematurely)\n- [ ] Test on mobile with touch events\n\n#### AutocompleteField Component:\n- [ ] Focus input, verify suggestions appear\n- [ ] Click outside input, verify suggestions close immediately (no 200ms delay)\n- [ ] Click on a suggestion, verify it's applied correctly\n- [ ] Use keyboard navigation (arrows + Enter), verify works correctly\n- [ ] Press Escape, verify dropdown closes\n- [ ] Press Tab, verify dropdown closes and focus moves\n\n### 4. Regression Testing\n\nRun existing tests to ensure no regressions:\n```bash\ncd quikadmin-web && bun run test -- --testNamePattern=\"search-bar|autocomplete\"\n```\n\n### 5. Performance Verification\n\nVerify event listeners are properly cleaned up by checking React DevTools and ensuring no memory leaks when components mount/unmount repeatedly.",
        "subtasks": [
          {
            "id": 1,
            "title": "Update search-bar.tsx import to use @/hooks",
            "description": "Update import statement in search-bar.tsx to import useDebouncedValue and useOnClickOutside from @/hooks barrel export",
            "dependencies": [],
            "details": "Change line 11 from:\n```typescript\nimport { useDebouncedValue } from \"@/hooks/useDebounce\"\n```\nto:\n```typescript\nimport { useDebouncedValue, useOnClickOutside } from \"@/hooks\"\n```",
            "status": "pending",
            "testStrategy": "Verify import resolves correctly with TypeScript: `bun run typecheck`",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Replace manual click-outside logic in SearchBarWithResults",
            "description": "Replace the useEffect with document.addEventListener pattern (lines 206-221) with useOnClickOutside hook call",
            "dependencies": [
              1
            ],
            "details": "Replace the entire useEffect block at lines 206-221:\n```typescript\nReact.useEffect(() => {\n  const handleClickOutside = (event: MouseEvent) => { ... }\n  if (showResults) {\n    document.addEventListener(\"mousedown\", handleClickOutside)\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside)\n  }\n}, [showResults])\n```\nWith:\n```typescript\nuseOnClickOutside(searchBarRef, () => setShowResults(false))\n```",
            "status": "pending",
            "testStrategy": "Test click outside behavior works: focus search, click outside, verify dropdown closes",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update autocomplete-field.tsx import to use @/hooks",
            "description": "Update import statement in autocomplete-field.tsx to import useDebouncedValue and useOnClickOutside from @/hooks barrel export",
            "dependencies": [],
            "details": "Change line 20 from:\n```typescript\nimport { useDebouncedValue } from '@/hooks/useDebounce';\n```\nto:\n```typescript\nimport { useDebouncedValue, useOnClickOutside } from '@/hooks';\n```",
            "status": "pending",
            "testStrategy": "Verify import resolves correctly with TypeScript: `bun run typecheck`",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add containerRef to AutocompleteField component",
            "description": "Add a container ref that wraps the entire AutocompleteField component (input + dropdown) to enable click-outside detection",
            "dependencies": [
              3
            ],
            "details": "1. Add containerRef around line 101 (after dropdownRef):\n```typescript\nconst containerRef = React.useRef<HTMLDivElement>(null)\n```\n\n2. Apply containerRef to the outer div in the return statement (line 280):\n```diff\n- return (\n-   <div className={cn('relative w-full', containerClassName)}>\n+ return (\n+   <div ref={containerRef} className={cn('relative w-full', containerClassName)}>\n```",
            "status": "pending",
            "testStrategy": "Verify component renders correctly with ref applied",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add useOnClickOutside hook to AutocompleteField",
            "description": "Add useOnClickOutside hook call to handle click-outside behavior for closing the suggestion dropdown",
            "dependencies": [
              4
            ],
            "details": "Add the hook call after containerRef definition (around line 103):\n```typescript\n// Handle click outside to close dropdown\nuseOnClickOutside(containerRef, () => {\n  setIsFocused(false)\n  setIsOpen(false)\n  setSelectedIndex(-1)\n})\n```",
            "status": "pending",
            "testStrategy": "Test that clicking outside the autocomplete field closes the dropdown immediately",
            "parentId": "undefined"
          },
          {
            "id": 6,
            "title": "Remove setTimeout workaround from handleBlur",
            "description": "Simplify handleBlur function by removing the setTimeout delay now that useOnClickOutside handles click-outside behavior",
            "dependencies": [
              5
            ],
            "details": "Replace lines 177-185:\n```typescript\nconst handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n  // Delay to allow click events on suggestions\n  setTimeout(() => {\n    setIsFocused(false);\n    setIsOpen(false);\n    setSelectedIndex(-1);\n  }, 200);\n  onBlur?.(e);\n};\n```\nWith:\n```typescript\nconst handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n  // Click-away handling is managed by useOnClickOutside hook\n  onBlur?.(e);\n};\n```",
            "status": "pending",
            "testStrategy": "Verify suggestion selection works correctly without 200ms delay race condition",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Run tests and typecheck to verify changes",
            "description": "Run full test suite and typecheck to ensure refactoring hasn't introduced any regressions",
            "dependencies": [
              2,
              6
            ],
            "details": "Execute:\n```bash\ncd quikadmin-web\nbun run typecheck\nbun run test -- --testNamePattern=\"search|autocomplete\"\n```\nVerify all tests pass and there are no type errors.",
            "status": "pending",
            "testStrategy": "All existing tests should pass, no new type errors introduced",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-01T16:31:54.455Z"
      },
      {
        "id": "180",
        "title": "Refactor Auth Redirect Timeouts to useTimeout Hook",
        "description": "Refactor setTimeout/clearTimeout patterns in ResetPassword.tsx, AuthCallback.tsx, and VerifyEmail.tsx to use the useTimeout hook from Task 173, providing automatic cleanup on unmount and preventing memory leaks in auth redirect flows.",
        "details": "## Implementation Details\n\n### Overview\nThis task replaces manual setTimeout/clearTimeout patterns in 3 auth-related pages with the `useTimeout` hook created in Task 173. The current implementations have potential memory leaks if components unmount before the timeout completes, and the code is verbose with manual cleanup.\n\n### 1. Target Files and Current Patterns\n\n#### A. ResetPassword.tsx (Lines 125-129)\n**Current State:**\n```typescript\n// Lines 125-129 - redirect delay after successful password reset\nsetTimeout(() => {\n  navigate('/login', {\n    state: { message: 'Password reset successful. Please log in with your new password.' },\n  });\n}, 3000);\n```\n**Problem:** No cleanup on unmount - if user navigates away before 3s, the timeout still fires.\n\n#### B. AuthCallback.tsx (Lines 56-72)\n**Current State:**\n```typescript\nuseEffect(() => {\n  if (status === 'success') {\n    const type = searchParams.get('type');\n    const timer = setTimeout(() => {\n      if (type === 'signup') {\n        navigate('/login', { state: { message: 'Email verified! You can now log in.' } });\n      } else if (type === 'recovery') {\n        navigate('/reset-password');\n      } else {\n        navigate('/dashboard');\n      }\n    }, 3000);\n    return () => clearTimeout(timer);\n  }\n}, [status, navigate, searchParams]);\n```\n**Problem:** Already has cleanup, but can be simplified with useTimeout hook.\n\n#### C. VerifyEmail.tsx (Lines 72-78)\n**Current State:**\n```typescript\n// Redirect to login after 2 seconds\nsetTimeout(() => {\n  navigate('/login', {\n    state: { message: 'Email verified! You can now log in.' },\n  });\n}, 2000);\n```\n**Problem:** No cleanup on unmount - if user navigates away before 2s, the timeout still fires.\n\n### 2. Refactored Implementation\n\n#### A. ResetPassword.tsx Refactor\n```typescript\nimport { useTimeout } from '@/hooks/useTimeout';\n\n// Inside component, after setResetSuccess(true):\nconst { start: startRedirect } = useTimeout(() => {\n  navigate('/login', {\n    state: { message: 'Password reset successful. Please log in with your new password.' },\n  });\n}, 3000);\n\n// In handleSubmit after setResetSuccess(true):\nstartRedirect();\n```\n\n**Or using immediate flag if hook supports it:**\n```typescript\n// Auto-start when resetSuccess becomes true\nuseTimeout(() => {\n  navigate('/login', {\n    state: { message: 'Password reset successful. Please log in with your new password.' },\n  });\n}, resetSuccess ? 3000 : null);\n```\n\n#### B. AuthCallback.tsx Refactor\n```typescript\nimport { useTimeout } from '@/hooks/useTimeout';\n\n// Replace the useEffect with:\nuseTimeout(() => {\n  const type = searchParams.get('type');\n  if (type === 'signup') {\n    navigate('/login', { state: { message: 'Email verified! You can now log in.' } });\n  } else if (type === 'recovery') {\n    navigate('/reset-password');\n  } else {\n    navigate('/dashboard');\n  }\n}, status === 'success' ? 3000 : null);\n```\n\n#### C. VerifyEmail.tsx Refactor\n```typescript\nimport { useTimeout } from '@/hooks/useTimeout';\n\n// Replace setTimeout with:\nuseTimeout(() => {\n  navigate('/login', {\n    state: { message: 'Email verified! You can now log in.' },\n  });\n}, success ? 2000 : null);\n```\n\n### 3. useTimeout Hook API (from Task 173)\nThe hook should provide:\n```typescript\n/**\n * useTimeout Hook\n * \n * @param callback - Function to execute after delay\n * @param delay - Delay in ms, or null to disable\n * @returns { start, clear, reset } control functions\n */\nfunction useTimeout(\n  callback: () => void,\n  delay: number | null\n): {\n  start: () => void;\n  clear: () => void;\n  reset: () => void;\n};\n```\n\n### 4. Implementation Steps\n\n1. **Verify useTimeout hook exists** from Task 173 in `quikadmin-web/src/hooks/useTimeout.ts`\n2. **Ensure index.ts export** includes useTimeout in barrel export\n3. **Refactor ResetPassword.tsx:**\n   - Import useTimeout from '@/hooks'\n   - Replace setTimeout call on line 125-129 with useTimeout\n   - Remove manual cleanup (none exists, which is the bug)\n4. **Refactor AuthCallback.tsx:**\n   - Import useTimeout from '@/hooks'\n   - Replace entire useEffect block (lines 56-72) with single useTimeout call\n   - Simplify conditional logic\n5. **Refactor VerifyEmail.tsx:**\n   - Import useTimeout from '@/hooks'\n   - Replace setTimeout call on lines 72-78 with useTimeout\n   - Remove manual cleanup (none exists, which is the bug)\n\n### 5. Edge Cases to Handle\n\n- **Conditional delays**: Use `delay: null` pattern to disable timeout when condition not met\n- **Callback dependencies**: Ensure navigate callback is properly memoized if needed\n- **State changes during timeout**: Hook should handle state updates safely\n- **Rapid status changes**: Clear previous timeout before starting new one\n\n### 6. Code Quality Improvements\n\nAfter refactoring, each file will have:\n- No more raw `setTimeout` calls\n- Automatic cleanup on unmount (memory leak prevention)\n- Cleaner, more declarative code\n- Consistent timeout pattern across auth flows",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useTimeout Integration\n\nVerify the hook is properly integrated in each refactored component:\n\n#### A. ResetPassword.test.tsx\n```typescript\nimport { render, screen, waitFor, act } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport userEvent from '@testing-library/user-event'\nimport { MemoryRouter } from 'react-router-dom'\nimport ResetPassword from '../ResetPassword'\n\n// Mock navigate\nconst mockNavigate = vi.fn()\nvi.mock('react-router-dom', async () => {\n  const actual = await vi.importActual('react-router-dom')\n  return { ...actual, useNavigate: () => mockNavigate }\n})\n\ndescribe('ResetPassword redirect timeout', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n    mockNavigate.mockClear()\n  })\n  \n  afterEach(() => {\n    vi.useRealTimers()\n  })\n\n  it('redirects to login after 3 seconds on success', async () => {\n    // Setup successful password reset scenario\n    render(<MemoryRouter><ResetPassword /></MemoryRouter>)\n    \n    // Trigger successful reset (mock API response)\n    // ...\n    \n    // Advance timer\n    act(() => vi.advanceTimersByTime(3000))\n    \n    expect(mockNavigate).toHaveBeenCalledWith('/login', {\n      state: { message: 'Password reset successful. Please log in with your new password.' }\n    })\n  })\n\n  it('does NOT navigate if component unmounts before timeout', async () => {\n    const { unmount } = render(<MemoryRouter><ResetPassword /></MemoryRouter>)\n    \n    // Trigger successful reset\n    // ...\n    \n    // Unmount before timeout\n    unmount()\n    \n    // Advance timer\n    act(() => vi.advanceTimersByTime(3000))\n    \n    // Should NOT have navigated (cleanup worked)\n    expect(mockNavigate).not.toHaveBeenCalled()\n  })\n})\n```\n\n#### B. AuthCallback.test.tsx\n```typescript\ndescribe('AuthCallback redirect timeout', () => {\n  it('redirects to login after 3 seconds for signup type', async () => {\n    render(\n      <MemoryRouter initialEntries={['/auth/callback?type=signup']}>\n        <AuthCallback />\n      </MemoryRouter>\n    )\n    \n    act(() => vi.advanceTimersByTime(3000))\n    \n    expect(mockNavigate).toHaveBeenCalledWith('/login', {\n      state: { message: 'Email verified! You can now log in.' }\n    })\n  })\n\n  it('redirects to reset-password for recovery type', async () => {\n    render(\n      <MemoryRouter initialEntries={['/auth/callback?type=recovery']}>\n        <AuthCallback />\n      </MemoryRouter>\n    )\n    \n    act(() => vi.advanceTimersByTime(3000))\n    \n    expect(mockNavigate).toHaveBeenCalledWith('/reset-password')\n  })\n\n  it('redirects to dashboard for other success types', async () => {\n    render(\n      <MemoryRouter initialEntries={['/auth/callback?type=magiclink']}>\n        <AuthCallback />\n      </MemoryRouter>\n    )\n    \n    act(() => vi.advanceTimersByTime(3000))\n    \n    expect(mockNavigate).toHaveBeenCalledWith('/dashboard')\n  })\n\n  it('does NOT redirect when status is error', async () => {\n    render(\n      <MemoryRouter initialEntries={['/auth/callback?error=access_denied']}>\n        <AuthCallback />\n      </MemoryRouter>\n    )\n    \n    act(() => vi.advanceTimersByTime(5000))\n    \n    expect(mockNavigate).not.toHaveBeenCalled()\n  })\n\n  it('cleans up timeout on unmount', async () => {\n    const { unmount } = render(\n      <MemoryRouter initialEntries={['/auth/callback?type=signup']}>\n        <AuthCallback />\n      </MemoryRouter>\n    )\n    \n    unmount()\n    act(() => vi.advanceTimersByTime(3000))\n    \n    expect(mockNavigate).not.toHaveBeenCalled()\n  })\n})\n```\n\n#### C. VerifyEmail.test.tsx\n```typescript\ndescribe('VerifyEmail redirect timeout', () => {\n  it('redirects to login after 2 seconds on successful verification', async () => {\n    // Mock successful verification API response\n    // ...\n    \n    render(<MemoryRouter><VerifyEmail /></MemoryRouter>)\n    \n    // Trigger successful verification\n    // ...\n    \n    act(() => vi.advanceTimersByTime(2000))\n    \n    expect(mockNavigate).toHaveBeenCalledWith('/login', {\n      state: { message: 'Email verified! You can now log in.' }\n    })\n  })\n\n  it('does NOT navigate if component unmounts before timeout', async () => {\n    const { unmount } = render(<MemoryRouter><VerifyEmail /></MemoryRouter>)\n    \n    // Trigger successful verification\n    // ...\n    \n    unmount()\n    act(() => vi.advanceTimersByTime(2000))\n    \n    expect(mockNavigate).not.toHaveBeenCalled()\n  })\n})\n```\n\n### 2. Manual Testing Checklist\n\n#### ResetPassword Flow\n1. Navigate to `/reset-password?token=valid_token`\n2. Enter valid matching passwords\n3. Submit form successfully\n4. Verify success message appears\n5. Wait 3 seconds - should redirect to `/login`\n6. Verify login page shows success state message\n\n#### AuthCallback Flow\n1. Test signup confirmation: Navigate to `/auth/callback?type=signup`\n2. Verify redirects to `/login` after 3 seconds\n3. Test recovery: Navigate to `/auth/callback?type=recovery`\n4. Verify redirects to `/reset-password` after 3 seconds\n5. Test error state: Navigate to `/auth/callback?error=access_denied`\n6. Verify NO automatic redirect occurs\n\n#### VerifyEmail Flow\n1. Navigate to `/verify-email?email=test@example.com`\n2. Enter valid 6-digit code\n3. Submit and receive success response\n4. Verify success message appears\n5. Wait 2 seconds - should redirect to `/login`\n\n### 3. Memory Leak Prevention Verification\n\n```typescript\ndescribe('Memory leak prevention', () => {\n  it('ResetPassword: no memory leak on rapid navigation', () => {\n    const { unmount, rerender } = render(<MemoryRouter><ResetPassword /></MemoryRouter>)\n    \n    // Trigger multiple successful resets rapidly\n    // Each should cancel previous timeout\n    // ...\n    \n    unmount()\n    \n    // No warnings about state updates on unmounted component\n    // No uncaught promise rejections\n  })\n})\n```\n\n### 4. Integration Test\n\n```typescript\ndescribe('Auth flow integration', () => {\n  it('complete password reset flow with redirect', async () => {\n    // 1. Start at reset password page\n    // 2. Enter new password\n    // 3. Submit successfully\n    // 4. See success state\n    // 5. Wait for redirect\n    // 6. Arrive at login page with correct state\n  })\n})\n```\n\n### 5. Typecheck Verification\n```bash\ncd quikadmin-web && bun run typecheck\n```\nEnsure no TypeScript errors after refactoring.",
        "status": "pending",
        "dependencies": [
          "173"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "181",
        "title": "Add useMediaQuery Hook with Live Listener to Theme Provider",
        "description": "Create a useMediaQuery hook with live event listeners for OS theme changes and integrate it into theme-provider.tsx to automatically update the app theme when users change their system preferences (dark/light mode), replacing the current one-time matchMedia check at line 39.",
        "details": "## Implementation Details\n\n### Overview\nThe current `theme-provider.tsx:39` implementation only checks the OS dark mode preference once during initial render. When users change their system preferences (e.g., macOS \"Auto\" mode switching at sunset), the app theme doesn't update until a page refresh. This is a critical UX issue for users who rely on system-level theme management.\n\n### 1. Create useMediaQuery Hook (`quikadmin-web/src/hooks/useMediaQuery.ts`)\n\n```typescript\n/**\n * Media query hook with live listener for responsive design\n * @module hooks/useMediaQuery\n */\n\nimport * as React from 'react'\n\n/**\n * Subscribe to a media query and receive live updates\n *\n * @param query - CSS media query string (e.g., \"(prefers-color-scheme: dark)\")\n * @returns Boolean indicating if the query matches\n *\n * @example\n * ```tsx\n * const isDarkMode = useMediaQuery(\"(prefers-color-scheme: dark)\")\n * const isMobile = useMediaQuery(\"(max-width: 768px)\")\n * const prefersReducedMotion = useMediaQuery(\"(prefers-reduced-motion: reduce)\")\n * ```\n */\nexport function useMediaQuery(query: string): boolean {\n  // Initialize with server-safe default, then hydrate on mount\n  const [matches, setMatches] = React.useState<boolean>(() => {\n    // SSR safety: return false during server-side rendering\n    if (typeof window === 'undefined') {\n      return false\n    }\n    return window.matchMedia(query).matches\n  })\n\n  React.useEffect(() => {\n    // Bail out on SSR\n    if (typeof window === 'undefined') {\n      return\n    }\n\n    const mediaQueryList = window.matchMedia(query)\n    \n    // Update state when media query changes\n    const handleChange = (event: MediaQueryListEvent) => {\n      setMatches(event.matches)\n    }\n\n    // Set initial value (handles hydration mismatch)\n    setMatches(mediaQueryList.matches)\n\n    // Modern API: addEventListener (Chrome 103+, Firefox 106+, Safari 14+)\n    // Fallback: addListener for older browsers\n    if (mediaQueryList.addEventListener) {\n      mediaQueryList.addEventListener('change', handleChange)\n    } else {\n      // Deprecated but needed for Safari < 14\n      mediaQueryList.addListener(handleChange)\n    }\n\n    // Cleanup listener on unmount or query change\n    return () => {\n      if (mediaQueryList.removeEventListener) {\n        mediaQueryList.removeEventListener('change', handleChange)\n      } else {\n        mediaQueryList.removeListener(handleChange)\n      }\n    }\n  }, [query])\n\n  return matches\n}\n\n/**\n * Pre-defined media query for dark mode preference\n * @returns Boolean indicating if user prefers dark mode\n */\nexport function usePrefersDarkMode(): boolean {\n  return useMediaQuery('(prefers-color-scheme: dark)')\n}\n\n/**\n * Pre-defined media query for reduced motion preference\n * @returns Boolean indicating if user prefers reduced motion\n */\nexport function usePrefersReducedMotion(): boolean {\n  return useMediaQuery('(prefers-reduced-motion: reduce)')\n}\n```\n\n### 2. Refactor theme-provider.tsx (Lines 33-49)\n\n**Current Implementation (Lines 33-49):**\n```typescript\nuseEffect(() => {\n  const root = window.document.documentElement\n\n  root.classList.remove(\"light\", \"dark\")\n\n  if (theme === \"system\") {\n    const systemTheme = window.matchMedia(\"(prefers-color-scheme: dark)\")\n      .matches\n      ? \"dark\"\n      : \"light\"\n\n    root.classList.add(systemTheme)\n    return\n  }\n\n  root.classList.add(theme)\n}, [theme])\n```\n\n**Refactored Implementation:**\n```typescript\nimport { useMediaQuery } from \"@/hooks/useMediaQuery\"\n\n// ... inside ThemeProvider component\n\n// Subscribe to OS dark mode preference with live updates\nconst prefersDarkMode = useMediaQuery(\"(prefers-color-scheme: dark)\")\n\n// Compute the resolved theme (what actually gets applied)\nconst resolvedTheme = React.useMemo(() => {\n  if (theme === \"system\") {\n    return prefersDarkMode ? \"dark\" : \"light\"\n  }\n  return theme\n}, [theme, prefersDarkMode])\n\n// Apply theme class to document root\nuseEffect(() => {\n  const root = window.document.documentElement\n  root.classList.remove(\"light\", \"dark\")\n  root.classList.add(resolvedTheme)\n}, [resolvedTheme])\n```\n\n### 3. Enhanced ThemeProviderState Type\n\nOptionally expose the resolved theme for components that need to know the actual applied theme:\n\n```typescript\ntype ThemeProviderState = {\n  theme: Theme                    // User's choice: \"dark\" | \"light\" | \"system\"\n  resolvedTheme: \"dark\" | \"light\" // Actual applied theme\n  setTheme: (theme: Theme) => void\n}\n```\n\n### 4. Export Hook from Barrel File\n\nIf `quikadmin-web/src/hooks/index.ts` exists, add:\n```typescript\nexport { useMediaQuery, usePrefersDarkMode, usePrefersReducedMotion } from './useMediaQuery'\n```\n\n### Key Considerations\n\n1. **SSR Safety**: The hook handles server-side rendering by returning `false` when `window` is undefined\n2. **Hydration Mismatch**: Initial state is set synchronously, then confirmed in useEffect to handle any hydration edge cases\n3. **Browser Compatibility**: Supports both modern `addEventListener` API and deprecated `addListener` for Safari < 14\n4. **Memory Leak Prevention**: Proper cleanup of event listeners on unmount and query changes\n5. **Performance**: Uses `useMemo` to compute resolved theme only when dependencies change\n\n### Additional Usage Opportunities\n\nThe `useMediaQuery` hook can be reused throughout the codebase:\n- Mobile-responsive layouts: `useMediaQuery(\"(max-width: 768px)\")`\n- Accessibility: `usePrefersReducedMotion()` for animation controls\n- Print styles: `useMediaQuery(\"print\")`",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useMediaQuery (`quikadmin-web/src/hooks/__tests__/useMediaQuery.test.tsx`)\n\n```typescript\nimport { renderHook, act } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { useMediaQuery, usePrefersDarkMode, usePrefersReducedMotion } from '../useMediaQuery'\n\ndescribe('useMediaQuery', () => {\n  let matchMediaMock: ReturnType<typeof vi.fn>\n  let listeners: Map<string, (e: MediaQueryListEvent) => void>\n\n  beforeEach(() => {\n    listeners = new Map()\n    matchMediaMock = vi.fn().mockImplementation((query: string) => ({\n      matches: false,\n      media: query,\n      onchange: null,\n      addEventListener: vi.fn((event: string, cb: (e: MediaQueryListEvent) => void) => {\n        if (event === 'change') listeners.set(query, cb)\n      }),\n      removeEventListener: vi.fn((event: string) => {\n        if (event === 'change') listeners.delete(query)\n      }),\n      addListener: vi.fn(),\n      removeListener: vi.fn(),\n      dispatchEvent: vi.fn(),\n    }))\n    Object.defineProperty(window, 'matchMedia', {\n      writable: true,\n      value: matchMediaMock,\n    })\n  })\n\n  afterEach(() => {\n    listeners.clear()\n    vi.clearAllMocks()\n  })\n\n  it('returns initial match state', () => {\n    matchMediaMock.mockImplementation((query: string) => ({\n      matches: true,\n      media: query,\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n    }))\n\n    const { result } = renderHook(() => useMediaQuery('(prefers-color-scheme: dark)'))\n    expect(result.current).toBe(true)\n  })\n\n  it('returns false when query does not match', () => {\n    const { result } = renderHook(() => useMediaQuery('(prefers-color-scheme: dark)'))\n    expect(result.current).toBe(false)\n  })\n\n  it('updates when media query changes', () => {\n    const { result } = renderHook(() => useMediaQuery('(prefers-color-scheme: dark)'))\n    expect(result.current).toBe(false)\n\n    // Simulate OS theme change\n    act(() => {\n      const listener = listeners.get('(prefers-color-scheme: dark)')\n      listener?.({ matches: true } as MediaQueryListEvent)\n    })\n\n    expect(result.current).toBe(true)\n  })\n\n  it('cleans up listener on unmount', () => {\n    const removeListenerMock = vi.fn()\n    matchMediaMock.mockImplementation(() => ({\n      matches: false,\n      addEventListener: vi.fn(),\n      removeEventListener: removeListenerMock,\n    }))\n\n    const { unmount } = renderHook(() => useMediaQuery('(prefers-color-scheme: dark)'))\n    unmount()\n\n    expect(removeListenerMock).toHaveBeenCalledWith('change', expect.any(Function))\n  })\n\n  it('handles query string changes', () => {\n    const { result, rerender } = renderHook(\n      ({ query }) => useMediaQuery(query),\n      { initialProps: { query: '(max-width: 768px)' } }\n    )\n\n    expect(matchMediaMock).toHaveBeenCalledWith('(max-width: 768px)')\n\n    rerender({ query: '(max-width: 1024px)' })\n    expect(matchMediaMock).toHaveBeenCalledWith('(max-width: 1024px)')\n  })\n})\n\ndescribe('usePrefersDarkMode', () => {\n  it('returns true when dark mode is preferred', () => {\n    Object.defineProperty(window, 'matchMedia', {\n      writable: true,\n      value: vi.fn().mockImplementation(() => ({\n        matches: true,\n        addEventListener: vi.fn(),\n        removeEventListener: vi.fn(),\n      })),\n    })\n\n    const { result } = renderHook(() => usePrefersDarkMode())\n    expect(result.current).toBe(true)\n  })\n})\n\ndescribe('usePrefersReducedMotion', () => {\n  it('returns true when reduced motion is preferred', () => {\n    Object.defineProperty(window, 'matchMedia', {\n      writable: true,\n      value: vi.fn().mockImplementation(() => ({\n        matches: true,\n        addEventListener: vi.fn(),\n        removeEventListener: vi.fn(),\n      })),\n    })\n\n    const { result } = renderHook(() => usePrefersReducedMotion())\n    expect(result.current).toBe(true)\n  })\n})\n```\n\n### 2. Integration Tests for ThemeProvider (`quikadmin-web/src/components/__tests__/theme-provider.test.tsx`)\n\n```typescript\nimport { render, screen, act } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { ThemeProvider, useTheme } from '../theme-provider'\n\ndescribe('ThemeProvider with live theme updates', () => {\n  let matchMediaListeners: Map<string, (e: MediaQueryListEvent) => void>\n\n  beforeEach(() => {\n    matchMediaListeners = new Map()\n    Object.defineProperty(window, 'matchMedia', {\n      writable: true,\n      value: vi.fn().mockImplementation((query: string) => ({\n        matches: query.includes('dark') ? false : true,\n        media: query,\n        addEventListener: vi.fn((event, cb) => {\n          if (event === 'change') matchMediaListeners.set(query, cb)\n        }),\n        removeEventListener: vi.fn(),\n      })),\n    })\n    document.documentElement.className = ''\n    localStorage.clear()\n  })\n\n  it('applies system theme and updates on OS change', () => {\n    const TestComponent = () => {\n      const { theme } = useTheme()\n      return <div data-testid=\"theme\">{theme}</div>\n    }\n\n    render(\n      <ThemeProvider defaultTheme=\"system\">\n        <TestComponent />\n      </ThemeProvider>\n    )\n\n    // Initially light mode\n    expect(document.documentElement.classList.contains('light')).toBe(true)\n\n    // Simulate OS switching to dark mode\n    act(() => {\n      const listener = matchMediaListeners.get('(prefers-color-scheme: dark)')\n      listener?.({ matches: true } as MediaQueryListEvent)\n    })\n\n    expect(document.documentElement.classList.contains('dark')).toBe(true)\n    expect(document.documentElement.classList.contains('light')).toBe(false)\n  })\n\n  it('does not respond to OS changes when explicit theme is set', () => {\n    render(\n      <ThemeProvider defaultTheme=\"light\">\n        <div>Test</div>\n      </ThemeProvider>\n    )\n\n    expect(document.documentElement.classList.contains('light')).toBe(true)\n\n    // Simulate OS switching to dark mode - should have no effect\n    act(() => {\n      const listener = matchMediaListeners.get('(prefers-color-scheme: dark)')\n      listener?.({ matches: true } as MediaQueryListEvent)\n    })\n\n    // Should remain light because explicit theme was set\n    expect(document.documentElement.classList.contains('light')).toBe(true)\n  })\n})\n```\n\n### 3. Manual Testing Checklist\n\n1. **macOS Auto Theme Testing**:\n   - Set macOS to \"Auto\" appearance in System Preferences\n   - Open app with theme set to \"System\"\n   - Manually change system time or wait for sunset/sunrise transition\n   - Verify app theme changes without page refresh\n\n2. **Windows Testing**:\n   - Open Settings > Personalization > Colors\n   - Toggle between Light and Dark modes\n   - Verify app immediately reflects the change\n\n3. **Browser DevTools Testing**:\n   - Open Chrome DevTools > Rendering panel\n   - Toggle \"Emulate CSS media feature prefers-color-scheme\"\n   - Verify app responds instantly to each change\n\n4. **Edge Cases**:\n   - Rapidly toggle OS theme multiple times\n   - Switch between explicit theme and \"System\"\n   - Verify no memory leaks (check for listener buildup)\n\n### 4. Update Test Setup Mock\n\nUpdate `quikadmin-web/src/test/setup.tsx` to support listener testing:\n\n```typescript\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: vi.fn().mockImplementation((query) => {\n    const listeners: ((e: MediaQueryListEvent) => void)[] = []\n    return {\n      matches: false,\n      media: query,\n      onchange: null,\n      addListener: vi.fn((cb) => listeners.push(cb)),\n      removeListener: vi.fn((cb) => {\n        const idx = listeners.indexOf(cb)\n        if (idx > -1) listeners.splice(idx, 1)\n      }),\n      addEventListener: vi.fn((event, cb) => {\n        if (event === 'change') listeners.push(cb)\n      }),\n      removeEventListener: vi.fn((event, cb) => {\n        if (event === 'change') {\n          const idx = listeners.indexOf(cb)\n          if (idx > -1) listeners.splice(idx, 1)\n        }\n      }),\n      dispatchEvent: vi.fn((event) => {\n        listeners.forEach(cb => cb(event))\n      }),\n    }\n  }),\n})\n```",
        "status": "done",
        "dependencies": [
          "173"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-01T15:06:17.375Z"
      },
      {
        "id": "182",
        "title": "Implement Virtual Scrolling for DataTable with useIntersectionObserver",
        "description": "Add virtual scrolling to DataTable component (data-table.tsx:342-429) to render only visible rows plus a buffer zone, replacing the current O(n×m) rendering pattern that causes 500ms+ render times on 50+ rows. Leverages useIntersectionObserver from Task 174 for visibility detection.",
        "details": "## Implementation Details\n\n### Overview\nThe current DataTable implementation in `quikadmin-web/src/components/features/data-table.tsx` renders all rows at once (lines 342-429 for desktop, 386-429 for mobile). With 50+ rows and multiple columns, this creates O(n×m) render complexity causing 500ms+ delays. Virtual scrolling will render only visible rows + buffer, achieving 300%+ performance improvement.\n\n### 1. Install @tanstack/react-virtual\n\n```bash\ncd quikadmin-web && bun add @tanstack/react-virtual\n```\n\nThis library is already recommended in `docs/guides/performance/README.md:47-49` and provides a production-ready virtualizer.\n\n### 2. Create useVirtualTable Hook (`quikadmin-web/src/hooks/useVirtualTable.ts`)\n\n```typescript\n/**\n * Virtual table hook for efficient rendering of large datasets\n * @module hooks/useVirtualTable\n */\n\nimport * as React from 'react'\nimport { useVirtualizer, VirtualItem } from '@tanstack/react-virtual'\n\nexport interface UseVirtualTableOptions<T> {\n  /** Data rows to virtualize */\n  data: T[]\n  /** Estimated row height in pixels (default: 48) */\n  estimatedRowHeight?: number\n  /** Number of rows to render outside viewport (default: 5) */\n  overscan?: number\n  /** Enable virtualization only when row count exceeds threshold (default: 30) */\n  virtualizeThreshold?: number\n  /** Container height for virtualization (default: 400) */\n  containerHeight?: number\n}\n\nexport interface UseVirtualTableReturn<T> {\n  /** Container ref to attach to scrollable element */\n  containerRef: React.RefObject<HTMLDivElement>\n  /** Virtual items to render */\n  virtualItems: VirtualItem[]\n  /** Total height for the virtualized container */\n  totalHeight: number\n  /** Whether virtualization is active */\n  isVirtualized: boolean\n  /** Get row data for a virtual item */\n  getRowData: (virtualItem: VirtualItem) => T\n  /** Visible rows (for non-virtualized rendering) */\n  visibleData: T[]\n}\n\nexport function useVirtualTable<T>({\n  data,\n  estimatedRowHeight = 48,\n  overscan = 5,\n  virtualizeThreshold = 30,\n  containerHeight = 400,\n}: UseVirtualTableOptions<T>): UseVirtualTableReturn<T> {\n  const containerRef = React.useRef<HTMLDivElement>(null)\n  \n  const isVirtualized = data.length > virtualizeThreshold\n  \n  const virtualizer = useVirtualizer({\n    count: isVirtualized ? data.length : 0,\n    getScrollElement: () => containerRef.current,\n    estimateSize: () => estimatedRowHeight,\n    overscan,\n    enabled: isVirtualized,\n  })\n  \n  const virtualItems = virtualizer.getVirtualItems()\n  const totalHeight = virtualizer.getTotalSize()\n  \n  const getRowData = React.useCallback(\n    (virtualItem: VirtualItem): T => data[virtualItem.index],\n    [data]\n  )\n  \n  return {\n    containerRef,\n    virtualItems,\n    totalHeight,\n    isVirtualized,\n    getRowData,\n    visibleData: isVirtualized ? [] : data,\n  }\n}\n```\n\n### 3. Create VirtualTableBody Component (`quikadmin-web/src/components/features/virtual-table-body.tsx`)\n\n```typescript\n/**\n * Virtual table body component for efficient row rendering\n */\n\nimport * as React from 'react'\nimport { VirtualItem } from '@tanstack/react-virtual'\nimport { TableBody, TableRow, TableCell } from '@/components/ui/table'\nimport { Checkbox } from '@/components/ui/checkbox'\nimport { cn } from '@/lib/utils'\nimport type { Column } from './data-table'\n\ninterface VirtualTableBodyProps<T extends Record<string, unknown>> {\n  virtualItems: VirtualItem[]\n  totalHeight: number\n  getRowData: (virtualItem: VirtualItem) => T\n  columns: Column<T>[]\n  selectable?: boolean\n  selected: string[]\n  getRowId: (row: T) => string\n  onRowClick?: (row: T) => void\n  onRowSelect: (rowId: string, checked: boolean) => void\n}\n\nexport function VirtualTableBody<T extends Record<string, unknown>>({\n  virtualItems,\n  totalHeight,\n  getRowData,\n  columns,\n  selectable,\n  selected,\n  getRowId,\n  onRowClick,\n  onRowSelect,\n}: VirtualTableBodyProps<T>) {\n  return (\n    <TableBody\n      style={{\n        height: `${totalHeight}px`,\n        position: 'relative',\n      }}\n    >\n      {virtualItems.map((virtualItem) => {\n        const row = getRowData(virtualItem)\n        const rowId = getRowId(row)\n        const isSelected = selected.includes(rowId)\n        \n        return (\n          <TableRow\n            key={virtualItem.key}\n            data-index={virtualItem.index}\n            onClick={() => onRowClick?.(row)}\n            className={cn(\n              onRowClick && 'cursor-pointer',\n              isSelected && 'bg-accent/50'\n            )}\n            style={{\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: '100%',\n              height: `${virtualItem.size}px`,\n              transform: `translateY(${virtualItem.start}px)`,\n            }}\n          >\n            {selectable && (\n              <TableCell\n                onClick={(e) => e.stopPropagation()}\n                className=\"w-12\"\n              >\n                <Checkbox\n                  checked={isSelected}\n                  onCheckedChange={(checked) =>\n                    onRowSelect(rowId, checked === true)\n                  }\n                  aria-label={`Select row ${virtualItem.index + 1}`}\n                />\n              </TableCell>\n            )}\n            {columns.map((column) => (\n              <TableCell\n                key={String(column.key)}\n                className={cn(column.className)}\n              >\n                {column.render\n                  ? column.render(row[column.key], row)\n                  : String(row[column.key] ?? '')}\n              </TableCell>\n            ))}\n          </TableRow>\n        )\n      })}\n    </TableBody>\n  )\n}\n```\n\n### 4. Refactor DataTable Component\n\nUpdate `data-table.tsx` to use virtualization when data exceeds threshold:\n\n**Add imports:**\n```typescript\nimport { useVirtualTable } from '@/hooks/useVirtualTable'\nimport { VirtualTableBody } from './virtual-table-body'\n```\n\n**Add new props to DataTableProps interface:**\n```typescript\nexport interface DataTableProps<T> {\n  // ... existing props ...\n  /**\n   * Enable virtual scrolling for large datasets\n   */\n  virtualized?: boolean\n  /**\n   * Threshold for auto-enabling virtualization (default: 30)\n   */\n  virtualizeThreshold?: number\n  /**\n   * Estimated row height in pixels (default: 48)\n   */\n  estimatedRowHeight?: number\n  /**\n   * Max height for virtualized container (default: 400)\n   */\n  maxHeight?: number\n}\n```\n\n**Integrate useVirtualTable in component:**\n```typescript\n// Inside DataTable component, after pagination logic\nconst {\n  containerRef,\n  virtualItems,\n  totalHeight,\n  isVirtualized,\n  getRowData,\n} = useVirtualTable({\n  data: paginatedData,\n  virtualizeThreshold: virtualizeThreshold ?? 30,\n  estimatedRowHeight: estimatedRowHeight ?? 48,\n  containerHeight: maxHeight ?? 400,\n})\n```\n\n**Replace desktop TableBody (lines 341-381) with conditional rendering:**\n```typescript\n{/* Desktop Table View */}\n<div \n  ref={containerRef}\n  className=\"hidden md:block rounded-lg border overflow-hidden\"\n  style={isVirtualized ? { maxHeight: maxHeight ?? 400, overflowY: 'auto' } : undefined}\n>\n  <Table className={cn(tableClassName)}>\n    <TableHeader>\n      {/* ... existing header code ... */}\n    </TableHeader>\n    {isVirtualized ? (\n      <VirtualTableBody\n        virtualItems={virtualItems}\n        totalHeight={totalHeight}\n        getRowData={getRowData}\n        columns={columns}\n        selectable={selectable}\n        selected={selected}\n        getRowId={getRowId}\n        onRowClick={onRowClick}\n        onRowSelect={handleRowSelect}\n      />\n    ) : (\n      <TableBody>\n        {/* ... existing non-virtualized row rendering ... */}\n      </TableBody>\n    )}\n  </Table>\n</div>\n```\n\n### 5. Create Virtual Mobile Cards Component\n\nSimilarly create `VirtualMobileCards` component for mobile view virtualization:\n\n```typescript\n// quikadmin-web/src/components/features/virtual-mobile-cards.tsx\nexport function VirtualMobileCards<T extends Record<string, unknown>>({\n  virtualItems,\n  totalHeight,\n  getRowData,\n  columns,\n  selectable,\n  selected,\n  getRowId,\n  onRowClick,\n  onRowSelect,\n}: VirtualMobileCardsProps<T>) {\n  return (\n    <div\n      style={{\n        height: `${totalHeight}px`,\n        position: 'relative',\n      }}\n    >\n      {virtualItems.map((virtualItem) => {\n        const row = getRowData(virtualItem)\n        const rowId = getRowId(row)\n        const isSelected = selected.includes(rowId)\n        \n        return (\n          <div\n            key={virtualItem.key}\n            data-index={virtualItem.index}\n            onClick={() => onRowClick?.(row)}\n            className={cn(\n              'rounded-lg border bg-card p-4 space-y-2',\n              onRowClick && 'cursor-pointer hover:bg-accent/50 transition-colors',\n              isSelected && 'border-primary bg-accent/50'\n            )}\n            style={{\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: '100%',\n              transform: `translateY(${virtualItem.start}px)`,\n            }}\n          >\n            {/* ... card content ... */}\n          </div>\n        )\n      })}\n    </div>\n  )\n}\n```\n\n### 6. Integration with useIntersectionObserver (Task 174)\n\nThe `useIntersectionObserver` hook from Task 174 can enhance virtualization:\n- Use it for initial visibility detection before @tanstack/react-virtual takes over\n- Integrate for lazy-loading row content (e.g., images, avatars within cells)\n- Combine with virtual scrolling for optimal DOM usage\n\n```typescript\n// Example integration in VirtualTableBody\nimport { useIntersectionObserver } from '@/hooks/useIntersectionObserver'\n\n// Within row rendering, for lazy content:\nconst { ref, isIntersecting } = useIntersectionObserver({\n  threshold: 0.1,\n  rootMargin: '100px',\n})\n\n// Only render heavy content when visible\n{isIntersecting && <ExpensiveAvatarComponent />}\n```\n\n### 7. Performance Optimizations\n\n1. **Memoize row rendering:**\n   ```typescript\n   const MemoizedTableRow = React.memo(VirtualTableRow)\n   ```\n\n2. **Use stable references:**\n   ```typescript\n   const stableGetRowId = React.useCallback(getRowId, [])\n   ```\n\n3. **Debounce scroll events (handled by @tanstack/react-virtual internally)**\n\n### 8. Backwards Compatibility\n\n- Default `virtualized` to `undefined` (auto-detect based on threshold)\n- Existing DataTable consumers work without changes\n- Only activates when `data.length > virtualizeThreshold`\n- Mobile view uses separate virtualization with appropriate card heights\n\n### Files to Create/Modify\n\n| File | Action |\n|------|--------|\n| `quikadmin-web/src/hooks/useVirtualTable.ts` | Create |\n| `quikadmin-web/src/components/features/virtual-table-body.tsx` | Create |\n| `quikadmin-web/src/components/features/virtual-mobile-cards.tsx` | Create |\n| `quikadmin-web/src/components/features/data-table.tsx` | Modify |\n| `quikadmin-web/src/hooks/index.ts` | Update exports |\n| `quikadmin-web/src/components/index.ts` | Update exports |",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useVirtualTable (`quikadmin-web/src/hooks/__tests__/useVirtualTable.test.tsx`)\n\n```typescript\nimport { renderHook, act } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { useVirtualTable } from '../useVirtualTable'\n\n// Mock @tanstack/react-virtual\nvi.mock('@tanstack/react-virtual', () => ({\n  useVirtualizer: vi.fn().mockReturnValue({\n    getVirtualItems: () => [\n      { key: '0', index: 0, start: 0, size: 48 },\n      { key: '1', index: 1, start: 48, size: 48 },\n    ],\n    getTotalSize: () => 2400,\n  }),\n}))\n\ndescribe('useVirtualTable', () => {\n  const mockData = Array.from({ length: 50 }, (_, i) => ({\n    id: `${i}`,\n    name: `Item ${i}`,\n  }))\n  \n  it('enables virtualization above threshold', () => {\n    const { result } = renderHook(() =>\n      useVirtualTable({\n        data: mockData,\n        virtualizeThreshold: 30,\n      })\n    )\n    \n    expect(result.current.isVirtualized).toBe(true)\n    expect(result.current.virtualItems.length).toBeGreaterThan(0)\n  })\n  \n  it('disables virtualization below threshold', () => {\n    const smallData = mockData.slice(0, 10)\n    const { result } = renderHook(() =>\n      useVirtualTable({\n        data: smallData,\n        virtualizeThreshold: 30,\n      })\n    )\n    \n    expect(result.current.isVirtualized).toBe(false)\n    expect(result.current.visibleData).toEqual(smallData)\n  })\n  \n  it('returns correct row data for virtual item', () => {\n    const { result } = renderHook(() =>\n      useVirtualTable({\n        data: mockData,\n        virtualizeThreshold: 30,\n      })\n    )\n    \n    const virtualItem = { key: '5', index: 5, start: 240, size: 48 }\n    const rowData = result.current.getRowData(virtualItem)\n    \n    expect(rowData).toEqual(mockData[5])\n  })\n  \n  it('provides container ref', () => {\n    const { result } = renderHook(() =>\n      useVirtualTable({\n        data: mockData,\n        virtualizeThreshold: 30,\n      })\n    )\n    \n    expect(result.current.containerRef).toBeDefined()\n    expect(result.current.containerRef.current).toBeNull() // Not mounted yet\n  })\n  \n  it('calculates total height correctly', () => {\n    const { result } = renderHook(() =>\n      useVirtualTable({\n        data: mockData,\n        estimatedRowHeight: 48,\n        virtualizeThreshold: 30,\n      })\n    )\n    \n    expect(result.current.totalHeight).toBe(2400) // 50 * 48\n  })\n})\n```\n\n### 2. Component Tests for VirtualTableBody (`quikadmin-web/src/components/features/__tests__/virtual-table-body.test.tsx`)\n\n```typescript\nimport React from 'react'\nimport { describe, it, expect, vi } from 'vitest'\nimport { render, screen, fireEvent } from '@testing-library/react'\nimport { VirtualTableBody } from '../virtual-table-body'\n\nconst mockColumns = [\n  { key: 'name', header: 'Name' },\n  { key: 'email', header: 'Email' },\n]\n\nconst mockVirtualItems = [\n  { key: '0', index: 0, start: 0, size: 48 },\n  { key: '1', index: 1, start: 48, size: 48 },\n]\n\nconst mockData = [\n  { id: '1', name: 'Alice', email: 'alice@test.com' },\n  { id: '2', name: 'Bob', email: 'bob@test.com' },\n]\n\ndescribe('VirtualTableBody', () => {\n  it('renders virtual items correctly', () => {\n    render(\n      <table>\n        <VirtualTableBody\n          virtualItems={mockVirtualItems}\n          totalHeight={2400}\n          getRowData={(item) => mockData[item.index]}\n          columns={mockColumns}\n          selected={[]}\n          getRowId={(row) => row.id}\n          onRowSelect={() => {}}\n        />\n      </table>\n    )\n    \n    expect(screen.getByText('Alice')).toBeInTheDocument()\n    expect(screen.getByText('Bob')).toBeInTheDocument()\n  })\n  \n  it('applies absolute positioning styles', () => {\n    render(\n      <table>\n        <VirtualTableBody\n          virtualItems={mockVirtualItems}\n          totalHeight={2400}\n          getRowData={(item) => mockData[item.index]}\n          columns={mockColumns}\n          selected={[]}\n          getRowId={(row) => row.id}\n          onRowSelect={() => {}}\n        />\n      </table>\n    )\n    \n    const rows = screen.getAllByRole('row')\n    expect(rows[0]).toHaveStyle({ transform: 'translateY(0px)' })\n    expect(rows[1]).toHaveStyle({ transform: 'translateY(48px)' })\n  })\n  \n  it('handles row selection in virtualized mode', async () => {\n    const onRowSelect = vi.fn()\n    render(\n      <table>\n        <VirtualTableBody\n          virtualItems={mockVirtualItems}\n          totalHeight={2400}\n          getRowData={(item) => mockData[item.index]}\n          columns={mockColumns}\n          selectable\n          selected={[]}\n          getRowId={(row) => row.id}\n          onRowSelect={onRowSelect}\n        />\n      </table>\n    )\n    \n    const checkboxes = screen.getAllByRole('checkbox')\n    fireEvent.click(checkboxes[0])\n    \n    expect(onRowSelect).toHaveBeenCalledWith('1', true)\n  })\n  \n  it('calls onRowClick with correct row data', () => {\n    const onRowClick = vi.fn()\n    render(\n      <table>\n        <VirtualTableBody\n          virtualItems={mockVirtualItems}\n          totalHeight={2400}\n          getRowData={(item) => mockData[item.index]}\n          columns={mockColumns}\n          selected={[]}\n          getRowId={(row) => row.id}\n          onRowClick={onRowClick}\n          onRowSelect={() => {}}\n        />\n      </table>\n    )\n    \n    const rows = screen.getAllByRole('row')\n    fireEvent.click(rows[0])\n    \n    expect(onRowClick).toHaveBeenCalledWith(mockData[0])\n  })\n})\n```\n\n### 3. Integration Tests for DataTable with Virtualization\n\n```typescript\n// quikadmin-web/src/components/features/__tests__/data-table-virtual.test.tsx\nimport React from 'react'\nimport { describe, it, expect, vi } from 'vitest'\nimport { render, screen, waitFor } from '@testing-library/react'\nimport { DataTable } from '../data-table'\n\n// Generate large dataset\nconst generateLargeDataset = (count: number) =>\n  Array.from({ length: count }, (_, i) => ({\n    id: `${i}`,\n    name: `User ${i}`,\n    email: `user${i}@test.com`,\n    [Symbol.for('__index__')]: i,\n  }))\n\nconst columns = [\n  { key: 'name', header: 'Name' },\n  { key: 'email', header: 'Email' },\n]\n\ndescribe('DataTable Virtual Scrolling', () => {\n  it('enables virtualization for large datasets', () => {\n    const largeData = generateLargeDataset(100)\n    render(\n      <DataTable\n        data={largeData}\n        columns={columns}\n        virtualizeThreshold={30}\n      />\n    )\n    \n    // Should not render all 100 rows\n    const rows = screen.getAllByRole('row')\n    expect(rows.length).toBeLessThan(100)\n  })\n  \n  it('renders all rows for small datasets', () => {\n    const smallData = generateLargeDataset(10)\n    render(\n      <DataTable\n        data={smallData}\n        columns={columns}\n        virtualizeThreshold={30}\n      />\n    )\n    \n    // Should render header + 10 data rows\n    const rows = screen.getAllByRole('row')\n    expect(rows.length).toBe(11) // 1 header + 10 rows (desktop only)\n  })\n  \n  it('maintains sorting with virtualization', async () => {\n    const largeData = generateLargeDataset(50)\n    const sortableColumns = [\n      { key: 'name', header: 'Name', sortable: true },\n      { key: 'email', header: 'Email' },\n    ]\n    \n    render(\n      <DataTable\n        data={largeData}\n        columns={sortableColumns}\n        virtualizeThreshold={30}\n      />\n    )\n    \n    // Sorting should still work\n    const sortButton = screen.getByRole('button', { name: /name/i })\n    fireEvent.click(sortButton)\n    \n    // Verify sorting applied (first visible item should change)\n    await waitFor(() => {\n      expect(screen.getByText(/User/)).toBeInTheDocument()\n    })\n  })\n  \n  it('maintains selection with virtualization', () => {\n    const largeData = generateLargeDataset(50)\n    const handleSelection = vi.fn()\n    \n    render(\n      <DataTable\n        data={largeData}\n        columns={columns}\n        selectable\n        selectedRows={[]}\n        onSelectionChange={handleSelection}\n        virtualizeThreshold={30}\n      />\n    )\n    \n    const checkboxes = screen.getAllByRole('checkbox')\n    fireEvent.click(checkboxes[1]) // Select first data row\n    \n    expect(handleSelection).toHaveBeenCalled()\n  })\n})\n```\n\n### 4. Performance Benchmark Tests\n\n```typescript\n// quikadmin-web/src/components/features/__tests__/data-table-performance.test.tsx\nimport { describe, it, expect } from 'vitest'\nimport { render } from '@testing-library/react'\nimport { DataTable } from '../data-table'\n\ndescribe('DataTable Performance', () => {\n  const generateLargeDataset = (count: number) =>\n    Array.from({ length: count }, (_, i) => ({\n      id: `${i}`,\n      name: `User ${i}`,\n      email: `user${i}@test.com`,\n      status: 'active',\n      createdAt: new Date().toISOString(),\n    }))\n  \n  const columns = [\n    { key: 'name', header: 'Name', sortable: true },\n    { key: 'email', header: 'Email' },\n    { key: 'status', header: 'Status' },\n    { key: 'createdAt', header: 'Created' },\n  ]\n  \n  it('renders 100 rows in under 200ms with virtualization', () => {\n    const largeData = generateLargeDataset(100)\n    \n    const startTime = performance.now()\n    render(\n      <DataTable\n        data={largeData}\n        columns={columns}\n        virtualizeThreshold={30}\n      />\n    )\n    const endTime = performance.now()\n    \n    const renderTime = endTime - startTime\n    expect(renderTime).toBeLessThan(200) // Should be 300%+ faster than 500ms baseline\n  })\n  \n  it('renders 500 rows in under 300ms with virtualization', () => {\n    const largeData = generateLargeDataset(500)\n    \n    const startTime = performance.now()\n    render(\n      <DataTable\n        data={largeData}\n        columns={columns}\n        virtualizeThreshold={30}\n      />\n    )\n    const endTime = performance.now()\n    \n    const renderTime = endTime - startTime\n    expect(renderTime).toBeLessThan(300)\n  })\n  \n  it('maintains O(1) visible row count regardless of data size', () => {\n    const counts = [50, 100, 500, 1000]\n    const visibleRowCounts: number[] = []\n    \n    counts.forEach((count) => {\n      const data = generateLargeDataset(count)\n      const { container } = render(\n        <DataTable\n          data={data}\n          columns={columns}\n          virtualizeThreshold={30}\n        />\n      )\n      \n      const rows = container.querySelectorAll('[data-index]')\n      visibleRowCounts.push(rows.length)\n    })\n    \n    // All should have similar visible row counts (within buffer)\n    const maxVariance = Math.max(...visibleRowCounts) - Math.min(...visibleRowCounts)\n    expect(maxVariance).toBeLessThan(20) // Allow for overscan variance\n  })\n})\n```\n\n### 5. Visual Regression Testing\n\n```typescript\n// cypress/e2e/data-table-virtual.cy.ts\ndescribe('DataTable Virtual Scrolling', () => {\n  beforeEach(() => {\n    cy.intercept('GET', '/api/documents*', {\n      fixture: 'large-document-list.json', // 100+ documents\n    })\n    cy.visit('/documents')\n  })\n  \n  it('scrolls smoothly through large dataset', () => {\n    cy.get('[data-slot=\"data-table\"]').should('exist')\n    \n    // Scroll to middle\n    cy.get('[data-slot=\"table-container\"]').scrollTo(0, 2000)\n    cy.wait(100)\n    \n    // Should render rows around scroll position\n    cy.get('[data-index]').should('have.length.lessThan', 50)\n    \n    // Scroll to end\n    cy.get('[data-slot=\"table-container\"]').scrollTo('bottom')\n    cy.wait(100)\n    \n    // Last items should be visible\n    cy.contains('User 99').should('be.visible')\n  })\n  \n  it('maintains selection across scroll', () => {\n    // Select first row\n    cy.get('[data-index=\"0\"] input[type=\"checkbox\"]').check()\n    \n    // Scroll away\n    cy.get('[data-slot=\"table-container\"]').scrollTo(0, 2000)\n    \n    // Scroll back\n    cy.get('[data-slot=\"table-container\"]').scrollTo('top')\n    \n    // Selection should persist\n    cy.get('[data-index=\"0\"] input[type=\"checkbox\"]').should('be.checked')\n  })\n})\n```\n\n### 6. Manual Testing Checklist\n\n- [ ] Load DocumentLibrary with 50+ documents - verify render time < 200ms\n- [ ] Load DocumentLibrary with 100+ documents - verify smooth scrolling\n- [ ] Scroll quickly up/down - no flickering or blank rows\n- [ ] Select rows, scroll away, scroll back - selection persists\n- [ ] Sort columns with virtualization active - data reorders correctly\n- [ ] Search/filter with virtualization - rows update correctly\n- [ ] Mobile view virtualization - cards render efficiently\n- [ ] Resize browser window - virtualization adapts correctly\n- [ ] Test with slow network (throttle) - no degradation\n- [ ] Memory profiling in DevTools - no memory leaks during scroll",
        "status": "done",
        "dependencies": [
          "174"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-01T16:31:16.477Z"
      },
      {
        "id": "183",
        "title": "Create Unified useFetch Wrapper Hook for Standardized Data Fetching",
        "description": "Create a unified useFetch wrapper hook in quikadmin-web/src/hooks/ that standardizes data fetching across the codebase, replacing the inconsistent patterns found in useApiData.ts (SSE + polling), documentService.ts (axios direct calls), and SimpleFillForm.tsx (@tanstack/react-query). The hook provides centralized error handling, retry logic with exponential backoff, request caching, unified loading/error states, and automatic AbortController cleanup.",
        "details": "## Implementation Details\n\n### Overview\nThe codebase currently has 3 distinct data fetching patterns that need unification:\n\n1. **useApiData.ts (lines 54-194)**: Manual useState/useEffect with SSE integration and interval polling\n2. **documentService.ts (lines 165-222)**: Direct axios calls with manual `fetch()` for some endpoints\n3. **SimpleFillForm.tsx (lines 174-192)**: @tanstack/react-query with `useQuery` but inconsistent options\n\nThe unified `useFetch` hook will wrap @tanstack/react-query (already installed) with standardized configuration and additional features.\n\n### 1. Create useFetch Hook (`quikadmin-web/src/hooks/useFetch.ts`)\n\n```typescript\n/**\n * Unified data fetching hook with standardized error handling, caching, and retry logic\n * @module hooks/useFetch\n */\n\nimport * as React from 'react'\nimport { useQuery, useMutation, UseQueryOptions, UseMutationOptions, QueryKey } from '@tanstack/react-query'\nimport api from '@/services/api'\nimport { getUserErrorMessage, isRetryableError } from '@/utils/errorMessages'\n\n// Default retry configuration with exponential backoff\nconst DEFAULT_RETRY_CONFIG = {\n  retries: 3,\n  baseDelay: 1000,\n  maxDelay: 30000,\n  backoffMultiplier: 2,\n}\n\n// Calculate delay with exponential backoff and jitter\nfunction calculateRetryDelay(attemptIndex: number, config = DEFAULT_RETRY_CONFIG): number {\n  const delay = Math.min(\n    config.baseDelay * Math.pow(config.backoffMultiplier, attemptIndex),\n    config.maxDelay\n  )\n  // Add jitter (±25%) to prevent thundering herd\n  const jitter = delay * 0.25 * (Math.random() - 0.5)\n  return Math.round(delay + jitter)\n}\n\nexport interface UseFetchOptions<TData, TError = Error> extends Omit<\n  UseQueryOptions<TData, TError>,\n  'queryKey' | 'queryFn'\n> {\n  /** URL path (relative to API base) */\n  url: string\n  /** Query parameters */\n  params?: Record<string, any>\n  /** Cache time in milliseconds (default: 5 minutes) */\n  cacheTime?: number\n  /** Stale time in milliseconds (default: 30 seconds) */\n  staleTime?: number\n  /** Enable retry with exponential backoff (default: true) */\n  enableRetry?: boolean\n  /** Custom retry configuration */\n  retryConfig?: Partial<typeof DEFAULT_RETRY_CONFIG>\n  /** Transform response data */\n  transform?: (data: any) => TData\n  /** Custom error handler */\n  onError?: (error: TError) => void\n}\n\nexport interface UseFetchResult<TData, TError = Error> {\n  data: TData | undefined\n  error: TError | null\n  isLoading: boolean\n  isError: boolean\n  isFetching: boolean\n  isSuccess: boolean\n  refetch: () => Promise<any>\n  /** User-friendly error message */\n  errorMessage: string | null\n  /** Whether the error is retryable */\n  isRetryable: boolean\n}\n\n/**\n * Unified data fetching hook with standardized patterns\n * \n * @example\n * ```tsx\n * const { data, isLoading, errorMessage } = useFetch<UserData>({\n *   url: '/users/me/data',\n *   staleTime: 60000,\n *   transform: (res) => res.data,\n * })\n * ```\n */\nexport function useFetch<TData = any, TError = Error>(\n  options: UseFetchOptions<TData, TError>\n): UseFetchResult<TData, TError> {\n  const {\n    url,\n    params,\n    cacheTime = 5 * 60 * 1000, // 5 minutes\n    staleTime = 30 * 1000, // 30 seconds\n    enableRetry = true,\n    retryConfig = {},\n    transform,\n    onError,\n    ...queryOptions\n  } = options\n\n  const mergedRetryConfig = { ...DEFAULT_RETRY_CONFIG, ...retryConfig }\n  \n  // Create stable query key\n  const queryKey: QueryKey = React.useMemo(\n    () => ['fetch', url, params].filter(Boolean),\n    [url, JSON.stringify(params)]\n  )\n\n  // AbortController for cleanup\n  const abortControllerRef = React.useRef<AbortController | null>(null)\n\n  // Cleanup on unmount\n  React.useEffect(() => {\n    return () => {\n      abortControllerRef.current?.abort()\n    }\n  }, [])\n\n  const query = useQuery<TData, TError>({\n    queryKey,\n    queryFn: async ({ signal }) => {\n      // Create new AbortController linked to React Query's signal\n      abortControllerRef.current = new AbortController()\n      \n      // Link to React Query's abort signal\n      signal?.addEventListener('abort', () => {\n        abortControllerRef.current?.abort()\n      })\n\n      const response = await api.get(url, {\n        params,\n        signal: abortControllerRef.current.signal,\n      })\n      \n      const data = response.data\n      return transform ? transform(data) : data\n    },\n    staleTime,\n    gcTime: cacheTime,\n    retry: enableRetry ? mergedRetryConfig.retries : false,\n    retryDelay: (attemptIndex) => calculateRetryDelay(attemptIndex, mergedRetryConfig),\n    ...queryOptions,\n  })\n\n  // Handle error callback\n  React.useEffect(() => {\n    if (query.error && onError) {\n      onError(query.error)\n    }\n  }, [query.error, onError])\n\n  // Derive user-friendly error info\n  const errorInfo = React.useMemo(() => {\n    if (!query.error) {\n      return { message: null, isRetryable: false }\n    }\n    return {\n      message: getUserErrorMessage(query.error),\n      isRetryable: isRetryableError(query.error),\n    }\n  }, [query.error])\n\n  return {\n    data: query.data,\n    error: query.error,\n    isLoading: query.isLoading,\n    isError: query.isError,\n    isFetching: query.isFetching,\n    isSuccess: query.isSuccess,\n    refetch: query.refetch,\n    errorMessage: errorInfo.message,\n    isRetryable: errorInfo.isRetryable,\n  }\n}\n```\n\n### 2. Create useMutate Hook for POST/PUT/DELETE Operations\n\n```typescript\nexport interface UseMutateOptions<TData, TVariables, TError = Error> extends Omit<\n  UseMutationOptions<TData, TError, TVariables>,\n  'mutationFn'\n> {\n  /** HTTP method */\n  method?: 'POST' | 'PUT' | 'PATCH' | 'DELETE'\n  /** URL path (relative to API base) */\n  url: string | ((variables: TVariables) => string)\n  /** Transform response data */\n  transform?: (data: any) => TData\n  /** Enable retry for mutations (default: false for safety) */\n  enableRetry?: boolean\n}\n\nexport function useMutate<TData = any, TVariables = any, TError = Error>(\n  options: UseMutateOptions<TData, TVariables, TError>\n) {\n  const {\n    method = 'POST',\n    url,\n    transform,\n    enableRetry = false,\n    ...mutationOptions\n  } = options\n\n  const abortControllerRef = React.useRef<AbortController | null>(null)\n\n  React.useEffect(() => {\n    return () => {\n      abortControllerRef.current?.abort()\n    }\n  }, [])\n\n  return useMutation<TData, TError, TVariables>({\n    mutationFn: async (variables) => {\n      abortControllerRef.current = new AbortController()\n      \n      const resolvedUrl = typeof url === 'function' ? url(variables) : url\n      \n      const response = await api.request({\n        method,\n        url: resolvedUrl,\n        data: method !== 'DELETE' ? variables : undefined,\n        signal: abortControllerRef.current.signal,\n      })\n      \n      const data = response.data\n      return transform ? transform(data) : data\n    },\n    retry: enableRetry ? 1 : false,\n    ...mutationOptions,\n  })\n}\n```\n\n### 3. Create Specialized Hooks Built on useFetch\n\n```typescript\n// useFetchWithPolling - for real-time data that needs periodic refresh\nexport function useFetchWithPolling<TData>(\n  options: UseFetchOptions<TData> & {\n    pollingInterval?: number\n    enablePolling?: boolean\n  }\n) {\n  const { pollingInterval = 5000, enablePolling = true, ...fetchOptions } = options\n\n  return useFetch<TData>({\n    ...fetchOptions,\n    refetchInterval: enablePolling ? pollingInterval : false,\n    refetchIntervalInBackground: false,\n  })\n}\n\n// useFetchOnce - for data that should only be fetched once\nexport function useFetchOnce<TData>(options: UseFetchOptions<TData>) {\n  return useFetch<TData>({\n    ...options,\n    staleTime: Infinity,\n    gcTime: Infinity,\n    refetchOnMount: false,\n    refetchOnWindowFocus: false,\n  })\n}\n\n// useLazyFetch - for on-demand fetching (e.g., after user action)\nexport function useLazyFetch<TData>(options: Omit<UseFetchOptions<TData>, 'enabled'>) {\n  const [shouldFetch, setShouldFetch] = React.useState(false)\n  \n  const result = useFetch<TData>({\n    ...options,\n    enabled: shouldFetch,\n  })\n\n  const trigger = React.useCallback(() => {\n    setShouldFetch(true)\n  }, [])\n\n  const reset = React.useCallback(() => {\n    setShouldFetch(false)\n  }, [])\n\n  return { ...result, trigger, reset }\n}\n```\n\n### 4. Export from hooks/index.ts\n\n```typescript\nexport {\n  useFetch,\n  useMutate,\n  useFetchWithPolling,\n  useFetchOnce,\n  useLazyFetch,\n  type UseFetchOptions,\n  type UseFetchResult,\n  type UseMutateOptions,\n} from './useFetch'\n```\n\n### 5. Migration Examples\n\n**Before (useApiData.ts pattern):**\n```typescript\nconst [data, setData] = useState(null);\nconst [loading, setLoading] = useState(true);\nconst [error, setError] = useState(null);\n\nuseEffect(() => {\n  const fetchData = async () => {\n    try {\n      setLoading(true);\n      const stats = await getStatistics();\n      setData(stats);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n  fetchData();\n  const interval = setInterval(fetchData, 120000);\n  return () => clearInterval(interval);\n}, []);\n```\n\n**After (useFetch pattern):**\n```typescript\nconst { data, isLoading, errorMessage, refetch } = useFetchWithPolling({\n  url: '/statistics',\n  pollingInterval: 120000,\n  staleTime: 60000,\n})\n```\n\n**Before (SimpleFillForm.tsx pattern):**\n```typescript\nconst { data, isLoading, error } = useQuery({\n  queryKey: ['user-data'],\n  queryFn: () => api.get('/users/me/data').then((res) => res.data),\n  staleTime: 60000,\n  retry: 1,\n});\n```\n\n**After (useFetch pattern):**\n```typescript\nconst { data, isLoading, errorMessage } = useFetch<UserDataResponse>({\n  url: '/users/me/data',\n  staleTime: 60000,\n  transform: (res) => res.data,\n})\n```\n\n### 6. Key Features\n\n1. **Centralized Error Handling**: Uses existing `getUserErrorMessage()` and `isRetryableError()` from `utils/errorMessages.ts`\n2. **Retry with Exponential Backoff**: Configurable retry logic with jitter to prevent thundering herd\n3. **Request Caching**: Leverages React Query's built-in cache with sensible defaults\n4. **Loading/Error States**: Unified state interface across all fetch operations\n5. **AbortController Cleanup**: Automatic request cancellation on unmount\n6. **TypeScript Support**: Full generic type support for request/response types\n\n### 7. Files to Modify\n\n1. **Create**: `quikadmin-web/src/hooks/useFetch.ts` - Main hook implementation\n2. **Update**: `quikadmin-web/src/hooks/index.ts` - Export new hooks\n3. **Future Migration** (separate tasks): Refactor useApiData.ts, documentService.ts, SimpleFillForm.tsx to use useFetch",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests (`quikadmin-web/src/hooks/__tests__/useFetch.test.tsx`)\n\n```typescript\nimport { renderHook, waitFor, act } from '@testing-library/react'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { useFetch, useMutate, useFetchWithPolling, useFetchOnce, useLazyFetch } from '../useFetch'\nimport api from '@/services/api'\n\n// Mock api module\nvi.mock('@/services/api', () => ({\n  default: {\n    get: vi.fn(),\n    request: vi.fn(),\n  },\n}))\n\nconst createWrapper = () => {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: { retry: false },\n      mutations: { retry: false },\n    },\n  })\n  return ({ children }: { children: React.ReactNode }) => (\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n  )\n}\n\ndescribe('useFetch', () => {\n  beforeEach(() => {\n    vi.clearAllMocks()\n  })\n\n  it('fetches data successfully', async () => {\n    const mockData = { success: true, data: { name: 'Test' } }\n    vi.mocked(api.get).mockResolvedValueOnce({ data: mockData })\n\n    const { result } = renderHook(\n      () => useFetch({ url: '/test' }),\n      { wrapper: createWrapper() }\n    )\n\n    expect(result.current.isLoading).toBe(true)\n    \n    await waitFor(() => {\n      expect(result.current.isSuccess).toBe(true)\n    })\n\n    expect(result.current.data).toEqual(mockData)\n    expect(result.current.isLoading).toBe(false)\n    expect(result.current.errorMessage).toBeNull()\n  })\n\n  it('handles errors with user-friendly messages', async () => {\n    const error = new Error('Network error')\n    vi.mocked(api.get).mockRejectedValueOnce(error)\n\n    const { result } = renderHook(\n      () => useFetch({ url: '/test', enableRetry: false }),\n      { wrapper: createWrapper() }\n    )\n\n    await waitFor(() => {\n      expect(result.current.isError).toBe(true)\n    })\n\n    expect(result.current.errorMessage).toBeTruthy()\n    expect(result.current.error).toBe(error)\n  })\n\n  it('transforms response data', async () => {\n    const mockResponse = { success: true, data: { items: [1, 2, 3] } }\n    vi.mocked(api.get).mockResolvedValueOnce({ data: mockResponse })\n\n    const { result } = renderHook(\n      () => useFetch({\n        url: '/test',\n        transform: (res) => res.data.items,\n      }),\n      { wrapper: createWrapper() }\n    )\n\n    await waitFor(() => {\n      expect(result.current.isSuccess).toBe(true)\n    })\n\n    expect(result.current.data).toEqual([1, 2, 3])\n  })\n\n  it('passes query parameters', async () => {\n    vi.mocked(api.get).mockResolvedValueOnce({ data: {} })\n\n    renderHook(\n      () => useFetch({\n        url: '/test',\n        params: { page: 1, limit: 10 },\n      }),\n      { wrapper: createWrapper() }\n    )\n\n    await waitFor(() => {\n      expect(api.get).toHaveBeenCalledWith('/test', expect.objectContaining({\n        params: { page: 1, limit: 10 },\n      }))\n    })\n  })\n\n  it('cleans up AbortController on unmount', async () => {\n    vi.mocked(api.get).mockImplementation(() => new Promise(() => {})) // Never resolves\n\n    const { unmount } = renderHook(\n      () => useFetch({ url: '/test' }),\n      { wrapper: createWrapper() }\n    )\n\n    unmount()\n    // Verify no memory leaks or errors after unmount\n    expect(true).toBe(true)\n  })\n\n  it('uses exponential backoff for retries', async () => {\n    const error = new Error('Temporary failure')\n    vi.mocked(api.get)\n      .mockRejectedValueOnce(error)\n      .mockRejectedValueOnce(error)\n      .mockResolvedValueOnce({ data: { success: true } })\n\n    const { result } = renderHook(\n      () => useFetch({\n        url: '/test',\n        enableRetry: true,\n        retryConfig: { retries: 3, baseDelay: 100 },\n      }),\n      { wrapper: createWrapper() }\n    )\n\n    await waitFor(() => {\n      expect(result.current.isSuccess).toBe(true)\n    }, { timeout: 5000 })\n\n    expect(api.get).toHaveBeenCalledTimes(3)\n  })\n})\n\ndescribe('useMutate', () => {\n  it('performs POST mutation', async () => {\n    const mockResponse = { id: '123', name: 'Created' }\n    vi.mocked(api.request).mockResolvedValueOnce({ data: mockResponse })\n\n    const { result } = renderHook(\n      () => useMutate({\n        url: '/items',\n        method: 'POST',\n      }),\n      { wrapper: createWrapper() }\n    )\n\n    await act(async () => {\n      await result.current.mutateAsync({ name: 'New Item' })\n    })\n\n    expect(api.request).toHaveBeenCalledWith(\n      expect.objectContaining({\n        method: 'POST',\n        url: '/items',\n        data: { name: 'New Item' },\n      })\n    )\n  })\n\n  it('handles dynamic URLs', async () => {\n    vi.mocked(api.request).mockResolvedValueOnce({ data: {} })\n\n    const { result } = renderHook(\n      () => useMutate<void, { id: string }>({\n        url: (vars) => `/items/${vars.id}`,\n        method: 'DELETE',\n      }),\n      { wrapper: createWrapper() }\n    )\n\n    await act(async () => {\n      await result.current.mutateAsync({ id: '456' })\n    })\n\n    expect(api.request).toHaveBeenCalledWith(\n      expect.objectContaining({\n        method: 'DELETE',\n        url: '/items/456',\n      })\n    )\n  })\n})\n\ndescribe('useFetchWithPolling', () => {\n  it('refetches at specified interval', async () => {\n    vi.useFakeTimers()\n    vi.mocked(api.get).mockResolvedValue({ data: { count: 1 } })\n\n    renderHook(\n      () => useFetchWithPolling({\n        url: '/status',\n        pollingInterval: 1000,\n        enablePolling: true,\n      }),\n      { wrapper: createWrapper() }\n    )\n\n    await waitFor(() => {\n      expect(api.get).toHaveBeenCalledTimes(1)\n    })\n\n    vi.advanceTimersByTime(1100)\n\n    await waitFor(() => {\n      expect(api.get).toHaveBeenCalledTimes(2)\n    })\n\n    vi.useRealTimers()\n  })\n})\n\ndescribe('useLazyFetch', () => {\n  it('does not fetch until triggered', async () => {\n    vi.mocked(api.get).mockResolvedValue({ data: {} })\n\n    const { result } = renderHook(\n      () => useLazyFetch({ url: '/lazy' }),\n      { wrapper: createWrapper() }\n    )\n\n    expect(api.get).not.toHaveBeenCalled()\n    expect(result.current.isLoading).toBe(false)\n\n    act(() => {\n      result.current.trigger()\n    })\n\n    await waitFor(() => {\n      expect(api.get).toHaveBeenCalledTimes(1)\n    })\n  })\n})\n```\n\n### 2. Integration Tests\n\n```typescript\ndescribe('useFetch Integration', () => {\n  it('works with existing api interceptors', async () => {\n    // Verify that auth tokens are attached via api.ts interceptors\n    // Verify token refresh on 401 works correctly\n  })\n\n  it('integrates with errorMessages utility', async () => {\n    // Verify getUserErrorMessage and isRetryableError are called correctly\n  })\n})\n```\n\n### 3. Manual Testing Checklist\n\n1. **Basic Fetch**: Navigate to a page using useFetch, verify data loads\n2. **Error Handling**: Disconnect network, verify error message displays\n3. **Retry Logic**: Cause temporary failures, verify retries with backoff\n4. **Abort on Unmount**: Navigate away during fetch, verify no console errors\n5. **Polling**: Use useFetchWithPolling, verify periodic updates\n6. **Caching**: Navigate away and back, verify cached data loads instantly\n7. **TypeScript**: Verify generic types work correctly with IDE autocomplete\n\n### 4. Performance Testing\n\n1. Verify no memory leaks with React DevTools Profiler\n2. Verify AbortController cleanup prevents orphaned requests\n3. Verify polling doesn't cause excessive re-renders\n\n### 5. Acceptance Criteria\n\n- [ ] useFetch hook created with full TypeScript support\n- [ ] Exponential backoff retry logic implemented with jitter\n- [ ] AbortController cleanup on component unmount\n- [ ] User-friendly error messages via existing errorMessages utility\n- [ ] Polling variant (useFetchWithPolling) working correctly\n- [ ] Lazy fetch variant (useLazyFetch) for on-demand fetching\n- [ ] Mutation hook (useMutate) for POST/PUT/DELETE\n- [ ] All unit tests passing with >90% coverage\n- [ ] No console errors or memory leaks in manual testing",
        "status": "pending",
        "dependencies": [
          "173"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "184",
        "title": "Implement useIdle Hook for Session Timeout Detection",
        "description": "Create a useIdle hook in quikadmin-web/src/hooks/ that detects user inactivity through mousemove, keydown, scroll, and visibility change events, and integrate it with backendAuthStore.ts to automatically log out users after a configurable idle period for enhanced security on shared computers.",
        "details": "## Implementation Details\n\n### Overview\nThe current `backendAuthStore.ts` tracks `lastActivity` (line 68, 108, 213, 265, 330, 368) but lacks active idle detection. Users on shared computers remain logged in indefinitely without activity-based timeout. This task creates a `useIdle` hook that monitors user activity and integrates with the existing token refresh logic to provide automatic logout after configurable inactivity periods.\n\n### 1. Create useIdle Hook (`quikadmin-web/src/hooks/useIdle.ts`)\n\n```typescript\n/**\n * Idle detection hook for session timeout management\n * @module hooks/useIdle\n */\n\nimport * as React from 'react'\n\nexport interface UseIdleOptions {\n  /** Idle timeout in milliseconds (default: 15 minutes) */\n  timeout?: number\n  /** Events to listen for user activity */\n  events?: (keyof WindowEventMap)[]\n  /** Callback when user becomes idle */\n  onIdle?: () => void\n  /** Callback when user becomes active after being idle */\n  onActive?: () => void\n  /** Initial idle state (default: false) */\n  initialState?: boolean\n  /** Whether to detect cross-tab activity via localStorage (default: true) */\n  crossTab?: boolean\n}\n\nexport interface UseIdleReturn {\n  /** Whether user is currently idle */\n  isIdle: boolean\n  /** Timestamp of last activity */\n  lastActive: number\n  /** Manually reset idle timer */\n  reset: () => void\n  /** Time remaining until idle (in ms), null if already idle */\n  remaining: number | null\n  /** Pause idle detection */\n  pause: () => void\n  /** Resume idle detection */\n  resume: () => void\n}\n\nconst DEFAULT_EVENTS: (keyof WindowEventMap)[] = [\n  'mousemove',\n  'mousedown',\n  'keydown',\n  'touchstart',\n  'scroll',\n  'wheel',\n]\n\nconst STORAGE_KEY = 'intellifill-last-activity'\n\nexport function useIdle(options: UseIdleOptions = {}): UseIdleReturn {\n  const {\n    timeout = 15 * 60 * 1000, // 15 minutes default\n    events = DEFAULT_EVENTS,\n    onIdle,\n    onActive,\n    initialState = false,\n    crossTab = true,\n  } = options\n\n  const [isIdle, setIsIdle] = React.useState(initialState)\n  const [lastActive, setLastActive] = React.useState(Date.now())\n  const [remaining, setRemaining] = React.useState<number | null>(timeout)\n  const [isPaused, setIsPaused] = React.useState(false)\n\n  const timeoutRef = React.useRef<NodeJS.Timeout | null>(null)\n  const intervalRef = React.useRef<NodeJS.Timeout | null>(null)\n  const onIdleRef = React.useRef(onIdle)\n  const onActiveRef = React.useRef(onActive)\n\n  // Keep callback refs current\n  React.useEffect(() => {\n    onIdleRef.current = onIdle\n    onActiveRef.current = onActive\n  }, [onIdle, onActive])\n\n  const clearTimers = React.useCallback(() => {\n    if (timeoutRef.current) clearTimeout(timeoutRef.current)\n    if (intervalRef.current) clearInterval(intervalRef.current)\n  }, [])\n\n  const handleActivity = React.useCallback(() => {\n    if (isPaused) return\n\n    const now = Date.now()\n    setLastActive(now)\n    setRemaining(timeout)\n\n    // Update cross-tab activity\n    if (crossTab) {\n      try {\n        localStorage.setItem(STORAGE_KEY, now.toString())\n      } catch {\n        // localStorage may be unavailable\n      }\n    }\n\n    // If was idle, trigger onActive callback\n    if (isIdle) {\n      setIsIdle(false)\n      onActiveRef.current?.()\n    }\n\n    // Reset timeout\n    clearTimers()\n    timeoutRef.current = setTimeout(() => {\n      setIsIdle(true)\n      setRemaining(null)\n      onIdleRef.current?.()\n    }, timeout)\n\n    // Update remaining time every second\n    intervalRef.current = setInterval(() => {\n      setRemaining((prev) => {\n        if (prev === null || prev <= 1000) return null\n        return prev - 1000\n      })\n    }, 1000)\n  }, [timeout, isIdle, isPaused, crossTab, clearTimers])\n\n  const reset = React.useCallback(() => {\n    handleActivity()\n  }, [handleActivity])\n\n  const pause = React.useCallback(() => {\n    setIsPaused(true)\n    clearTimers()\n  }, [clearTimers])\n\n  const resume = React.useCallback(() => {\n    setIsPaused(false)\n    handleActivity()\n  }, [handleActivity])\n\n  // Handle cross-tab activity sync\n  React.useEffect(() => {\n    if (!crossTab) return\n\n    const handleStorageChange = (e: StorageEvent) => {\n      if (e.key === STORAGE_KEY && e.newValue) {\n        const otherTabActivity = parseInt(e.newValue, 10)\n        if (otherTabActivity > lastActive) {\n          handleActivity()\n        }\n      }\n    }\n\n    window.addEventListener('storage', handleStorageChange)\n    return () => window.removeEventListener('storage', handleStorageChange)\n  }, [crossTab, lastActive, handleActivity])\n\n  // Handle visibility change (tab switch)\n  React.useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'visible') {\n        // Check if we should have timed out while tab was hidden\n        const elapsed = Date.now() - lastActive\n        if (elapsed >= timeout && !isIdle) {\n          setIsIdle(true)\n          setRemaining(null)\n          onIdleRef.current?.()\n        } else if (!isIdle) {\n          handleActivity()\n        }\n      }\n    }\n\n    document.addEventListener('visibilitychange', handleVisibilityChange)\n    return () => document.removeEventListener('visibilitychange', handleVisibilityChange)\n  }, [lastActive, timeout, isIdle, handleActivity])\n\n  // Set up event listeners\n  React.useEffect(() => {\n    // Throttled activity handler (max once per 500ms)\n    let lastCall = 0\n    const throttledHandler = () => {\n      const now = Date.now()\n      if (now - lastCall >= 500) {\n        lastCall = now\n        handleActivity()\n      }\n    }\n\n    // Initial activity trigger\n    handleActivity()\n\n    // Add event listeners\n    events.forEach((event) => {\n      window.addEventListener(event, throttledHandler, { passive: true })\n    })\n\n    return () => {\n      clearTimers()\n      events.forEach((event) => {\n        window.removeEventListener(event, throttledHandler)\n      })\n    }\n  }, [events, handleActivity, clearTimers])\n\n  return {\n    isIdle,\n    lastActive,\n    reset,\n    remaining,\n    pause,\n    resume,\n  }\n}\n```\n\n### 2. Create Session Timeout Hook (`quikadmin-web/src/hooks/useSessionTimeout.ts`)\n\n```typescript\n/**\n * Session timeout hook integrating useIdle with auth store\n * @module hooks/useSessionTimeout\n */\n\nimport * as React from 'react'\nimport { useIdle, UseIdleOptions } from './useIdle'\nimport { useBackendAuthStore } from '@/stores/backendAuthStore'\n\nexport interface UseSessionTimeoutOptions {\n  /** Idle timeout in milliseconds (default: 15 minutes) */\n  timeout?: number\n  /** Warning time before logout in milliseconds (default: 2 minutes) */\n  warningTime?: number\n  /** Callback when showing warning */\n  onWarning?: (remainingMs: number) => void\n  /** Callback before logout */\n  onLogout?: () => void\n  /** Whether session timeout is enabled (default: true when authenticated) */\n  enabled?: boolean\n}\n\nexport interface UseSessionTimeoutReturn {\n  /** Whether user is idle */\n  isIdle: boolean\n  /** Whether warning is showing */\n  isWarning: boolean\n  /** Time remaining until logout (ms) */\n  remaining: number | null\n  /** Reset the idle timer (on user activity confirmation) */\n  stayLoggedIn: () => void\n  /** Manually trigger logout */\n  logout: () => void\n}\n\nexport function useSessionTimeout(options: UseSessionTimeoutOptions = {}): UseSessionTimeoutReturn {\n  const {\n    timeout = 15 * 60 * 1000, // 15 minutes\n    warningTime = 2 * 60 * 1000, // 2 minutes warning\n    onWarning,\n    onLogout,\n    enabled = true,\n  } = options\n\n  const isAuthenticated = useBackendAuthStore((state) => state.isAuthenticated)\n  const logout = useBackendAuthStore((state) => state.logout)\n  const refreshTokenIfNeeded = useBackendAuthStore((state) => state.refreshTokenIfNeeded)\n\n  const [isWarning, setIsWarning] = React.useState(false)\n  const onWarningRef = React.useRef(onWarning)\n  const onLogoutRef = React.useRef(onLogout)\n\n  React.useEffect(() => {\n    onWarningRef.current = onWarning\n    onLogoutRef.current = onLogout\n  }, [onWarning, onLogout])\n\n  const handleIdle = React.useCallback(async () => {\n    onLogoutRef.current?.()\n    await logout()\n  }, [logout])\n\n  const handleActive = React.useCallback(() => {\n    setIsWarning(false)\n    // Proactively refresh token on activity if needed\n    refreshTokenIfNeeded()\n  }, [refreshTokenIfNeeded])\n\n  const { isIdle, remaining, reset, pause, resume } = useIdle({\n    timeout,\n    onIdle: handleIdle,\n    onActive: handleActive,\n    initialState: false,\n  })\n\n  // Check for warning threshold\n  React.useEffect(() => {\n    if (!enabled || !isAuthenticated) return\n\n    if (remaining !== null && remaining <= warningTime && !isWarning) {\n      setIsWarning(true)\n      onWarningRef.current?.(remaining)\n    } else if (remaining !== null && remaining > warningTime && isWarning) {\n      setIsWarning(false)\n    }\n  }, [remaining, warningTime, isWarning, enabled, isAuthenticated])\n\n  // Pause/resume based on authentication state\n  React.useEffect(() => {\n    if (!enabled || !isAuthenticated) {\n      pause()\n    } else {\n      resume()\n    }\n  }, [enabled, isAuthenticated, pause, resume])\n\n  const stayLoggedIn = React.useCallback(() => {\n    reset()\n    setIsWarning(false)\n    // Refresh token on \"stay logged in\"\n    refreshTokenIfNeeded()\n  }, [reset, refreshTokenIfNeeded])\n\n  return {\n    isIdle,\n    isWarning,\n    remaining,\n    stayLoggedIn,\n    logout,\n  }\n}\n```\n\n### 3. Create Session Timeout Warning Component (`quikadmin-web/src/components/features/session-timeout-warning.tsx`)\n\n```typescript\n/**\n * Session timeout warning dialog\n */\n\nimport * as React from 'react'\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from '@/components/ui/alert-dialog'\nimport { useSessionTimeout } from '@/hooks/useSessionTimeout'\n\nexport interface SessionTimeoutWarningProps {\n  /** Idle timeout in milliseconds */\n  timeout?: number\n  /** Warning time before logout in milliseconds */\n  warningTime?: number\n}\n\nexport function SessionTimeoutWarning({\n  timeout = 15 * 60 * 1000,\n  warningTime = 2 * 60 * 1000,\n}: SessionTimeoutWarningProps) {\n  const { isWarning, remaining, stayLoggedIn, logout } = useSessionTimeout({\n    timeout,\n    warningTime,\n  })\n\n  const formatTime = (ms: number | null): string => {\n    if (ms === null) return '0:00'\n    const seconds = Math.floor(ms / 1000)\n    const mins = Math.floor(seconds / 60)\n    const secs = seconds % 60\n    return `${mins}:${secs.toString().padStart(2, '0')}`\n  }\n\n  return (\n    <AlertDialog open={isWarning}>\n      <AlertDialogContent>\n        <AlertDialogHeader>\n          <AlertDialogTitle>Session Timeout Warning</AlertDialogTitle>\n          <AlertDialogDescription>\n            Your session will expire in {formatTime(remaining)} due to inactivity.\n            Would you like to stay logged in?\n          </AlertDialogDescription>\n        </AlertDialogHeader>\n        <AlertDialogFooter>\n          <AlertDialogCancel onClick={logout}>Log Out</AlertDialogCancel>\n          <AlertDialogAction onClick={stayLoggedIn}>Stay Logged In</AlertDialogAction>\n        </AlertDialogFooter>\n      </AlertDialogContent>\n    </AlertDialog>\n  )\n}\n```\n\n### 4. Integrate with ProtectedRoute (`quikadmin-web/src/components/ProtectedRoute.tsx`)\n\nAdd the session timeout warning to ProtectedRoute:\n\n```typescript\nimport { SessionTimeoutWarning } from '@/components/features/session-timeout-warning'\n\nexport function ProtectedRoute({ children }: ProtectedRouteProps) {\n  // ... existing code ...\n\n  // User is authenticated, render the protected content with session timeout\n  return (\n    <>\n      {children}\n      <SessionTimeoutWarning timeout={15 * 60 * 1000} warningTime={2 * 60 * 1000} />\n    </>\n  )\n}\n```\n\n### 5. Add Configuration Support\n\nUpdate `quikadmin-web/src/stores/types.ts` to use the existing `sessionTimeout` field in security settings (line 280) and add environment variable support:\n\n```typescript\n// In a new config or via env:\nconst SESSION_TIMEOUT = parseInt(import.meta.env.VITE_SESSION_TIMEOUT_MS || '900000', 10) // 15 min default\nconst SESSION_WARNING = parseInt(import.meta.env.VITE_SESSION_WARNING_MS || '120000', 10) // 2 min default\n```\n\n### Key Integration Points\n\n1. **backendAuthStore.ts:68** - `lastActivity` is already tracked; useIdle will update this via `refreshTokenIfNeeded` calls on activity\n2. **backendAuthStore.ts:385-407** - `refreshTokenIfNeeded` integrates with idle detection to refresh tokens on user activity\n3. **ProtectedRoute.tsx:40** - `checkSession()` validates session; idle timeout adds automatic logout layer\n4. **api.ts:33-48** - Proactive token refresh happens on API calls; useSessionTimeout triggers on user activity\n\n### Security Considerations\n\n1. **Cross-tab sync**: Uses localStorage to sync activity across tabs, preventing logout in active tab while idle in another\n2. **Visibility change**: Handles tab switching and calculates elapsed time during hidden period\n3. **Throttled listeners**: Activity events throttled to 500ms to prevent performance issues\n4. **Token refresh integration**: Triggers `refreshTokenIfNeeded` on activity confirmation to keep session fresh",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useIdle (`quikadmin-web/src/hooks/__tests__/useIdle.test.tsx`)\n\n```typescript\nimport { renderHook, act, waitFor } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { useIdle } from '../useIdle'\n\ndescribe('useIdle', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n    localStorage.clear()\n  })\n\n  afterEach(() => {\n    vi.useRealTimers()\n  })\n\n  describe('initialization', () => {\n    it('initializes with default state (not idle)', () => {\n      const { result } = renderHook(() => useIdle())\n      expect(result.current.isIdle).toBe(false)\n      expect(result.current.lastActive).toBeLessThanOrEqual(Date.now())\n    })\n\n    it('respects initialState option', () => {\n      const { result } = renderHook(() => useIdle({ initialState: true }))\n      expect(result.current.isIdle).toBe(true)\n    })\n\n    it('sets remaining to timeout value initially', () => {\n      const { result } = renderHook(() => useIdle({ timeout: 5000 }))\n      expect(result.current.remaining).toBe(5000)\n    })\n  })\n\n  describe('idle detection', () => {\n    it('transitions to idle after timeout', async () => {\n      const onIdle = vi.fn()\n      const { result } = renderHook(() => useIdle({ timeout: 5000, onIdle }))\n\n      expect(result.current.isIdle).toBe(false)\n\n      act(() => {\n        vi.advanceTimersByTime(5000)\n      })\n\n      expect(result.current.isIdle).toBe(true)\n      expect(onIdle).toHaveBeenCalledTimes(1)\n      expect(result.current.remaining).toBeNull()\n    })\n\n    it('resets timer on user activity', async () => {\n      const { result } = renderHook(() => useIdle({ timeout: 5000 }))\n\n      act(() => {\n        vi.advanceTimersByTime(3000)\n      })\n\n      expect(result.current.isIdle).toBe(false)\n\n      // Simulate user activity\n      act(() => {\n        window.dispatchEvent(new MouseEvent('mousemove'))\n        vi.advanceTimersByTime(100) // Allow throttle\n      })\n\n      act(() => {\n        vi.advanceTimersByTime(3000)\n      })\n\n      // Should still not be idle because timer was reset\n      expect(result.current.isIdle).toBe(false)\n    })\n\n    it('calls onActive when user returns from idle', () => {\n      const onActive = vi.fn()\n      const { result } = renderHook(() => useIdle({ timeout: 5000, onActive }))\n\n      // Go idle\n      act(() => {\n        vi.advanceTimersByTime(5000)\n      })\n\n      expect(result.current.isIdle).toBe(true)\n\n      // User activity\n      act(() => {\n        window.dispatchEvent(new MouseEvent('mousemove'))\n        vi.advanceTimersByTime(600) // Past throttle\n      })\n\n      expect(result.current.isIdle).toBe(false)\n      expect(onActive).toHaveBeenCalledTimes(1)\n    })\n  })\n\n  describe('remaining time', () => {\n    it('decrements remaining time every second', () => {\n      const { result } = renderHook(() => useIdle({ timeout: 5000 }))\n\n      expect(result.current.remaining).toBe(5000)\n\n      act(() => {\n        vi.advanceTimersByTime(1000)\n      })\n\n      expect(result.current.remaining).toBe(4000)\n\n      act(() => {\n        vi.advanceTimersByTime(2000)\n      })\n\n      expect(result.current.remaining).toBe(2000)\n    })\n  })\n\n  describe('pause/resume', () => {\n    it('pauses idle detection', () => {\n      const onIdle = vi.fn()\n      const { result } = renderHook(() => useIdle({ timeout: 5000, onIdle }))\n\n      act(() => {\n        result.current.pause()\n      })\n\n      act(() => {\n        vi.advanceTimersByTime(10000)\n      })\n\n      expect(result.current.isIdle).toBe(false)\n      expect(onIdle).not.toHaveBeenCalled()\n    })\n\n    it('resumes idle detection after pause', () => {\n      const onIdle = vi.fn()\n      const { result } = renderHook(() => useIdle({ timeout: 5000, onIdle }))\n\n      act(() => {\n        result.current.pause()\n        vi.advanceTimersByTime(3000)\n        result.current.resume()\n      })\n\n      act(() => {\n        vi.advanceTimersByTime(5000)\n      })\n\n      expect(result.current.isIdle).toBe(true)\n      expect(onIdle).toHaveBeenCalled()\n    })\n  })\n\n  describe('reset', () => {\n    it('resets idle timer manually', () => {\n      const { result } = renderHook(() => useIdle({ timeout: 5000 }))\n\n      act(() => {\n        vi.advanceTimersByTime(4000)\n      })\n\n      act(() => {\n        result.current.reset()\n      })\n\n      expect(result.current.remaining).toBe(5000)\n\n      act(() => {\n        vi.advanceTimersByTime(4000)\n      })\n\n      expect(result.current.isIdle).toBe(false)\n    })\n  })\n\n  describe('cross-tab sync', () => {\n    it('syncs activity across tabs via localStorage', () => {\n      const { result } = renderHook(() => useIdle({ timeout: 5000, crossTab: true }))\n\n      act(() => {\n        vi.advanceTimersByTime(3000)\n      })\n\n      // Simulate activity from another tab\n      act(() => {\n        const event = new StorageEvent('storage', {\n          key: 'intellifill-last-activity',\n          newValue: Date.now().toString(),\n        })\n        window.dispatchEvent(event)\n      })\n\n      // Timer should be reset\n      expect(result.current.remaining).toBe(5000)\n    })\n  })\n\n  describe('visibility change', () => {\n    it('checks elapsed time when tab becomes visible', () => {\n      const onIdle = vi.fn()\n      const { result } = renderHook(() => useIdle({ timeout: 5000, onIdle }))\n\n      // Simulate tab hidden for longer than timeout\n      const mockNow = Date.now()\n      vi.spyOn(Date, 'now').mockReturnValueOnce(mockNow + 6000)\n\n      act(() => {\n        Object.defineProperty(document, 'visibilityState', {\n          value: 'visible',\n          writable: true,\n        })\n        document.dispatchEvent(new Event('visibilitychange'))\n      })\n\n      expect(onIdle).toHaveBeenCalled()\n    })\n  })\n\n  describe('cleanup', () => {\n    it('clears timers on unmount', () => {\n      const { unmount } = renderHook(() => useIdle({ timeout: 5000 }))\n\n      const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout')\n      const clearIntervalSpy = vi.spyOn(global, 'clearInterval')\n\n      unmount()\n\n      expect(clearTimeoutSpy).toHaveBeenCalled()\n      expect(clearIntervalSpy).toHaveBeenCalled()\n    })\n\n    it('removes event listeners on unmount', () => {\n      const removeEventListenerSpy = vi.spyOn(window, 'removeEventListener')\n\n      const { unmount } = renderHook(() => useIdle({ timeout: 5000 }))\n\n      unmount()\n\n      expect(removeEventListenerSpy).toHaveBeenCalledWith('mousemove', expect.any(Function))\n      expect(removeEventListenerSpy).toHaveBeenCalledWith('keydown', expect.any(Function))\n    })\n  })\n})\n```\n\n### 2. Unit Tests for useSessionTimeout (`quikadmin-web/src/hooks/__tests__/useSessionTimeout.test.tsx`)\n\n```typescript\nimport { renderHook, act, waitFor } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { useSessionTimeout } from '../useSessionTimeout'\nimport { useBackendAuthStore } from '@/stores/backendAuthStore'\n\n// Mock the auth store\nvi.mock('@/stores/backendAuthStore', () => ({\n  useBackendAuthStore: vi.fn(),\n}))\n\ndescribe('useSessionTimeout', () => {\n  const mockLogout = vi.fn()\n  const mockRefreshTokenIfNeeded = vi.fn()\n\n  beforeEach(() => {\n    vi.useFakeTimers()\n    vi.mocked(useBackendAuthStore).mockImplementation((selector) => {\n      const state = {\n        isAuthenticated: true,\n        logout: mockLogout,\n        refreshTokenIfNeeded: mockRefreshTokenIfNeeded,\n      }\n      return selector(state as any)\n    })\n  })\n\n  afterEach(() => {\n    vi.useRealTimers()\n    vi.clearAllMocks()\n  })\n\n  it('shows warning before logout', () => {\n    const onWarning = vi.fn()\n    const { result } = renderHook(() =>\n      useSessionTimeout({ timeout: 10000, warningTime: 3000, onWarning })\n    )\n\n    expect(result.current.isWarning).toBe(false)\n\n    act(() => {\n      vi.advanceTimersByTime(7500) // Past warning threshold\n    })\n\n    expect(result.current.isWarning).toBe(true)\n    expect(onWarning).toHaveBeenCalled()\n  })\n\n  it('calls logout when timeout expires', async () => {\n    const onLogout = vi.fn()\n    renderHook(() => useSessionTimeout({ timeout: 5000, onLogout }))\n\n    act(() => {\n      vi.advanceTimersByTime(5000)\n    })\n\n    expect(onLogout).toHaveBeenCalled()\n    expect(mockLogout).toHaveBeenCalled()\n  })\n\n  it('stayLoggedIn resets timer and clears warning', () => {\n    const { result } = renderHook(() =>\n      useSessionTimeout({ timeout: 10000, warningTime: 3000 })\n    )\n\n    act(() => {\n      vi.advanceTimersByTime(8000)\n    })\n\n    expect(result.current.isWarning).toBe(true)\n\n    act(() => {\n      result.current.stayLoggedIn()\n    })\n\n    expect(result.current.isWarning).toBe(false)\n    expect(mockRefreshTokenIfNeeded).toHaveBeenCalled()\n  })\n\n  it('does not run when not authenticated', () => {\n    vi.mocked(useBackendAuthStore).mockImplementation((selector) => {\n      const state = {\n        isAuthenticated: false,\n        logout: mockLogout,\n        refreshTokenIfNeeded: mockRefreshTokenIfNeeded,\n      }\n      return selector(state as any)\n    })\n\n    const onIdle = vi.fn()\n    renderHook(() => useSessionTimeout({ timeout: 5000, onLogout: onIdle }))\n\n    act(() => {\n      vi.advanceTimersByTime(10000)\n    })\n\n    expect(mockLogout).not.toHaveBeenCalled()\n  })\n})\n```\n\n### 3. Integration Tests\n\n```typescript\ndescribe('Session Timeout Integration', () => {\n  it('integrates with ProtectedRoute', async () => {\n    render(\n      <MemoryRouter>\n        <ProtectedRoute>\n          <div>Protected Content</div>\n        </ProtectedRoute>\n      </MemoryRouter>\n    )\n\n    // Verify SessionTimeoutWarning is rendered\n    // Fast-forward time to trigger warning\n    act(() => {\n      vi.advanceTimersByTime(13 * 60 * 1000) // 13 minutes\n    })\n\n    expect(screen.getByText(/session will expire/i)).toBeInTheDocument()\n  })\n\n  it('refreshes token on activity when warning is dismissed', async () => {\n    // ... test that refreshTokenIfNeeded is called\n  })\n})\n```\n\n### 4. Manual Testing Checklist\n\n1. **Basic Idle Detection**\n   - [ ] User becomes idle after configured timeout\n   - [ ] Any activity (mouse, keyboard, scroll) resets timer\n   - [ ] Warning dialog appears before logout\n\n2. **Cross-Tab Behavior**\n   - [ ] Activity in one tab resets idle timer in all tabs\n   - [ ] Logging out in one tab logs out all tabs\n\n3. **Tab Visibility**\n   - [ ] Switching tabs away and back correctly calculates elapsed time\n   - [ ] User is logged out if tab was hidden past timeout\n\n4. **Token Integration**\n   - [ ] Token is refreshed when user clicks \"Stay Logged In\"\n   - [ ] Token refresh happens on activity after near-expiry\n\n5. **Configuration**\n   - [ ] Custom timeout values work correctly\n   - [ ] Custom warning times work correctly\n   - [ ] Environment variables override defaults\n\n6. **Edge Cases**\n   - [ ] Rapid activity doesn't cause performance issues (throttling works)\n   - [ ] Component cleanup on unmount prevents memory leaks\n   - [ ] Demo mode behavior (consider if demo should have different timeout)",
        "status": "cancelled",
        "dependencies": [
          "173"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-01T13:08:55.089Z"
      },
      {
        "id": "185",
        "title": "Implement useVisibilityChange Hook for Page Visibility Optimization",
        "description": "Create a useVisibilityChange hook in quikadmin-web/src/hooks/ that detects page visibility state changes using the Page Visibility API and integrate it into useApiData.ts to pause polling/SSE connections and KnowledgeBase.tsx to pause processing status polling when the browser tab is hidden, automatically resuming when the tab becomes visible again.",
        "details": "## Implementation Details\n\n### Overview\nThe codebase has multiple polling and SSE patterns that continue running when the tab is hidden, wasting resources and API calls:\n1. **useApiData.ts:20-51** - `useRealtime()` SSE connection stays open when tab hidden\n2. **useApiData.ts:76-77** - `useStatistics()` polls every 2 minutes regardless of visibility\n3. **useApiData.ts:122-123** - `useJobs()` polls every 60 seconds\n4. **useApiData.ts:189-190** - `useQueueMetrics()` polls every 60 seconds\n5. **KnowledgeBase.tsx:222-235** - Processing status polling every 5 seconds\n6. **useJobPolling.ts:66,183** - Already uses `refetchIntervalInBackground: false` (React Query native)\n\n### 1. Create useVisibilityChange Hook (`quikadmin-web/src/hooks/useVisibilityChange.ts`)\n\n```typescript\n/**\n * Page visibility hook for pausing background work\n * @module hooks/useVisibilityChange\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react'\n\nexport type VisibilityState = 'visible' | 'hidden' | 'prerender'\n\nexport interface UseVisibilityChangeOptions {\n  /** Callback when page becomes visible */\n  onVisible?: () => void\n  /** Callback when page becomes hidden */\n  onHidden?: () => void\n  /** Initial state (defaults to current document state) */\n  initialState?: VisibilityState\n}\n\nexport interface UseVisibilityChangeReturn {\n  /** Current visibility state */\n  isVisible: boolean\n  /** Raw visibility state from document.visibilityState */\n  visibilityState: VisibilityState\n  /** Time when visibility last changed (ms since epoch) */\n  lastChangeTime: number\n  /** Duration hidden in ms (0 if currently visible) */\n  hiddenDuration: number\n}\n\n/**\n * Hook for tracking page visibility changes\n * \n * @param options - Configuration options with optional callbacks\n * @returns Visibility state and metadata\n * \n * @example\n * ```tsx\n * const { isVisible } = useVisibilityChange({\n *   onHidden: () => eventSource.close(),\n *   onVisible: () => reconnectEventSource()\n * })\n * ```\n */\nexport function useVisibilityChange(\n  options: UseVisibilityChangeOptions = {}\n): UseVisibilityChangeReturn {\n  const { onVisible, onHidden, initialState } = options\n  \n  const getInitialState = (): VisibilityState => {\n    if (initialState) return initialState\n    if (typeof document === 'undefined') return 'visible'\n    return document.visibilityState as VisibilityState\n  }\n\n  const [visibilityState, setVisibilityState] = useState<VisibilityState>(getInitialState)\n  const [lastChangeTime, setLastChangeTime] = useState<number>(() => Date.now())\n  const hiddenStartRef = useRef<number | null>(null)\n  const [hiddenDuration, setHiddenDuration] = useState<number>(0)\n  \n  // Store callbacks in refs to avoid re-subscribing\n  const onVisibleRef = useRef(onVisible)\n  const onHiddenRef = useRef(onHidden)\n  \n  useEffect(() => {\n    onVisibleRef.current = onVisible\n    onHiddenRef.current = onHidden\n  }, [onVisible, onHidden])\n\n  useEffect(() => {\n    if (typeof document === 'undefined') return\n\n    const handleVisibilityChange = () => {\n      const newState = document.visibilityState as VisibilityState\n      const now = Date.now()\n      \n      setVisibilityState(newState)\n      setLastChangeTime(now)\n\n      if (newState === 'hidden') {\n        hiddenStartRef.current = now\n        onHiddenRef.current?.()\n      } else if (newState === 'visible') {\n        if (hiddenStartRef.current) {\n          setHiddenDuration(now - hiddenStartRef.current)\n        }\n        hiddenStartRef.current = null\n        onVisibleRef.current?.()\n      }\n    }\n\n    document.addEventListener('visibilitychange', handleVisibilityChange)\n    \n    return () => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange)\n    }\n  }, [])\n\n  return {\n    isVisible: visibilityState === 'visible',\n    visibilityState,\n    lastChangeTime,\n    hiddenDuration\n  }\n}\n\n/**\n * Utility hook that pauses an interval when tab is hidden\n * Integrates with useInterval from Task 173\n * \n * @param callback - Function to call on each interval\n * @param delay - Interval in ms (null to pause)\n * @param pauseOnHidden - Whether to pause when tab is hidden (default: true)\n */\nexport function useVisibilityAwareInterval(\n  callback: () => void,\n  delay: number | null,\n  pauseOnHidden: boolean = true\n): { isPaused: boolean } {\n  const { isVisible } = useVisibilityChange()\n  const savedCallback = useRef(callback)\n  const intervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n\n  const isPaused = pauseOnHidden && !isVisible\n\n  useEffect(() => {\n    if (delay === null || isPaused) {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current)\n        intervalRef.current = null\n      }\n      return\n    }\n\n    intervalRef.current = setInterval(() => {\n      savedCallback.current()\n    }, delay)\n\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current)\n      }\n    }\n  }, [delay, isPaused])\n\n  return { isPaused }\n}\n```\n\n### 2. Update useApiData.ts - Integrate Visibility-Aware SSE\n\nModify `useRealtime()` to close SSE when hidden and reconnect when visible:\n\n```typescript\n// At top of file, add import\nimport { useVisibilityChange } from './useVisibilityChange'\n\n// Inside useRealtime function (lines 20-51)\nfunction useRealtime(onEvent?: (event: SSEEvent) => void) {\n  const eventCallback = useRef(onEvent)\n  const eventSourceRef = useRef<EventSource | null>(null)\n\n  useEffect(() => {\n    eventCallback.current = onEvent\n  }, [onEvent])\n\n  const connect = useCallback(() => {\n    if (eventSourceRef.current) return\n    \n    const sseUrl = `${API_BASE_URL}/realtime`.replace('/api/api', '/api')\n    const eventSource = new EventSource(sseUrl, { withCredentials: true })\n    eventSourceRef.current = eventSource\n\n    eventSource.onmessage = (event) => {\n      try {\n        const data: SSEEvent = JSON.parse(event.data)\n        if (eventCallback.current) {\n          eventCallback.current(data)\n        }\n      } catch (err) {\n        console.error('Failed to parse SSE event:', err)\n      }\n    }\n\n    eventSource.onerror = () => {\n      eventSource.close()\n      eventSourceRef.current = null\n    }\n  }, [])\n\n  const disconnect = useCallback(() => {\n    if (eventSourceRef.current) {\n      eventSourceRef.current.close()\n      eventSourceRef.current = null\n    }\n  }, [])\n\n  // Connect/disconnect based on visibility\n  useVisibilityChange({\n    onVisible: connect,\n    onHidden: disconnect\n  })\n\n  // Initial connection\n  useEffect(() => {\n    connect()\n    return disconnect\n  }, [connect, disconnect])\n}\n```\n\n### 3. Update useStatistics, useJobs, useQueueMetrics - Add Visibility-Aware Polling\n\nReplace `setInterval` with `useVisibilityAwareInterval`:\n\n```typescript\n// In useStatistics() - replace lines 73-78\nimport { useVisibilityAwareInterval } from './useVisibilityChange'\n\nexport function useStatistics() {\n  // ... existing state setup ...\n  \n  useEffect(() => {\n    fetchData()\n  }, [fetchData])\n\n  // Visibility-aware polling replaces setInterval\n  useVisibilityAwareInterval(fetchData, 120000, true)\n\n  return { data, loading, error, refresh: fetchData }\n}\n```\n\nApply same pattern to `useJobs()` (line 122-123) and `useQueueMetrics()` (line 189-190).\n\n### 4. Update KnowledgeBase.tsx - Visibility-Aware Processing Poll\n\nReplace lines 222-235:\n\n```typescript\nimport { useVisibilityAwareInterval } from '@/hooks/useVisibilityChange'\n\n// Replace the useEffect with polling\nconst processingIds = sources\n  .filter((s) => s.status === 'PROCESSING' || s.status === 'PENDING')\n  .map((s) => s.id)\n\nuseVisibilityAwareInterval(\n  () => {\n    processingIds.forEach((id) => refreshSource(id))\n  },\n  processingIds.length > 0 ? 5000 : null,\n  true\n)\n```\n\n### 5. Export from hooks/index.ts (if exists)\n\n```typescript\nexport { useVisibilityChange, useVisibilityAwareInterval } from './useVisibilityChange'\nexport type { UseVisibilityChangeOptions, UseVisibilityChangeReturn, VisibilityState } from './useVisibilityChange'\n```\n\n### Key Implementation Notes\n\n1. **SSR Safety**: Check `typeof document === 'undefined'` for SSR compatibility\n2. **Callback Refs**: Store callbacks in refs to avoid re-subscribing on every render\n3. **Immediate Refresh Option**: Consider calling the fetch callback immediately when tab becomes visible after being hidden for a long time\n4. **Hidden Duration Tracking**: Useful for deciding whether to refresh immediately when visible\n5. **React Query Integration**: `useJobPolling.ts` already uses `refetchIntervalInBackground: false` which is the React Query native solution - no changes needed there\n6. **Memory Leak Prevention**: Clean up event listeners and clear intervals on unmount",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useVisibilityChange (`quikadmin-web/src/hooks/__tests__/useVisibilityChange.test.tsx`)\n\n```typescript\nimport { renderHook, act } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { useVisibilityChange, useVisibilityAwareInterval } from '../useVisibilityChange'\n\n// Mock document.visibilityState\nconst mockVisibilityState = vi.fn(() => 'visible')\n\ndescribe('useVisibilityChange', () => {\n  let addEventListenerSpy: ReturnType<typeof vi.spyOn>\n  let removeEventListenerSpy: ReturnType<typeof vi.spyOn>\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    Object.defineProperty(document, 'visibilityState', {\n      get: mockVisibilityState,\n      configurable: true\n    })\n    addEventListenerSpy = vi.spyOn(document, 'addEventListener')\n    removeEventListenerSpy = vi.spyOn(document, 'removeEventListener')\n  })\n\n  afterEach(() => {\n    vi.restoreAllMocks()\n  })\n\n  it('should initialize with visible state', () => {\n    mockVisibilityState.mockReturnValue('visible')\n    const { result } = renderHook(() => useVisibilityChange())\n    \n    expect(result.current.isVisible).toBe(true)\n    expect(result.current.visibilityState).toBe('visible')\n  })\n\n  it('should register visibilitychange listener', () => {\n    renderHook(() => useVisibilityChange())\n    \n    expect(addEventListenerSpy).toHaveBeenCalledWith(\n      'visibilitychange',\n      expect.any(Function)\n    )\n  })\n\n  it('should cleanup listener on unmount', () => {\n    const { unmount } = renderHook(() => useVisibilityChange())\n    unmount()\n    \n    expect(removeEventListenerSpy).toHaveBeenCalledWith(\n      'visibilitychange',\n      expect.any(Function)\n    )\n  })\n\n  it('should call onHidden when tab becomes hidden', () => {\n    const onHidden = vi.fn()\n    renderHook(() => useVisibilityChange({ onHidden }))\n    \n    // Simulate visibility change to hidden\n    mockVisibilityState.mockReturnValue('hidden')\n    act(() => {\n      document.dispatchEvent(new Event('visibilitychange'))\n    })\n    \n    expect(onHidden).toHaveBeenCalledTimes(1)\n  })\n\n  it('should call onVisible when tab becomes visible', () => {\n    mockVisibilityState.mockReturnValue('hidden')\n    const onVisible = vi.fn()\n    const { rerender } = renderHook(() => useVisibilityChange({ onVisible }))\n    \n    // Simulate visibility change to visible\n    mockVisibilityState.mockReturnValue('visible')\n    act(() => {\n      document.dispatchEvent(new Event('visibilitychange'))\n    })\n    \n    expect(onVisible).toHaveBeenCalledTimes(1)\n  })\n\n  it('should track hidden duration', () => {\n    vi.useFakeTimers()\n    const { result } = renderHook(() => useVisibilityChange())\n    \n    // Go hidden\n    mockVisibilityState.mockReturnValue('hidden')\n    act(() => {\n      document.dispatchEvent(new Event('visibilitychange'))\n    })\n    \n    // Advance time by 5 seconds\n    vi.advanceTimersByTime(5000)\n    \n    // Go visible\n    mockVisibilityState.mockReturnValue('visible')\n    act(() => {\n      document.dispatchEvent(new Event('visibilitychange'))\n    })\n    \n    expect(result.current.hiddenDuration).toBe(5000)\n    \n    vi.useRealTimers()\n  })\n})\n\ndescribe('useVisibilityAwareInterval', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n    Object.defineProperty(document, 'visibilityState', {\n      get: () => 'visible',\n      configurable: true\n    })\n  })\n\n  afterEach(() => {\n    vi.useRealTimers()\n  })\n\n  it('should call callback at specified interval when visible', () => {\n    const callback = vi.fn()\n    renderHook(() => useVisibilityAwareInterval(callback, 1000))\n    \n    vi.advanceTimersByTime(3000)\n    \n    expect(callback).toHaveBeenCalledTimes(3)\n  })\n\n  it('should pause interval when tab is hidden', () => {\n    const callback = vi.fn()\n    let visibilityState = 'visible'\n    Object.defineProperty(document, 'visibilityState', {\n      get: () => visibilityState,\n      configurable: true\n    })\n    \n    renderHook(() => useVisibilityAwareInterval(callback, 1000))\n    \n    vi.advanceTimersByTime(2000) // 2 calls\n    \n    // Hide tab\n    visibilityState = 'hidden'\n    act(() => {\n      document.dispatchEvent(new Event('visibilitychange'))\n    })\n    \n    vi.advanceTimersByTime(3000) // Should not add more calls\n    \n    expect(callback).toHaveBeenCalledTimes(2)\n  })\n\n  it('should resume interval when tab becomes visible again', () => {\n    const callback = vi.fn()\n    let visibilityState = 'hidden'\n    Object.defineProperty(document, 'visibilityState', {\n      get: () => visibilityState,\n      configurable: true\n    })\n    \n    renderHook(() => useVisibilityAwareInterval(callback, 1000))\n    \n    vi.advanceTimersByTime(2000) // No calls while hidden\n    \n    // Show tab\n    visibilityState = 'visible'\n    act(() => {\n      document.dispatchEvent(new Event('visibilitychange'))\n    })\n    \n    vi.advanceTimersByTime(2000) // Should have 2 calls now\n    \n    expect(callback).toHaveBeenCalledTimes(2)\n  })\n\n  it('should not pause when pauseOnHidden is false', () => {\n    const callback = vi.fn()\n    let visibilityState = 'visible'\n    Object.defineProperty(document, 'visibilityState', {\n      get: () => visibilityState,\n      configurable: true\n    })\n    \n    renderHook(() => useVisibilityAwareInterval(callback, 1000, false))\n    \n    vi.advanceTimersByTime(2000)\n    \n    visibilityState = 'hidden'\n    act(() => {\n      document.dispatchEvent(new Event('visibilitychange'))\n    })\n    \n    vi.advanceTimersByTime(3000)\n    \n    expect(callback).toHaveBeenCalledTimes(5) // All 5 seconds counted\n  })\n\n  it('should stop interval when delay is null', () => {\n    const callback = vi.fn()\n    const { rerender } = renderHook(\n      ({ delay }) => useVisibilityAwareInterval(callback, delay),\n      { initialProps: { delay: 1000 as number | null } }\n    )\n    \n    vi.advanceTimersByTime(2000)\n    expect(callback).toHaveBeenCalledTimes(2)\n    \n    rerender({ delay: null })\n    \n    vi.advanceTimersByTime(3000)\n    expect(callback).toHaveBeenCalledTimes(2) // No more calls\n  })\n})\n```\n\n### 2. Integration Tests for useApiData.ts\n\n```typescript\n// In quikadmin-web/src/hooks/__tests__/useApiData.visibility.test.tsx\ndescribe('useApiData visibility integration', () => {\n  it('should disconnect SSE when tab is hidden', async () => {\n    // Mock EventSource\n    const mockClose = vi.fn()\n    global.EventSource = vi.fn().mockImplementation(() => ({\n      onmessage: null,\n      onerror: null,\n      close: mockClose\n    }))\n    \n    renderHook(() => useJobs(5)) // Uses useRealtime internally\n    \n    // Simulate tab hidden\n    act(() => {\n      Object.defineProperty(document, 'visibilityState', { \n        value: 'hidden', \n        configurable: true \n      })\n      document.dispatchEvent(new Event('visibilitychange'))\n    })\n    \n    expect(mockClose).toHaveBeenCalled()\n  })\n})\n```\n\n### 3. Manual Testing Checklist\n\n1. **SSE Connection Test**:\n   - Open Network tab in DevTools\n   - Navigate to dashboard (uses useRealtime)\n   - Switch to another tab for 30+ seconds\n   - Verify no SSE requests during hidden period\n   - Return to tab, verify SSE reconnects\n\n2. **Polling Pause Test**:\n   - Open Network tab, filter by XHR\n   - Wait to see periodic API calls (statistics, jobs, queue)\n   - Switch tabs, monitor for 2+ minutes\n   - Verify no polling requests while hidden\n   - Return to tab, verify polling resumes\n\n3. **KnowledgeBase Processing Status**:\n   - Upload a document to trigger processing\n   - While processing, switch to another tab\n   - Wait 30 seconds\n   - Verify no refresh API calls while hidden\n   - Return to tab, verify status updates resume\n\n4. **Resource Usage Verification**:\n   - Use Chrome Task Manager (Shift+Esc)\n   - With tab hidden, verify CPU usage drops\n   - Measure network requests before/after implementation",
        "status": "cancelled",
        "dependencies": [
          "173",
          "176"
        ],
        "priority": "low",
        "subtasks": [],
        "updatedAt": "2026-01-01T13:09:03.368Z"
      },
      {
        "id": "186",
        "title": "Implement useLocalStorage Hook for Form and Preference Persistence",
        "description": "Create a useLocalStorage hook in quikadmin-web/src/hooks/ that provides a reactive state synchronized with localStorage, supporting JSON serialization, cross-tab synchronization via the storage event, and SSR-safe initialization. Integrate it into theme-provider.tsx, Login.tsx (remember me), and DocumentLibrary.tsx (search history) to replace manual localStorage.getItem/setItem patterns.",
        "details": "## Implementation Details\n\n### Overview\nThe codebase has 19+ sites with manual localStorage patterns that lack reactivity, cross-tab sync, and SSR safety:\n1. **theme-provider.tsx:30** - `localStorage.getItem(storageKey) as Theme` for initial state\n2. **theme-provider.tsx:54** - `localStorage.setItem(storageKey, theme)` in setTheme callback\n3. **Login.tsx:36-41** - No localStorage for \"Remember Me\" email persistence (feature gap)\n4. **DocumentLibrary.tsx** - No search history persistence (feature gap)\n5. **stores/index.ts:94-105** - Direct localStorage access for state hydration\n\n### 1. Create useLocalStorage Hook (`quikadmin-web/src/hooks/useLocalStorage.ts`)\n\n```typescript\n/**\n * LocalStorage hook with reactive state, cross-tab sync, and SSR safety\n * @module hooks/useLocalStorage\n */\n\nimport * as React from 'react'\n\ntype SetValue<T> = T | ((prevValue: T) => T)\n\ninterface UseLocalStorageOptions<T> {\n  /** Custom serializer (default: JSON.stringify) */\n  serializer?: (value: T) => string\n  /** Custom deserializer (default: JSON.parse) */\n  deserializer?: (value: string) => T\n  /** Sync across browser tabs (default: true) */\n  syncTabs?: boolean\n  /** Log errors to console (default: false in production) */\n  logErrors?: boolean\n}\n\n/**\n * Reactive localStorage hook with cross-tab synchronization\n *\n * @param key - localStorage key\n * @param initialValue - Default value if key doesn't exist\n * @param options - Configuration options\n * @returns [storedValue, setValue, removeValue] tuple\n *\n * @example\n * ```tsx\n * // Basic usage\n * const [theme, setTheme] = useLocalStorage('theme', 'system')\n *\n * // With object value\n * const [prefs, setPrefs] = useLocalStorage('user-prefs', { darkMode: false })\n *\n * // Functional update\n * setPrefs(prev => ({ ...prev, darkMode: true }))\n *\n * // Remove value\n * const [value, setValue, removeValue] = useLocalStorage('key', 'default')\n * removeValue() // Clears from localStorage and resets to initialValue\n * ```\n */\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T,\n  options: UseLocalStorageOptions<T> = {}\n): [T, (value: SetValue<T>) => void, () => void] {\n  const {\n    serializer = JSON.stringify,\n    deserializer = JSON.parse,\n    syncTabs = true,\n    logErrors = import.meta.env.DEV,\n  } = options\n\n  // Use ref to track if we're in SSR/hydration\n  const isInitializedRef = React.useRef(false)\n\n  // Read from localStorage with SSR safety\n  const readValue = React.useCallback((): T => {\n    // SSR safety: return initial value on server\n    if (typeof window === 'undefined') {\n      return initialValue\n    }\n\n    try {\n      const item = window.localStorage.getItem(key)\n      if (item === null) {\n        return initialValue\n      }\n      return deserializer(item)\n    } catch (error) {\n      if (logErrors) {\n        console.warn(`Error reading localStorage key \"${key}\":`, error)\n      }\n      return initialValue\n    }\n  }, [key, initialValue, deserializer, logErrors])\n\n  // State to store our value\n  const [storedValue, setStoredValue] = React.useState<T>(readValue)\n\n  // Sync state on mount (handles SSR hydration mismatch)\n  React.useEffect(() => {\n    if (!isInitializedRef.current) {\n      isInitializedRef.current = true\n      const value = readValue()\n      setStoredValue(value)\n    }\n  }, [readValue])\n\n  // Return a wrapped version of useState's setter function\n  const setValue = React.useCallback(\n    (value: SetValue<T>) => {\n      try {\n        // Allow value to be a function (like useState)\n        const valueToStore = value instanceof Function ? value(storedValue) : value\n        \n        // Save to local state\n        setStoredValue(valueToStore)\n        \n        // Save to localStorage\n        if (typeof window !== 'undefined') {\n          window.localStorage.setItem(key, serializer(valueToStore))\n          \n          // Dispatch storage event for same-tab listeners\n          // (storage event only fires for other tabs by default)\n          window.dispatchEvent(\n            new StorageEvent('storage', {\n              key,\n              newValue: serializer(valueToStore),\n              storageArea: window.localStorage,\n            })\n          )\n        }\n      } catch (error) {\n        if (logErrors) {\n          console.warn(`Error setting localStorage key \"${key}\":`, error)\n        }\n      }\n    },\n    [key, storedValue, serializer, logErrors]\n  )\n\n  // Remove value from localStorage\n  const removeValue = React.useCallback(() => {\n    try {\n      if (typeof window !== 'undefined') {\n        window.localStorage.removeItem(key)\n        window.dispatchEvent(\n          new StorageEvent('storage', {\n            key,\n            newValue: null,\n            storageArea: window.localStorage,\n          })\n        )\n      }\n      setStoredValue(initialValue)\n    } catch (error) {\n      if (logErrors) {\n        console.warn(`Error removing localStorage key \"${key}\":`, error)\n      }\n    }\n  }, [key, initialValue, logErrors])\n\n  // Listen for storage changes (cross-tab sync)\n  React.useEffect(() => {\n    if (!syncTabs || typeof window === 'undefined') {\n      return\n    }\n\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key !== key || event.storageArea !== window.localStorage) {\n        return\n      }\n\n      try {\n        if (event.newValue === null) {\n          setStoredValue(initialValue)\n        } else {\n          setStoredValue(deserializer(event.newValue))\n        }\n      } catch (error) {\n        if (logErrors) {\n          console.warn(`Error parsing storage event for \"${key}\":`, error)\n        }\n      }\n    }\n\n    window.addEventListener('storage', handleStorageChange)\n    return () => window.removeEventListener('storage', handleStorageChange)\n  }, [key, initialValue, deserializer, syncTabs, logErrors])\n\n  return [storedValue, setValue, removeValue]\n}\n\n/**\n * useLocalStorage variant with lazy initial value (for expensive computations)\n */\nexport function useLocalStorageLazy<T>(\n  key: string,\n  initializer: () => T,\n  options?: UseLocalStorageOptions<T>\n): [T, (value: SetValue<T>) => void, () => void] {\n  const initialValue = React.useMemo(initializer, [])\n  return useLocalStorage(key, initialValue, options)\n}\n```\n\n### 2. Refactor theme-provider.tsx (lines 29-56)\n\n```typescript\n// Before (lines 29-31):\nconst [theme, setTheme] = useState<Theme>(\n  () => (localStorage.getItem(storageKey) as Theme) || defaultTheme\n)\n\n// After:\nimport { useLocalStorage } from '@/hooks/useLocalStorage'\n\nconst [theme, setThemeStorage] = useLocalStorage<Theme>(storageKey, defaultTheme)\n\n// And replace lines 51-57:\nconst value = {\n  theme,\n  setTheme: setThemeStorage, // Now reactive and syncs across tabs\n}\n```\n\n### 3. Add Remember Me Persistence to Login.tsx (lines 36-41)\n\n```typescript\n// Current (no persistence):\nconst [formData, setFormData] = useState({\n  email: '',\n  password: '',\n  companySlug: '',\n  rememberMe: false,\n});\n\n// After:\nimport { useLocalStorage } from '@/hooks/useLocalStorage'\n\n// Persist remembered email separately (never persist password)\nconst [rememberedEmail, setRememberedEmail] = useLocalStorage<string>('intellifill-remembered-email', '')\n\nconst [formData, setFormData] = useState({\n  email: rememberedEmail,\n  password: '',\n  companySlug: '',\n  rememberMe: rememberedEmail !== '',\n});\n\n// In handleSubmit success block:\nif (formData.rememberMe) {\n  setRememberedEmail(formData.email)\n} else {\n  setRememberedEmail('')\n}\n```\n\n### 4. Add Search History to DocumentLibrary.tsx\n\n```typescript\n// Add after line 51:\nimport { useLocalStorage } from '@/hooks/useLocalStorage'\n\n// Inside DocumentLibrary component, after line 100:\nconst [searchHistory, setSearchHistory] = useLocalStorage<string[]>(\n  'intellifill-doc-search-history',\n  []\n)\n\n// Add search to history on successful filter (in the debounce effect):\nReact.useEffect(() => {\n  if (debouncedSearch && debouncedSearch.length >= 3) {\n    setSearchHistory(prev => {\n      const filtered = prev.filter(s => s !== debouncedSearch)\n      return [debouncedSearch, ...filtered].slice(0, 10) // Keep last 10\n    })\n  }\n}, [debouncedSearch, setSearchHistory])\n\n// Optionally display search history dropdown in search input\n```\n\n### 5. Create Type-Safe Specialized Hooks\n\n```typescript\n// In useLocalStorage.ts, add convenience hooks:\n\n/** Theme persistence hook */\nexport function useThemeStorage(defaultTheme: 'light' | 'dark' | 'system' = 'system') {\n  return useLocalStorage<'light' | 'dark' | 'system'>('pdf-filler-theme', defaultTheme)\n}\n\n/** Search history with max items */\nexport function useSearchHistory(key: string, maxItems: number = 10) {\n  const [history, setHistory, clearHistory] = useLocalStorage<string[]>(key, [])\n  \n  const addToHistory = React.useCallback((term: string) => {\n    if (!term || term.length < 2) return\n    setHistory(prev => {\n      const filtered = prev.filter(s => s.toLowerCase() !== term.toLowerCase())\n      return [term, ...filtered].slice(0, maxItems)\n    })\n  }, [setHistory, maxItems])\n  \n  const removeFromHistory = React.useCallback((term: string) => {\n    setHistory(prev => prev.filter(s => s !== term))\n  }, [setHistory])\n  \n  return { history, addToHistory, removeFromHistory, clearHistory }\n}\n```\n\n### 6. Update Hooks Index (Create `quikadmin-web/src/hooks/index.ts`)\n\n```typescript\n// Re-export all hooks for cleaner imports\nexport * from './useDebounce'\nexport * from './useLocalStorage'\n// ... other hooks as they're created\n```\n\n### Integration Notes\n\n1. **SSR Safety**: The hook uses `typeof window === 'undefined'` checks and delayed hydration to prevent SSR mismatches\n2. **Cross-Tab Sync**: Uses the `storage` event with synthetic events for same-tab updates\n3. **JSON Serialization**: Handles objects/arrays automatically with customizable serializer\n4. **Error Handling**: Graceful fallback to initialValue on parse errors with optional logging\n5. **Functional Updates**: Supports `setValue(prev => newValue)` pattern like useState\n6. **Memory Cleanup**: Properly removes event listeners on unmount",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useLocalStorage (`quikadmin-web/src/hooks/__tests__/useLocalStorage.test.tsx`)\n\n```typescript\nimport { renderHook, act, waitFor } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { useLocalStorage, useSearchHistory } from '../useLocalStorage'\n\n// Mock localStorage\nconst localStorageMock = (() => {\n  let store: Record<string, string> = {}\n  return {\n    getItem: vi.fn((key: string) => store[key] ?? null),\n    setItem: vi.fn((key: string, value: string) => { store[key] = value }),\n    removeItem: vi.fn((key: string) => { delete store[key] }),\n    clear: vi.fn(() => { store = {} }),\n  }\n})()\n\nObject.defineProperty(window, 'localStorage', { value: localStorageMock })\n\ndescribe('useLocalStorage', () => {\n  beforeEach(() => {\n    localStorageMock.clear()\n    vi.clearAllMocks()\n  })\n\n  // === BASIC FUNCTIONALITY ===\n  \n  it('returns initial value when localStorage is empty', () => {\n    const { result } = renderHook(() => useLocalStorage('test-key', 'default'))\n    expect(result.current[0]).toBe('default')\n  })\n\n  it('reads existing value from localStorage', () => {\n    localStorageMock.setItem('test-key', JSON.stringify('stored-value'))\n    const { result } = renderHook(() => useLocalStorage('test-key', 'default'))\n    expect(result.current[0]).toBe('stored-value')\n  })\n\n  it('updates localStorage when setValue is called', () => {\n    const { result } = renderHook(() => useLocalStorage('test-key', 'default'))\n    \n    act(() => {\n      result.current[1]('new-value')\n    })\n\n    expect(result.current[0]).toBe('new-value')\n    expect(localStorageMock.setItem).toHaveBeenCalledWith('test-key', '\"new-value\"')\n  })\n\n  it('supports functional updates like useState', () => {\n    const { result } = renderHook(() => useLocalStorage('counter', 0))\n    \n    act(() => {\n      result.current[1](prev => prev + 1)\n    })\n    \n    expect(result.current[0]).toBe(1)\n    \n    act(() => {\n      result.current[1](prev => prev + 5)\n    })\n    \n    expect(result.current[0]).toBe(6)\n  })\n\n  it('removes value with removeValue and resets to initial', () => {\n    const { result } = renderHook(() => useLocalStorage('test-key', 'default'))\n    \n    act(() => {\n      result.current[1]('stored')\n    })\n    expect(result.current[0]).toBe('stored')\n    \n    act(() => {\n      result.current[2]() // removeValue\n    })\n    \n    expect(result.current[0]).toBe('default')\n    expect(localStorageMock.removeItem).toHaveBeenCalledWith('test-key')\n  })\n\n  // === JSON SERIALIZATION ===\n  \n  it('handles object values with JSON serialization', () => {\n    const initial = { theme: 'dark', fontSize: 14 }\n    const { result } = renderHook(() => useLocalStorage('prefs', initial))\n    \n    act(() => {\n      result.current[1]({ theme: 'light', fontSize: 16 })\n    })\n\n    expect(result.current[0]).toEqual({ theme: 'light', fontSize: 16 })\n    expect(localStorageMock.setItem).toHaveBeenCalledWith(\n      'prefs',\n      '{\"theme\":\"light\",\"fontSize\":16}'\n    )\n  })\n\n  it('handles array values', () => {\n    const { result } = renderHook(() => useLocalStorage('history', ['a', 'b']))\n    \n    act(() => {\n      result.current[1](prev => [...prev, 'c'])\n    })\n\n    expect(result.current[0]).toEqual(['a', 'b', 'c'])\n  })\n\n  it('handles null values', () => {\n    const { result } = renderHook(() => useLocalStorage<string | null>('nullable', null))\n    \n    expect(result.current[0]).toBeNull()\n    \n    act(() => {\n      result.current[1]('value')\n    })\n    expect(result.current[0]).toBe('value')\n    \n    act(() => {\n      result.current[1](null)\n    })\n    expect(result.current[0]).toBeNull()\n  })\n\n  // === ERROR HANDLING ===\n  \n  it('returns initial value when localStorage has invalid JSON', () => {\n    localStorageMock.getItem.mockReturnValueOnce('invalid-json{')\n    const { result } = renderHook(() => useLocalStorage('broken', 'fallback'))\n    expect(result.current[0]).toBe('fallback')\n  })\n\n  it('handles localStorage quota exceeded gracefully', () => {\n    localStorageMock.setItem.mockImplementationOnce(() => {\n      throw new DOMException('QuotaExceededError')\n    })\n    \n    const { result } = renderHook(() => useLocalStorage('test', 'initial'))\n    \n    // Should not throw, state should still update locally\n    act(() => {\n      result.current[1]('large-value')\n    })\n    \n    expect(result.current[0]).toBe('large-value')\n  })\n\n  // === CROSS-TAB SYNCHRONIZATION ===\n  \n  it('updates state when storage event fires from another tab', () => {\n    const { result } = renderHook(() => useLocalStorage('shared-key', 'default'))\n    \n    act(() => {\n      window.dispatchEvent(\n        new StorageEvent('storage', {\n          key: 'shared-key',\n          newValue: '\"from-other-tab\"',\n          storageArea: localStorage,\n        })\n      )\n    })\n\n    expect(result.current[0]).toBe('from-other-tab')\n  })\n\n  it('ignores storage events for different keys', () => {\n    const { result } = renderHook(() => useLocalStorage('my-key', 'original'))\n    \n    act(() => {\n      window.dispatchEvent(\n        new StorageEvent('storage', {\n          key: 'other-key',\n          newValue: '\"should-ignore\"',\n          storageArea: localStorage,\n        })\n      )\n    })\n\n    expect(result.current[0]).toBe('original')\n  })\n\n  it('resets to initial when storage event has null newValue', () => {\n    const { result } = renderHook(() => useLocalStorage('clearable', 'initial'))\n    \n    act(() => {\n      result.current[1]('stored')\n    })\n    expect(result.current[0]).toBe('stored')\n    \n    act(() => {\n      window.dispatchEvent(\n        new StorageEvent('storage', {\n          key: 'clearable',\n          newValue: null,\n          storageArea: localStorage,\n        })\n      )\n    })\n\n    expect(result.current[0]).toBe('initial')\n  })\n\n  it('can disable cross-tab sync with syncTabs: false', () => {\n    const { result } = renderHook(() => \n      useLocalStorage('no-sync', 'initial', { syncTabs: false })\n    )\n    \n    act(() => {\n      window.dispatchEvent(\n        new StorageEvent('storage', {\n          key: 'no-sync',\n          newValue: '\"should-ignore\"',\n          storageArea: localStorage,\n        })\n      )\n    })\n\n    expect(result.current[0]).toBe('initial')\n  })\n\n  // === SSR SAFETY ===\n  \n  it('handles SSR by returning initial value when window is undefined', () => {\n    const originalWindow = global.window\n    // @ts-ignore\n    delete global.window\n    \n    const { result } = renderHook(() => useLocalStorage('ssr-key', 'ssr-safe'))\n    expect(result.current[0]).toBe('ssr-safe')\n    \n    global.window = originalWindow\n  })\n\n  // === CLEANUP ===\n  \n  it('removes event listener on unmount', () => {\n    const removeEventListenerSpy = vi.spyOn(window, 'removeEventListener')\n    const { unmount } = renderHook(() => useLocalStorage('cleanup-test', 'value'))\n    \n    unmount()\n    \n    expect(removeEventListenerSpy).toHaveBeenCalledWith('storage', expect.any(Function))\n  })\n})\n\ndescribe('useSearchHistory', () => {\n  beforeEach(() => {\n    localStorageMock.clear()\n    vi.clearAllMocks()\n  })\n\n  it('adds new search terms to history', () => {\n    const { result } = renderHook(() => useSearchHistory('doc-search'))\n    \n    act(() => {\n      result.current.addToHistory('invoice')\n    })\n    \n    expect(result.current.history).toEqual(['invoice'])\n  })\n\n  it('moves duplicate terms to the front', () => {\n    const { result } = renderHook(() => useSearchHistory('doc-search'))\n    \n    act(() => {\n      result.current.addToHistory('first')\n      result.current.addToHistory('second')\n      result.current.addToHistory('first') // duplicate\n    })\n    \n    expect(result.current.history).toEqual(['first', 'second'])\n  })\n\n  it('limits history to maxItems', () => {\n    const { result } = renderHook(() => useSearchHistory('doc-search', 3))\n    \n    act(() => {\n      result.current.addToHistory('one')\n      result.current.addToHistory('two')\n      result.current.addToHistory('three')\n      result.current.addToHistory('four')\n    })\n    \n    expect(result.current.history).toEqual(['four', 'three', 'two'])\n    expect(result.current.history).toHaveLength(3)\n  })\n\n  it('ignores empty or short terms', () => {\n    const { result } = renderHook(() => useSearchHistory('doc-search'))\n    \n    act(() => {\n      result.current.addToHistory('')\n      result.current.addToHistory('a')\n    })\n    \n    expect(result.current.history).toEqual([])\n  })\n})\n```\n\n### 2. Integration Tests for Theme Provider\n\n```typescript\n// quikadmin-web/src/components/__tests__/theme-provider.test.tsx\ndescribe('ThemeProvider with useLocalStorage', () => {\n  it('persists theme selection to localStorage')\n  it('syncs theme across tabs via storage event')\n  it('initializes with stored theme on mount')\n  it('handles system theme preference correctly')\n})\n```\n\n### 3. Integration Tests for Login Remember Me\n\n```typescript\n// quikadmin-web/src/pages/__tests__/Login.test.tsx\ndescribe('Login Remember Me', () => {\n  it('pre-fills email when remember me was checked')\n  it('clears remembered email when remember me unchecked')\n  it('persists email across page reloads')\n  it('never persists password')\n})\n```\n\n### 4. Manual Testing Checklist\n\n- [ ] **Theme Persistence**: Change theme, refresh page - theme should persist\n- [ ] **Cross-Tab Theme Sync**: Open app in two tabs, change theme in one - other tab updates\n- [ ] **Remember Me**: Login with \"remember me\" checked, logout, revisit login - email pre-filled\n- [ ] **Search History**: Search documents, refresh page - search history preserved\n- [ ] **Error Resilience**: Clear localStorage while app is open - should gracefully fallback\n- [ ] **SSR Safety**: No hydration mismatch warnings in console\n- [ ] **Memory Leaks**: Mount/unmount components repeatedly - no memory growth",
        "status": "pending",
        "dependencies": [
          "173"
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-01T16:31:54.458Z",
      "taskCount": 30,
      "completedCount": 23,
      "tags": [
        "master"
      ]
    }
  }
}