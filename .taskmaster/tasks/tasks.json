{
  "master": {
    "tasks": [
      {
        "id": "187",
        "title": "Implement JWT Secret Startup Validation",
        "description": "Add startup validation in backend config to check for JWT_SECRET and JWT_REFRESH_SECRET environment variables, fail hard if missing with clear error message and exit code 1 (REQ-004)",
        "details": "In quikadmin/src/config/index.ts, add validation function using process.env checks. Use crypto.randomBytes(64).toString('hex') as example in error message. Remove all hardcoded fallbacks from supabase-auth.routes.ts. Ensure cookie-parser@^1.4.6 is installed for cookie handling. Implementation:\n```typescript\nconst validateJWTSecrets = () => {\n  const required = ['JWT_SECRET', 'JWT_REFRESH_SECRET'];\n  for (const key of required) {\n    if (!process.env[key] || process.env[key].length < 64) {\n      console.error(`FATAL: ${key} not set or too short. Set ${key}=<64+ char random string like ${crypto.randomBytes(64).toString('hex').slice(0,32)}...>`);\n      process.exit(1);\n    }\n  }\n};\nvalidateJWTSecrets();\n``` Call at app startup before routes. Update .env.example with both vars.",
        "testStrategy": "Unit test config validation: mock missing env vars → expect exit(1) and correct error message. Integration test: start server without env vars → verify crash with correct log. Test with valid 64+ char secrets → server starts successfully.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add JWT secrets validation function to config",
            "description": "Create validateJWTSecrets function in quikadmin/src/config/index.ts that checks for JWT_SECRET and JWT_REFRESH_SECRET environment variables",
            "dependencies": [],
            "details": "Implement the provided code snippet using process.env checks and crypto.randomBytes(64).toString('hex') for error message example. Ensure function validates length >= 64 characters.",
            "status": "pending",
            "testStrategy": "Unit test: mock missing/invalid env vars → verify console.error called and process.exit(1) triggered",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Call validation function at app startup",
            "description": "Invoke validateJWTSecrets() at the earliest point in app startup before any routes are registered",
            "dependencies": [1],
            "details": "Add validateJWTSecrets(); call in the main server startup sequence, ideally right after environment loading but before express app initialization and route mounting.",
            "status": "pending",
            "testStrategy": "Integration test: start server without env vars → verify immediate crash with exit code 1 and correct error message",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Remove hardcoded JWT fallbacks from routes",
            "description": "Eliminate all hardcoded JWT secret fallbacks from supabase-auth.routes.ts file",
            "dependencies": [1],
            "details": "Search for and remove any default/fallback JWT_SECRET or JWT_REFRESH_SECRET values in supabase-auth.routes.ts. Ensure the app now strictly requires environment variables.",
            "status": "pending",
            "testStrategy": "Code review: verify no hardcoded secrets remain. Test startup without env vars → confirm proper validation failure",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Install and configure cookie-parser dependency",
            "description": "Add cookie-parser@^1.4.6 to package.json and ensure it's properly imported for cookie handling",
            "dependencies": [],
            "details": "Run npm install cookie-parser@^1.4.6. Verify it's imported and initialized in the main express app with app.use(cookieParser()).",
            "status": "pending",
            "testStrategy": "Verify package.json includes correct version. Test cookie reading in auth routes → confirm req.cookies works correctly",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update .env.example with required JWT variables",
            "description": "Add JWT_SECRET and JWT_REFRESH_SECRET entries to .env.example with generation instructions",
            "dependencies": [1],
            "details": "Include both variables in .env.example file with comments explaining they must be 64+ character random strings generated via crypto.randomBytes(64).toString('hex').",
            "status": "pending",
            "testStrategy": "Manual verification: check .env.example contains both vars with proper instructions and example generation command",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T11:23:18.134Z"
      },
      {
        "id": "188",
        "title": "Standardize localStorage Keys and Add Migration",
        "description": "Consolidate all localStorage keys to 'intellifill-backend-auth' and add one-time migration from old keys (REQ-002)",
        "details": "In stores/index.ts and migrationUtils.ts, standardize to single key. Add migration logic:\n```typescript\nconst migrateAuthStorage = () => {\n  const oldKeys = ['intellifill-auth', 'auth-storage'];\n  const newKey = 'intellifill-backend-auth';\n  for (const oldKey of oldKeys) {\n    if (localStorage.getItem(oldKey)) {\n      localStorage.setItem(newKey, localStorage.getItem(oldKey)!);\n      localStorage.removeItem(oldKey);\n    }\n  }\n  localStorage.removeItem('migration-complete');\n};\n// Call once on first app load\nif (!localStorage.getItem('migration-complete')) {\n  migrateAuthStorage();\n  localStorage.setItem('migration-complete', 'true');\n}\n``` Update all cleanup/export functions to use new key. Remove refreshToken from Zustand partialize.",
        "testStrategy": "Unit tests: simulate old keys → verify migration to new key and cleanup. E2E test: populate old keys → reload → verify data in new key only. Test idempotency: run migration twice → no data loss.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create migrationUtils.ts with migrateAuthStorage function",
            "description": "Implement the migration logic to copy data from old keys to new key and clean up old keys.",
            "dependencies": [],
            "details": "Create migrationUtils.ts file with the provided migrateAuthStorage function that handles oldKeys ['intellifill-auth', 'auth-storage'] to 'intellifill-backend-auth'. Include removal of 'migration-complete' flag. Ensure safe handling with null checks.",
            "status": "pending",
            "testStrategy": "Unit test: mock localStorage with old keys → verify data copied to new key and old keys removed.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add one-time migration trigger in app initialization",
            "description": "Call migration logic once on first app load using migration-complete flag.",
            "dependencies": [1],
            "details": "In stores/index.ts or main app entry, add the check: if (!localStorage.getItem('migration-complete')) { migrateAuthStorage(); localStorage.setItem('migration-complete', 'true'); }. Place at earliest app initialization point.",
            "status": "pending",
            "testStrategy": "Unit test: simulate first load → verify migration runs once; second load → verify skipped.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update stores/index.ts to use new localStorage key",
            "description": "Replace all instances of old localStorage keys with 'intellifill-backend-auth' in stores/index.ts.",
            "dependencies": [1],
            "details": "Search and replace all getItem/setItem/removeItem calls using old keys with the new unified key 'intellifill-backend-auth'. Update any Zustand persist configurations to use the new name.",
            "status": "pending",
            "testStrategy": "Unit test: verify store persistence reads/writes only new key after migration.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update cleanup and export functions to use new key",
            "description": "Modify all cleanup/export functions throughout codebase to reference the standardized key.",
            "dependencies": [1, 3],
            "details": "Globally update logout, session clear, data export functions to use 'intellifill-backend-auth'. Ensure no references to old keys remain in cleanup logic. Check auth-related utilities.",
            "status": "pending",
            "testStrategy": "Integration test: trigger logout → verify only new key cleared, no old keys remain.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Remove refreshToken from Zustand partialize configuration",
            "description": "Update backendAuthStore to exclude refreshToken from localStorage persistence.",
            "dependencies": [1, 3],
            "details": "In backendAuthStore.ts, modify persist partialize to include only { user, accessToken, tokenExpiresAt }. Ensure refreshToken cleared on login/refresh and stored only in cookies.",
            "status": "pending",
            "testStrategy": "E2E test: login → verify no refreshToken in localStorage, session works on reload via cookie.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-02T11:24:27.217Z"
      },
      {
        "id": "189",
        "title": "Fix Session Initialization Race Conditions",
        "description": "Refactor initialization to run only once using useRef flag and useCallback memoization (REQ-003)",
        "details": "In App.tsx and ProtectedRoute.tsx, use useRef for initialization flag:\n```typescript\nconst initRef = useRef(false);\nconst initialize = useCallback(async () => {\n  if (initRef.current) return;\n  initRef.current = true;\n  try {\n    await initializeStores();\n  } finally {\n    initRef.current = false;\n  }\n}, []);\nuseEffect(() => {\n  initialize();\n}, [initialize]);\n``` Remove duplicate calls from ProtectedRoute.tsx. Use existing useIsMounted hook to prevent state updates after unmount. Add console.warn if duplicate detected.",
        "testStrategy": "E2E test: rapid page reloads (10x) → verify single /api/auth/v2/me call per reload. Console log analysis: no race warnings. Network tab: no duplicate API calls.",
        "priority": "high",
        "dependencies": ["188"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement useRef flag in App.tsx",
            "description": "Add useRef initialization flag and memoized initialize function in App.tsx to prevent multiple initialization calls",
            "dependencies": [],
            "details": "Use provided code pattern: create initRef = useRef(false), useCallback for initialize() with early return if initRef.current true, set true before await initializeStores(), false in finally block. Add useEffect to trigger initialize.",
            "status": "pending",
            "testStrategy": "Verify console shows no duplicate warnings during rapid re-renders. Check network tab for single /api/auth/v2/me call.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Integrate useIsMounted hook in App.tsx",
            "description": "Wrap initialization logic with existing useIsMounted hook to prevent state updates after component unmount",
            "dependencies": [1],
            "details": "Import useIsMounted from hooks library. Use useIsMountedEffect or similar wrapper around state updates in initialize function to avoid memory leaks and stale updates.",
            "status": "pending",
            "testStrategy": "Unmount component during initialization → verify no React warnings about updating unmounted component.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add duplicate detection warning in App.tsx",
            "description": "Implement console.warn logging when duplicate initialization attempts are detected",
            "dependencies": [1],
            "details": "In initialize useCallback, add console.warn('Duplicate initialization detected') when initRef.current is already true before returning early. Include timestamp and component name.",
            "status": "pending",
            "testStrategy": "Trigger multiple concurrent initialize calls → verify warning appears exactly once per duplicate attempt.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Remove initialization from ProtectedRoute.tsx",
            "description": "Eliminate all duplicate initializeStores() calls from ProtectedRoute.tsx",
            "dependencies": [1],
            "details": "Search for initializeStores(), useEffect with initialization, or similar patterns in ProtectedRoute.tsx. Remove completely since App.tsx now handles centralized initialization.",
            "status": "pending",
            "testStrategy": "Verify ProtectedRoute.tsx contains no initializeStores() calls. Test navigation → single API call from App.tsx only.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "E2E test session initialization race conditions",
            "description": "Create E2E tests for rapid page reloads verifying single initialization per reload",
            "dependencies": [1, 2, 3, 4],
            "details": "Write Playwright test: 10x rapid page reloads, expect exactly 1 /api/auth/v2/me call per reload cycle. Verify no console warnings. Check network tab for no duplicates.",
            "status": "pending",
            "testStrategy": "Run test suite → verify passes consistently across browsers. Test edge cases: network failure, slow initialization, concurrent navigation.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "190",
        "title": "Implement Token Validation on Rehydration",
        "description": "Modify onRehydrateStorage to automatically call initialize() for backend validation (REQ-001)",
        "details": "In backendAuthStore.ts Zustand store:\n```typescript\nconst useBackendAuthStore = create<BackendAuthState>()(\n  persist(\n    // store config\n    {\n      onRehydrateStorage: (state) => {\n        return (state, error) => {\n          if (!error && state) {\n            initialize(); // Auto-validate with backend\n          }\n        };\n      },\n    },\n    { name: 'intellifill-backend-auth' }\n  )\n);\n``` Add loading state during validation. Implement 10s timeout using existing useTimeout hook.",
        "testStrategy": "E2E test: login → page reload → verify /api/auth/v2/me called → dashboard shown (valid token) or login shown (invalid). Verify loading spinner during validation.",
        "priority": "high",
        "dependencies": ["188", "189"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add loading state to BackendAuthState interface",
            "description": "Extend the BackendAuthState TypeScript interface to include a loading boolean property for tracking rehydration validation status.",
            "dependencies": [],
            "details": "In backendAuthStore.ts, update the BackendAuthState interface to include `loading: boolean` with initial value false. This enables components to show loading spinner during token validation.",
            "status": "pending",
            "testStrategy": "Unit test: Verify interface includes loading property and initial state is false.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update onRehydrateStorage to set loading state",
            "description": "Modify the onRehydrateStorage callback to set loading state to true before calling initialize() and handle the complete callback.",
            "dependencies": [1],
            "details": "In the onRehydrateStorage return function, add `set({ loading: true })` before `initialize()`, then in initialize() completion/error handlers set `loading: false`. Ensure both success and error paths clear loading state.",
            "status": "pending",
            "testStrategy": "Unit test: Mock rehydration → verify loading becomes true → mock initialize complete → verify loading false.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate useTimeout hook for 10s validation timeout",
            "description": "Implement 10-second timeout logic using the existing useTimeout hook to force logout if backend validation doesn't complete.",
            "dependencies": [2],
            "details": "In the store, create a timeout mechanism that calls logout() after 10s if loading is still true. Use useTimeout hook pattern adapted for Zustand store context, clearing timeout on validation complete.",
            "status": "pending",
            "testStrategy": "Unit test: Mock initialize delay >10s → verify timeout triggers logout and loading cleared.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update initialize() to handle loading state management",
            "description": "Modify the existing initialize() function to accept and manage the store's loading state in its success/error callbacks.",
            "dependencies": [2],
            "details": "Pass store setter to initialize() or use getState/set from Zustand context. Ensure initialize() completion (success or /api/auth/v2/me failure) calls set({ loading: false }) regardless of validation outcome.",
            "status": "pending",
            "testStrategy": "Integration test: Call initialize() → verify loading toggles correctly on success and 401 error paths.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add E2E test for rehydration token validation flow",
            "description": "Create end-to-end test verifying the complete rehydration validation flow including loading state and timeout.",
            "dependencies": [3],
            "details": "E2E test sequence: 1) Login with valid token 2) Page reload 3) Verify loading spinner appears 4) Verify /api/auth/v2/me called 5) Verify dashboard for valid token or login for invalid 6) Test 10s timeout → login screen.",
            "status": "pending",
            "testStrategy": "Cypress/Playwright: Test valid token → dashboard + loading spinner. Test expired token → login screen. Test network timeout → login after 10s.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "191",
        "title": "Add Initialization Timeout Guard",
        "description": "Wrap initialize() with 10-second timeout using useTimeout hook (REQ-008)",
        "details": "In ProtectedRoute.tsx:\n```typescript\nconst { startTimeout, isTimingOut, resetTimeout } = useTimeout(10000, () => {\n  toast.error('Session initialization timed out. Please check your connection and try again.', {\n    action: { label: 'Retry', onClick: () => window.location.reload() }\n  });\n});\nuseEffect(() => {\n  startTimeout();\n  initialize().finally(() => resetTimeout());\n}, []);\nif (isLoading || isTimingOut) return <LoadingSpinner message={isTimingOut ? 'Initializing...' : 'Validating session...'} />;\n``` Use existing hooks library useTimeout.",
        "testStrategy": "E2E test: mock slow backend (>10s) → verify timeout error and retry button. Test fast init (<2s) → no timeout. Test retry → reinitializes successfully.",
        "priority": "high",
        "dependencies": ["189", "190"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Import useTimeout hook",
            "description": "Add the useTimeout hook import statement to ProtectedRoute.tsx from the existing hooks library.",
            "dependencies": [],
            "details": "Add import at the top of ProtectedRoute.tsx: import { useTimeout } from '@/hooks/useTimeout'; or wherever the existing hooks library exports it. Verify the exact import path matches project structure.",
            "status": "pending",
            "testStrategy": "Verify no TypeScript import errors in IDE. Check bundle includes hook without tree-shaking issues.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add useTimeout hook declaration",
            "description": "Declare the useTimeout hook with 10-second timeout and toast error callback in ProtectedRoute.tsx component.",
            "dependencies": [1],
            "details": "Add exactly this code: const { startTimeout, isTimingOut, resetTimeout } = useTimeout(10000, () => { toast.error('Session initialization timed out. Please check your connection and try again.', { action: { label: 'Retry', onClick: () => window.location.reload() } }); }); Ensure toast is imported.",
            "status": "pending",
            "testStrategy": "Unit test: verify hook returns expected methods. Console log hook values on render.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Wrap initialize() call with timeout logic",
            "description": "Create useEffect that starts timeout before initialize() and resets it after completion using finally().",
            "dependencies": [2],
            "details": "Add useEffect: useEffect(() => { startTimeout(); initialize().finally(() => resetTimeout()); }, []); Ensure initialize() is properly imported/available from parent task dependencies (189/190). Empty dependency array for mount-only execution.",
            "status": "pending",
            "testStrategy": "Verify useEffect runs once on mount. Check initialize() called after startTimeout(). Console log sequence.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update loading spinner condition",
            "description": "Modify loading spinner render condition to show during isLoading OR isTimingOut states.",
            "dependencies": [3],
            "details": "Replace existing loading condition with: if (isLoading || isTimingOut) return <LoadingSpinner message={isTimingOut ? 'Initializing...' : 'Validating session...'} />; Ensure LoadingSpinner component handles both messages correctly.",
            "status": "pending",
            "testStrategy": "Manual test: trigger both isLoading=true and isTimingOut=true states, verify correct messages display.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add E2E timeout tests",
            "description": "Implement comprehensive E2E tests for timeout scenarios including slow backend, fast init, and retry functionality.",
            "dependencies": [4],
            "details": "Create Cypress/Playwright tests: 1) Mock backend >10s → verify timeout toast + retry button appears. 2) Fast init <2s → no timeout. 3) Click retry → page reloads and reinitializes. Use network throttling for slow backend simulation.",
            "status": "pending",
            "testStrategy": "E2E: Mock slow backend (>10s) → verify timeout error and retry button. Test fast init (<2s) → no timeout. Test retry → reinitializes successfully. Network tab verification.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "192",
        "title": "Fix Session Persistence E2E Test",
        "description": "Unskip and fix auth.spec.ts session persistence test (REQ-010)",
        "details": "In auth.spec.ts, unskip test and fix assertions:\n```typescript\nit('restores session on page reload', async ({ page }) => {\n  // Login\n  await login(page);\n  // Reload\n  await page.reload();\n  // Verify loading spinner shown\n  await expect(page.locator('[data-testid=\"loading-spinner\"]')).toBeVisible({ timeout: 15000 });\n  // Verify dashboard visible, no login flash\n  await expect(page.locator('[data-testid=\"dashboard\"]')).toBeVisible();\n  await expect(page.locator('[data-testid=\"login-form\"]')).not.toBeVisible();\n  // Verify /me API called\n  await expect(page.waitForResponse('/api/auth/v2/me')).toPass();\n});\n``` Mock backend to return valid session.",
        "testStrategy": "Run test suite → verify passes consistently. Test invalid token → redirects to login. Test network failure → timeout error shown.",
        "priority": "high",
        "dependencies": ["190"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Unskip the session persistence test",
            "description": "Locate the 'restores session on page reload' test in auth.spec.ts and remove the skip marker (it.skip or test.skip) to enable execution.",
            "dependencies": [],
            "details": "Search for the test by name in auth.spec.ts file. Remove .skip() call or change it.skip to it. Verify test appears in Cypress runner without skip indicator.",
            "status": "pending",
            "testStrategy": "Run Cypress test suite and confirm the test is listed as runnable, not skipped.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Set up backend mocking for /api/auth/v2/me endpoint",
            "description": "Create Cypress intercept to mock the /api/auth/v2/me response returning valid session data after login.",
            "dependencies": [1],
            "details": "Use cy.intercept('GET', '/api/auth/v2/me', { statusCode: 200, body: { user: { id: 1, email: 'test@example.com' }, token: 'valid-token' } }).as('me-api'); Ensure mock returns before page reload assertions.",
            "status": "pending",
            "testStrategy": "Verify network tab shows mocked response with 200 status and valid user data during test execution.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement and verify login + reload sequence",
            "description": "Ensure login(page) completes successfully, followed by page.reload(), then verify loading spinner visibility with 15s timeout.",
            "dependencies": [1, 2],
            "details": "Keep existing code: await login(page); await page.reload(); await expect(page.locator('[data-testid=\"loading-spinner\"]')).toBeVisible({ timeout: 15000 }); Add logging if spinner timeout occurs.",
            "status": "pending",
            "testStrategy": "Watch for spinner element appearance in test replay. Test fails if spinner never appears within timeout.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add dashboard and login form visibility assertions",
            "description": "After spinner verification, assert dashboard is visible and login form is hidden to confirm no login flash.",
            "dependencies": [1, 2, 3],
            "details": "Add assertions: await expect(page.locator('[data-testid=\"dashboard\"]')).toBeVisible(); await expect(page.locator('[data-testid=\"login-form\"]')).not.toBeVisible(); Increase timeout if elements slow to appear.",
            "status": "pending",
            "testStrategy": "Screenshot comparison: dashboard visible, login form absent. Run test 3x to verify consistency.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify /api/auth/v2/me API call and finalize test",
            "description": "Confirm the mocked /me API is called after reload using waitForResponse, then run full test suite validation.",
            "dependencies": [1, 2, 3, 4],
            "details": "Add: await expect(page.waitForResponse('/api/auth/v2/me')).toPass(); Run entire suite: npm run test:e2e. Test invalid token case separately by modifying mock to 401.",
            "status": "pending",
            "testStrategy": "Network tab: exactly one /me call post-reload. Full suite passes. Invalid token mock redirects to login form.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "193",
        "title": "Backend: Add httpOnly Cookie Support to Login/Register",
        "description": "Update login/register endpoints to set refreshToken in httpOnly cookie (REQ-005 Phase 2)",
        "details": "In supabase-auth.routes.ts, ensure cookie-parser middleware:\n```typescript\napp.use(cookieParser());\n\n// Login endpoint\napp.post('/api/auth/v2/login', async (req, res) => {\n  // ... auth logic\n  const refreshToken = await generateRefreshToken();\n  res.cookie('refreshToken', refreshToken, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'strict',\n    maxAge: 604800000, // 7 days\n    path: '/api/auth'\n  });\n  res.json({ success: true, data: { user, tokens: { accessToken, expiresIn } } });\n});\n``` Remove refreshToken from response body. Same for register endpoint.",
        "testStrategy": "Integration test: POST /login → verify Set-Cookie header with correct flags. Browser test: login → inspect cookies → verify httpOnly refreshToken present.",
        "priority": "high",
        "dependencies": ["187"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify and Add cookie-parser Middleware",
            "description": "Ensure cookie-parser middleware is properly installed and configured in the Express app before auth routes.",
            "dependencies": [],
            "details": "Check package.json for 'cookie-parser' dependency, install if missing. In main app file or routes file, add app.use(cookieParser()) before mounting supabase-auth.routes.ts. Import cookieParser from 'cookie-parser'.",
            "status": "pending",
            "testStrategy": "Verify req.cookies is available in a test route by logging req.cookies after middleware.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update Login Endpoint for httpOnly Cookie",
            "description": "Modify POST /api/auth/v2/login to set refreshToken in httpOnly cookie and remove from response body.",
            "dependencies": [1],
            "details": "In supabase-auth.routes.ts, generate refreshToken, call res.cookie('refreshToken', refreshToken, {httpOnly: true, secure: process.env.NODE_ENV === 'production', sameSite: 'strict', maxAge: 604800000, path: '/api/auth'}). Update res.json to exclude refreshToken: {success: true, data: {user, tokens: {accessToken, expiresIn}}}",
            "status": "pending",
            "testStrategy": "Integration test: POST /login with credentials → verify 200 response, Set-Cookie header contains refreshToken with httpOnly=true, secure flag correct for env, and refreshToken absent from JSON body.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update Register Endpoint for httpOnly Cookie",
            "description": "Apply identical httpOnly cookie changes to POST /api/auth/v2/register endpoint as done for login.",
            "dependencies": [1],
            "details": "Locate register endpoint in supabase-auth.routes.ts, add refreshToken cookie setting with same options as login. Remove refreshToken from response JSON body, keeping only user data and accessToken.",
            "status": "pending",
            "testStrategy": "Integration test: POST /register with user data → verify Set-Cookie header with correct flags, no refreshToken in response body, user created successfully.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Remove refreshToken from All Auth Responses",
            "description": "Audit and clean up any remaining instances where refreshToken appears in JSON responses across auth endpoints.",
            "dependencies": [2, 3],
            "details": "Search codebase for 'refreshToken' in res.json calls within auth routes. Ensure only accessToken and user data returned. Update any documentation or frontend expectations if needed.",
            "status": "pending",
            "testStrategy": "Run full auth flow tests (login/register) → grep responses for 'refreshToken' → confirm absence. Manual inspection of response schemas.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add Integration Tests for Cookie Implementation",
            "description": "Create comprehensive tests verifying cookie setting, security flags, and response changes for login/register.",
            "dependencies": [2, 3, 4],
            "details": "Use supertest for POST /login and /register tests. Assert Set-Cookie header presence, parse for httpOnly=true, secure=(env-based), sameSite=strict, maxAge=604800000. Verify 401 without creds. Browser test: login → devtools → confirm httpOnly refreshToken cookie.",
            "status": "pending",
            "testStrategy": "CI/CD tests pass: 100% coverage of cookie flags, edge cases (no creds, prod env secure=true), cross-browser cookie inspection.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "194",
        "title": "Backend: Implement Cookie-Based Refresh Endpoint",
        "description": "Update refresh endpoint to read refreshToken from cookie, not body (REQ-005 Phase 2)",
        "details": "In supabase-auth.routes.ts:\n```typescript\napp.post('/api/auth/v2/refresh', async (req, res) => {\n  const refreshToken = req.cookies.refreshToken;\n  if (!refreshToken) {\n    return res.status(401).json({ success: false, error: 'No refresh token' });\n  }\n  // Validate and rotate refresh token\n  const newTokens = await refreshSession(refreshToken);\n  res.cookie('refreshToken', newTokens.refreshToken, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'strict',\n    maxAge: 604800000,\n    path: '/api/auth'\n  });\n  res.json({ success: true, data: { tokens: { accessToken: newTokens.accessToken, expiresIn: 3600 } } });\n});\n``` Support both cookie and body during migration phase.",
        "testStrategy": "Integration test: POST /refresh with cookie → verify new accessToken and updated cookie. Test missing cookie → 401. Test expired refreshToken → 401.",
        "priority": "high",
        "dependencies": ["193"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify cookie-parser middleware configuration",
            "description": "Ensure cookie-parser middleware is properly configured in the Express app to read cookies from refresh endpoint requests.",
            "dependencies": [],
            "details": "Check that `app.use(cookieParser());` is present before auth routes in supabase-auth.routes.ts. Install cookie-parser if missing via `npm i cookie-parser`. Test cookie reading with a simple endpoint.",
            "status": "pending",
            "testStrategy": "Unit test: Mock req.cookies object and verify middleware parses correctly. Integration test: Send cookie in request and verify it's accessible in handler.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement dual refreshToken extraction logic",
            "description": "Update refresh endpoint to read refreshToken from cookie first, then fallback to request body during migration phase.",
            "dependencies": [1],
            "details": "Modify handler: `let refreshToken = req.cookies?.refreshToken || req.body?.refreshToken;`. Add validation: if (!refreshToken) return 401. Preserve existing refreshSession() call.",
            "status": "pending",
            "testStrategy": "Integration tests: 1) Cookie only → success. 2) Body only → success. 3) Both → prefers cookie. 4) Neither → 401 error.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update refresh token cookie setting with correct options",
            "description": "Ensure new refreshToken cookie is set with secure httpOnly options matching login/register endpoints.",
            "dependencies": [2],
            "details": "Use exact same cookie options as Task 193: httpOnly: true, secure: NODE_ENV==='production', sameSite: 'strict', maxAge: 604800000 (7 days), path: '/api/auth'. Clear old cookie if present.",
            "status": "pending",
            "testStrategy": "Verify Set-Cookie header contains all security flags. Test in production/staging envs for secure flag. Browser devtools: inspect cookie attributes post-refresh.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Preserve existing response format and error handling",
            "description": "Maintain backward-compatible JSON response structure and add specific error messages for missing/expired tokens.",
            "dependencies": [2],
            "details": "Response: { success: true, data: { tokens: { accessToken, expiresIn: 3600 } } }. Errors: 'No refresh token', handle refreshSession() failures with 401. Log errors for debugging.",
            "status": "pending",
            "testStrategy": "Test happy path → correct JSON structure. Test refreshSession() throws → 401 with error message. Verify expiresIn is always 3600.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add comprehensive integration tests for refresh endpoint",
            "description": "Create integration tests covering all refresh endpoint scenarios including cookie precedence and migration support.",
            "dependencies": [3],
            "details": "Use supertest: 1) Valid cookie → new tokens + updated cookie. 2) Valid body → success (migration). 3) No token → 401. 4) Expired token → 401. 5) Cookie + body → cookie wins.",
            "status": "pending",
            "testStrategy": "Full test suite with 100% coverage of endpoint logic. Mock refreshSession() for predictable responses. Test cookie flags in Set-Cookie headers. Run against staging env.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "195",
        "title": "Frontend: Remove Refresh Token from localStorage",
        "description": "Update frontend stores to exclude refreshToken from persistence (REQ-005 Phase 2)",
        "details": "In backendAuthStore.ts, update persist config:\n```typescript\nconst useBackendAuthStore = create(\n  persist(\n    (set, get) => ({\n      // state without refreshToken\n    }), {\n      name: 'intellifill-backend-auth',\n      partialize: (state) => ({ \n        user: state.user, \n        accessToken: state.accessToken, \n        tokenExpiresAt: state.tokenExpiresAt \n        // exclude refreshToken\n      })\n    }\n  )\n);\n``` Clear any existing refreshTokens on login/refresh.",
        "testStrategy": "Browser devtools: login → verify no refreshToken in localStorage, only in cookies. E2E test: page reload → session still works via cookie.",
        "priority": "high",
        "dependencies": ["188", "194"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update persist partialize config to exclude refreshToken",
            "description": "Modify the partialize function in backendAuthStore.ts to exclude refreshToken from localStorage persistence while keeping user, accessToken, and tokenExpiresAt.",
            "dependencies": [],
            "details": "Update the persist config exactly as specified: partialize: (state) => ({ user: state.user, accessToken: state.accessToken, tokenExpiresAt: state.tokenExpiresAt }) - ensure refreshToken is completely omitted from the returned object.",
            "status": "pending",
            "testStrategy": "Check store state in Redux DevTools - verify refreshToken exists in memory but is absent from partialize output.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Ensure store state definition excludes refreshToken persistence",
            "description": "Update the Zustand store creator to properly handle refreshToken in memory only, without any persistence configuration that includes it.",
            "dependencies": [1],
            "details": "In the create(persist((set, get) => ({ ... }))) - ensure the initial state shape supports refreshToken in memory but relies solely on the partialize from subtask 1 for persistence.",
            "status": "pending",
            "testStrategy": "Verify store can set/get refreshToken in memory via get().refreshToken and set({refreshToken: 'test'}) without errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Clear existing refreshTokens from localStorage on login",
            "description": "Implement cleanup logic in the login action to remove any pre-existing refreshToken from localStorage immediately upon successful login.",
            "dependencies": [1, 2],
            "details": "In the login handler: after successful login, explicitly call localStorage.removeItem('intellifill-backend-auth') or use store rehydration to overwrite with new partialized state excluding refreshToken.",
            "status": "pending",
            "testStrategy": "Manually add refreshToken to localStorage → login → verify key is cleared or overwritten without refreshToken.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Clear existing refreshTokens from localStorage on token refresh",
            "description": "Add cleanup logic in refreshTokenIfNeeded to ensure localStorage never contains refreshToken after refresh operations.",
            "dependencies": [1, 2, 3],
            "details": "In refreshTokenIfNeeded(): after successful refresh, ensure the store state update uses partialize (no manual localStorage writes) and consider explicit localStorage cleanup if legacy data exists.",
            "status": "pending",
            "testStrategy": "Trigger refresh flow → check localStorage before/after → confirm no refreshToken persists.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify implementation with browser testing and E2E validation",
            "description": "Test the complete implementation to confirm refreshToken is excluded from localStorage while session functionality remains intact.",
            "dependencies": [1, 2, 3, 4],
            "details": "Follow test strategy: Browser devtools Application tab → login → verify no refreshToken in localStorage (only cookies). Page reload → session works via cookie refresh mechanism.",
            "status": "pending",
            "testStrategy": "1. Login → DevTools → localStorage → no refreshToken. 2. Page reload → auto-refresh works. 3. E2E: simulate expiry → refresh succeeds via cookies only.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "196",
        "title": "Update Frontend Refresh Logic for Cookies",
        "description": "Modify refreshTokenIfNeeded() to send empty body (cookie auto-sent) (REQ-005 Phase 2)",
        "details": "In backendAuthStore.ts:\n```typescript\nconst refreshTokenIfNeeded = async () => {\n  if (Date.now() < get().tokenExpiresAt - 2 * 60 * 1000) return; // 2min early\n  \n  try {\n    const response = await fetch('/api/auth/v2/refresh', {\n      method: 'POST',\n      credentials: 'include', // Send cookies\n      body: JSON.stringify({}) // Empty body\n    });\n    \n    if (response.ok) {\n      const data = await response.json();\n      set({ accessToken: data.data.tokens.accessToken, tokenExpiresAt: Date.now() + data.data.tokens.expiresIn * 1000 });\n    } else {\n      logout();\n    }\n  } catch (error) {\n    toast.error('Unable to refresh session. Please save your work.', {\n      action: { label: 'Retry', onClick: () => refreshTokenIfNeeded() }\n    });\n  }\n};\n``` Always include credentials: 'include'.",
        "testStrategy": "E2E test: wait until near expiry → verify refresh called with credentials: 'include' and empty body → new accessToken received.",
        "priority": "high",
        "dependencies": ["195"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Locate and Open backendAuthStore.ts File",
            "description": "Navigate to the backendAuthStore.ts file in the project and open it in the code editor for modification.",
            "dependencies": [],
            "details": "Find the file containing the refreshTokenIfNeeded function, typically in the stores or auth directory. Verify the current implementation matches the provided code snippet with the existing body: JSON.stringify({}).",
            "status": "pending",
            "testStrategy": "Manual verification: Confirm file opens and function signature is visible.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Update refreshTokenIfNeeded Fetch Request",
            "description": "Modify the fetch call in refreshTokenIfNeeded to ensure empty body is sent with credentials: 'include'.",
            "dependencies": [1],
            "details": "Replace or confirm the fetch options: method: 'POST', credentials: 'include', body: JSON.stringify({}). Ensure no other body content is added and comment clearly indicates cookie auto-sent behavior.",
            "status": "pending",
            "testStrategy": "Unit test: Mock fetch call and verify request options include credentials: 'include' and body is '{}'.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Verify Token Parsing and State Update Logic",
            "description": "Confirm response parsing and state update logic correctly handles new access token and expiry.",
            "dependencies": [2],
            "details": "Check if (response.ok) block correctly extracts data.data.tokens.accessToken and sets tokenExpiresAt: Date.now() + data.data.tokens.expiresIn * 1000. Add comments for clarity.",
            "status": "pending",
            "testStrategy": "Unit test: Mock successful response with token data and verify set() is called with correct values.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Validate Error Handling and Logout Behavior",
            "description": "Ensure error handling in refreshTokenIfNeeded properly triggers logout and shows toast notification.",
            "dependencies": [2],
            "details": "Verify !response.ok calls logout() and catch block displays toast.error with 'Unable to refresh session. Please save your work.' and Retry action that recalls refreshTokenIfNeeded.",
            "status": "pending",
            "testStrategy": "Unit test: Mock failed response (non-ok) and error throw, verify logout() called and toast triggered.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run E2E Tests and Commit Changes",
            "description": "Execute end-to-end tests for token refresh and commit the updated backendAuthStore.ts.",
            "dependencies": [3, 4],
            "details": "Run E2E test: simulate near token expiry, verify /api/auth/v2/refresh called with credentials: 'include' and empty body, confirm new accessToken received and stored. Commit with message referencing REQ-005 Phase 2.",
            "status": "pending",
            "testStrategy": "E2E test: Wait until 2min before expiry → verify fetch request → assert new accessToken and updated tokenExpiresAt.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "197",
        "title": "Add Token Refresh Test Suite",
        "description": "Create comprehensive E2E tests for proactive/reactive refresh flows (REQ-011)",
        "details": "Create token-refresh.spec.ts:\n```typescript\n// Proactive refresh (before 2min threshold)\nit('proactively refreshes token', async ({ page }) => {\n  await mockTokenExpiry(page, Date.now() + 1 * 60 * 1000); // 1min\n  await page.waitForResponse('/api/auth/v2/refresh');\n});\n\n// Reactive refresh (401 error)\nit('reactively refreshes on 401', async ({ page }) => {\n  await mock401Response(page);\n  await expect(page.waitForResponse('/api/auth/v2/refresh')).toPass();\n});\n\n// Failed refresh → logout\nit('logs out on refresh failure', async ({ page }) => {\n  await mockRefreshFail(page);\n  await expect(page.locator('[data-testid=\"login-form\"]')).toBeVisible();\n});\n``` Test concurrent prevention using shared promise.",
        "testStrategy": "Run full test suite → all refresh scenarios pass. Verify no double refresh calls. Test edge cases: expired refresh token, network failure.",
        "priority": "medium",
        "dependencies": ["196"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create token-refresh.spec.ts file structure",
            "description": "Set up the Playwright test file with describe block, beforeEach hooks for login and initial token setup.",
            "dependencies": [],
            "details": "Create token-refresh.spec.ts with describe('Token Refresh Flows', () => { beforeEach(async ({ page }) => { await loginUser(page); await mockValidToken(page, Date.now() + 10 * 60 * 1000); }); }); Add test tags for E2E reporting.",
            "status": "pending",
            "testStrategy": "Verify file structure loads without syntax errors in Playwright test runner",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement proactive refresh test case",
            "description": "Write test for proactive token refresh triggered before 2-minute expiry threshold.",
            "dependencies": [1],
            "details": "Implement it('proactively refreshes token', async ({ page }) => { await mockTokenExpiry(page, Date.now() + 1 * 60 * 1000); await page.waitForResponse('/api/auth/v2/refresh'); expect(await getTokenExpiry(page)).toBeGreaterThan(Date.now() + 15 * 60 * 1000); }); Verify new token expiry >15min.",
            "status": "pending",
            "testStrategy": "Mock 1min expiry → verify single /refresh call → new token expiry >15min",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement reactive refresh on 401 test",
            "description": "Test automatic refresh triggered by 401 Unauthorized response on API call.",
            "dependencies": [1],
            "details": "Add it('reactively refreshes on 401', async ({ page }) => { await mock401Response(page, '/api/protected-endpoint'); await expect(page.waitForResponse('/api/auth/v2/refresh')).toPass({ timeout: 5000 }); await expect(page.waitForResponse('/api/protected-endpoint')).toPass(); }); Verify retry succeeds.",
            "status": "pending",
            "testStrategy": "Mock 401 → verify refresh called → verify retry API succeeds with 200",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement refresh failure logout test",
            "description": "Test user logout when refresh endpoint returns failure (401/500).",
            "dependencies": [1],
            "details": "Create it('logs out on refresh failure', async ({ page }) => { await mockRefreshFail(page); await expect(page.locator('[data-testid=\"login-form\"]')).toBeVisible({ timeout: 10000 }); await expect(page.locator('[data-testid=\"protected-content\"]')).toBeHidden(); }); Verify session cleared.",
            "status": "pending",
            "testStrategy": "Mock refresh 401 → verify login form visible → verify protected content hidden",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add concurrent refresh prevention test",
            "description": "Test shared promise prevents multiple simultaneous refresh calls using race condition simulation.",
            "dependencies": [2, 3],
            "details": "Implement it('prevents concurrent refresh calls', async ({ page }) => { const promises = Array(5).fill(0).map(() => mockNearExpiry(page)); await Promise.all(promises); const responses = await page.waitForResponse('/api/auth/v2/refresh', { timeout: 10000 }); expect(responses.length).toBe(1); }); Use shared promise verification.",
            "status": "pending",
            "testStrategy": "Trigger 5 concurrent expiry conditions → verify exactly 1 refresh call made",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "198",
        "title": "Implement Proactive Refresh Error Notifications",
        "description": "Show toast notifications for refresh failures with retry option (REQ-007)",
        "details": "Already partially implemented in task 196. Enhance toast:\n```typescript\nif (!response.ok || !data.success) {\n  toast.error('Session refresh failed. Save your work and retry.', {\n    id: 'refresh-error',\n    duration: 10000,\n    action: [\n      {\n        label: 'Retry',\n        onClick: () => refreshTokenIfNeeded(),\n      },\n      {\n        label: 'Logout',\n        onClick: logout,\n      },\n    ],\n  });\n  // Retry 3x with exponential backoff\n  let retries = 0;\n  const maxRetries = 3;\n  const retryWithBackoff = async () => {\n    retries++;\n    if (retries >= maxRetries) {\n      toast.error('Multiple refresh attempts failed. Logging out...', { id: 'refresh-fatal' });\n      logout();\n      return;\n    }\n    await new Promise(r => setTimeout(r, 1000 * Math.pow(2, retries)));\n    refreshTokenIfNeeded();\n  };\n}\n``` Use sonner/react-hot-toast for toasts.",
        "testStrategy": "E2E test: mock refresh failure → verify toast appears with Retry/Logout buttons. Test retry → calls refresh again. Test 3 failures → auto-logout.",
        "priority": "medium",
        "dependencies": ["196"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor Inline Retry Logic into Separate Hook",
            "description": "Extract the inline retry logic with exponential backoff into a reusable custom hook to improve code organization and testability.",
            "dependencies": [],
            "details": "Create useAutoRetryRefresh hook that handles up to 3 retries with exponential backoff (1s, 2s, 4s). Return loading state and success/failure status. Remove inline retries from the existing error handler.",
            "status": "pending",
            "testStrategy": "Unit test hook: mock refreshTokenIfNeeded failures → verify 3 retries with correct delays → verify returns failure after max retries.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Enhance Toast Notification Content and UX",
            "description": "Improve toast message clarity, add progress indication for retries, and ensure sonner/react-hot-toast best practices are followed.",
            "dependencies": [1],
            "details": "Update toast.error message to 'Session refresh failed. Auto-retrying...' with dynamic retry count. Add loading spinner during retries using toast.loading(). Ensure duration=10000 and unique IDs. Follow UX best practices: clear messaging, simple actions.",
            "status": "pending",
            "testStrategy": "Visual regression test: verify toast appears with correct message, Retry/Logout buttons, and 10s duration. Test auto-dismiss behavior.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate Auto-Retry Hook with Error Handler",
            "description": "Replace existing toast + inline retry code with the new useAutoRetryRefresh hook integration.",
            "dependencies": [1, 2],
            "details": "In refresh error block: show initial toast, then call useAutoRetryRefresh(). Update Retry button to trigger manual retry via hook. Ensure Logout action remains available. Dismiss 'refresh-error' toast on retry success.",
            "status": "pending",
            "testStrategy": "Integration test: trigger refresh failure → verify hook called → verify sequential retries → verify toast updates.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Comprehensive Error State Management",
            "description": "Implement global refresh failure state in auth store with loading indicators and user guidance.",
            "dependencies": [3],
            "details": "Add isRefreshing and refreshFailed states to backendAuthStore. Show app-wide loading overlay during retries. Display persistent banner if refresh permanently fails before auto-logout. Ensure smooth UX transitions.",
            "status": "pending",
            "testStrategy": "E2E test: refresh failure → verify loading spinner → verify banner after max retries → verify auto-logout after fatal error.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Complete E2E Test Coverage",
            "description": "Write comprehensive tests covering all refresh failure scenarios as specified in original test strategy.",
            "dependencies": [4],
            "details": "Create Cypress/Playwright tests: 1) Mock refresh failure → verify toast with Retry/Logout 2) Click Retry → verify refreshTokenIfNeeded called 3) 3 failures → verify 'refresh-fatal' toast → auto-logout. Test edge cases: network errors, 401 responses.",
            "status": "pending",
            "testStrategy": "Run full test suite: verify 100% pass rate. Test manual Retry button → single refresh call. Test Logout → immediate redirect to /login.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "199",
        "title": "Add Race Condition and Edge Case Tests",
        "description": "Add E2E tests for rapid reloads and edge cases (REQ-012, REQ-013)",
        "details": "Extend auth.spec.ts:\n```typescript\n// Race condition test\nit('handles rapid reloads without races', async ({ page, browser }) => {\n  await login(page);\n  for (let i = 0; i < 10; i++) {\n    await page.reload({ waitUntil: 'networkidle' });\n    await expect(page.locator('[data-testid=\"dashboard\"]')).toBeVisible({ timeout: 5000 });\n  }\n});\n\n// Edge cases\nit('clears invalid token', async ({ page }) => {\n  await page.addInitScript(() => {\n    localStorage.setItem('intellifill-backend-auth', JSON.stringify({ accessToken: 'invalid' }));\n  });\n  await page.goto('/');\n  await expect(page.locator('[data-testid=\"login-form\"]')).toBeVisible();\n});\n```",
        "testStrategy": "Run tests → 100% pass rate. Verify rapid reloads show no console errors. Test offline → timeout error. Test expired during session → refresh triggered.",
        "priority": "medium",
        "dependencies": ["192", "197"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Race Condition Rapid Reload Test",
            "description": "Implement the E2E test for handling rapid reloads without race conditions in auth.spec.ts as provided in the task details.",
            "dependencies": [],
            "details": "Copy the provided test code into auth.spec.ts: login, perform 10 rapid reloads with networkidle wait, verify dashboard visibility each time with 5000ms timeout. Ensure test uses Playwright fixtures page and browser.",
            "status": "pending",
            "testStrategy": "Run test 10x, verify 100% pass rate, check browser console for no race warnings or duplicate API calls to /api/auth/v2/me.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add Invalid Token Clearing Test",
            "description": "Implement the E2E test for clearing invalid tokens by simulating localStorage with invalid auth token.",
            "dependencies": [],
            "details": "Add the provided test code to auth.spec.ts: use page.addInitScript to set invalid accessToken in localStorage, goto '/', expect login-form to be visible indicating token cleared.",
            "status": "pending",
            "testStrategy": "Verify login form appears, no dashboard shown, check network tab for no successful auth calls, console shows no errors.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Offline Mode Edge Case Test",
            "description": "Create new E2E test for offline scenario where auth operations should timeout appropriately.",
            "dependencies": [1, 2],
            "details": "In auth.spec.ts, use browser.newContext({ offline: true }), attempt login or reload after login, expect timeout error on dashboard locator or API calls, timeout after 10s.",
            "status": "pending",
            "testStrategy": "Set offline context, verify timeout errors logged, no infinite hangs, test passes when expecting failure due to offline.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add Expired Token During Session Test",
            "description": "Implement test simulating token expiration mid-session triggering automatic refresh.",
            "dependencies": [1, 2],
            "details": "Mock expired token via initScript after login, perform page interaction/reload, verify refresh token call triggered and dashboard remains visible, login form does not appear.",
            "status": "pending",
            "testStrategy": "Check network tab for refresh token API call, verify single /api/auth/v2/me after refresh, no fallback to login, 100% pass rate.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Run Full Test Suite and Validate Coverage",
            "description": "Execute all auth.spec.ts tests, validate against REQ-012/REQ-013, ensure 100% pass rate and no regressions.",
            "dependencies": [1, 2, 3, 4],
            "details": "Run npx playwright test auth.spec.ts --headed, review console/network for races/duplicates/errors, update test strategy docs, commit with message referencing REQ-012, REQ-013.",
            "status": "pending",
            "testStrategy": "100% pass rate required, verify rapid reloads: single init per reload, no console errors, offline/expired handle gracefully per specs.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "200",
        "title": "Implement Token Cache Invalidation on Logout",
        "description": "Call tokenCache.invalidateToken() during logout (REQ-006)",
        "details": "In supabase-auth.routes.ts logout endpoint:\n```typescript\napp.post('/api/auth/v2/logout', async (req, res) => {\n  const refreshToken = req.cookies.refreshToken;\n  if (refreshToken) {\n    await tokenCache.invalidateToken(refreshToken); // Non-blocking\n    res.clearCookie('refreshToken');\n  }\n  res.json({ success: true });\n});\n``` Frontend logout also clears localStorage:\n```typescript\nconst logout = () => {\n  localStorage.clear();\n  window.location.href = '/login';\n};\n``` Make cache invalidation fire-and-forget with 500ms timeout.",
        "testStrategy": "Integration test: login → logout → verify cache cleared (subsequent /me calls hit Supabase). Test concurrent logouts → no errors.",
        "priority": "medium",
        "dependencies": ["194"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update logout endpoint to make invalidation non-blocking",
            "description": "Modify the backend logout endpoint to call tokenCache.invalidateToken() without awaiting it, ensuring the response is sent immediately.",
            "dependencies": [],
            "details": "In supabase-auth.routes.ts, remove 'await' from tokenCache.invalidateToken(refreshToken) to make it fire-and-forget. Keep cookie clearing and success response synchronous for fast logout.",
            "status": "pending",
            "testStrategy": "Verify endpoint responds <100ms even if cache op hangs. Test with mock slow invalidateToken() → response still fast.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement 500ms timeout wrapper for cache invalidation",
            "description": "Create a utility function that wraps tokenCache.invalidateToken() with Promise.race() to timeout after 500ms and prevent hanging requests.",
            "dependencies": [1],
            "details": "Create timeoutInvalidateToken(refreshToken) using Promise.race([tokenCache.invalidateToken(refreshToken), new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 500))]). Log timeout errors.",
            "status": "pending",
            "testStrategy": "Unit test: mock invalidateToken hanging → verify timeout fires at exactly 500ms. Test normal case → completes without timeout.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate timeout wrapper into logout endpoint",
            "description": "Replace direct cache invalidation call with the new timeout wrapper in the logout endpoint.",
            "dependencies": [2],
            "details": "Update POST /api/auth/v2/logout to use timeoutInvalidateToken(refreshToken) instead of direct call. Ensure it remains non-blocking with try-catch for timeout handling.",
            "status": "pending",
            "testStrategy": "Integration test: simulate slow cache → verify endpoint still responds fast, timeout logged but user unaffected.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Add logging for cache invalidation success/failure",
            "description": "Implement structured logging for cache invalidation attempts, timeouts, and successes during logout.",
            "dependencies": [3],
            "details": "Add console.error for timeouts with refreshToken hash (not full token), console.log for successful invalidations. Use structured format: {event: 'token_invalidation', status: 'timeout/success', tokenHash: '...'}",
            "status": "pending",
            "testStrategy": "Manual test: logout → check server logs show success. Simulate timeout → verify timeout log appears without crashing endpoint.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create integration tests for logout cache invalidation",
            "description": "Write comprehensive tests verifying cache invalidation works correctly on logout with timeout protection.",
            "dependencies": [4],
            "details": "Test suite: 1) login→logout→/me hits Supabase (cache cleared); 2) concurrent logouts (no errors); 3) slow cache simulation (timeout works); 4) no refreshToken (fast success response).",
            "status": "pending",
            "testStrategy": "Full E2E: login → logout → verify subsequent /me calls bypass cache and hit Supabase directly. Load test: 100 concurrent logouts → no errors, all caches cleared.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "201",
        "title": "Improve Loading States with Stages",
        "description": "Add substates to distinguish rehydration vs backend validation (REQ-009)",
        "details": "In store:\n```typescript\ntype LoadingStage = 'idle' | 'rehydrating' | 'validating' | 'ready';\nloadingStage: LoadingStage;\n```\nIn ProtectedRoute.tsx:\n```typescript\nconst stage = useBackendAuthStore(s => s.loadingStage);\nconst messages = {\n  rehydrating: 'Restoring session...',\n  validating: 'Validating with server...',\n  ready: 'Loading dashboard...'\n};\nreturn <LoadingSpinner message={messages[stage] || 'Loading...'} />;\n```\nUpdate initialize to set stages appropriately.",
        "testStrategy": "Manual test: page reload → verify spinner messages change: 'Restoring...' → 'Validating...' → dashboard. E2E test: verify no flash of wrong content.",
        "priority": "low",
        "dependencies": ["190", "191"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update BackendAuthStore with LoadingStage state",
            "description": "Add the LoadingStage type and loadingStage property to the Zustand store used by backend authentication.",
            "dependencies": [],
            "details": "Define type LoadingStage = 'idle' | 'rehydrating' | 'validating' | 'ready'; Add loadingStage: LoadingStage to store state. Initialize as 'idle'. Export selector useBackendAuthStore(s => s.loadingStage).",
            "status": "pending",
            "testStrategy": "Unit test: verify store initializes with loadingStage='idle', selector returns correct value.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Add stage transition actions to store",
            "description": "Create actions in the store to set loadingStage to 'rehydrating', 'validating', and 'ready'.",
            "dependencies": [1],
            "details": "Add store methods: setRehydrating(), setValidating(), setReady(). Each updates loadingStage to respective value. Ensure actions are exported from store.",
            "status": "pending",
            "testStrategy": "Unit test: call each action and verify loadingStage updates correctly in store state.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update ProtectedRoute.tsx to use staged messages",
            "description": "Modify ProtectedRoute component to read loadingStage and display appropriate spinner messages.",
            "dependencies": [1],
            "details": "Use const stage = useBackendAuthStore(s => s.loadingStage); Define messages object with rehydrating, validating, ready keys. Render <LoadingSpinner message={messages[stage] || 'Loading...'} />.",
            "status": "pending",
            "testStrategy": "Unit test: render with different stage props, verify correct message displayed in LoadingSpinner.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update initialize function with stage transitions",
            "description": "Modify the initialize function to set appropriate loading stages during rehydration and validation.",
            "dependencies": [2],
            "details": "In initialize(): setRehydrating() before local storage/session check, setValidating() before backend refresh call, setReady() on successful completion or final state.",
            "status": "pending",
            "testStrategy": "Unit test: mock initialize flow, verify actions called in sequence: rehydrating → validating → ready.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Add manual and E2E tests for loading stages",
            "description": "Implement testing strategy to verify spinner messages change correctly during page load.",
            "dependencies": [3, 4],
            "details": "Manual: page reload and check message sequence. E2E: use Cypress/Playwright to assert spinner text changes 'Restoring session...' → 'Validating with server...' → dashboard loads without wrong content flash.",
            "status": "pending",
            "testStrategy": "E2E test: intercept network calls, verify no content flash, message sequence correct. Manual verification on prod-like environment.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "202",
        "title": "Refactor to Use Existing Hooks Library",
        "description": "Replace custom logic with useTimeout, useIsMounted, useFetch from hooks library (REQ-014)",
        "details": "Audit all auth components:\n- Replace custom setTimeout with useTimeout\n- Wrap API calls with useFetch AbortController\n- Use useIsMounted for cleanup\n```typescript\nconst { data, error, isLoading } = useFetch('/api/auth/v2/me', {\n  refetchOnWindowFocus: false\n});\nuseIsMountedEffect(() => {\n  if (data) setUser(data.user);\n});\n``` Remove custom implementations, rely on hooks/index.ts.",
        "testStrategy": "Code review: verify no custom timeout/AbortController/useEffect cleanup logic remains. Component tests: verify hooks prevent memory leaks.",
        "priority": "low",
        "dependencies": ["191", "196"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit Auth Components for Custom Logic",
            "description": "Review all authentication-related components to identify custom setTimeout, AbortController, and useEffect cleanup implementations.",
            "dependencies": [],
            "details": "Scan files like Login.tsx, AuthProvider.tsx, ProtectedRoute.tsx for manual setTimeout calls, fetch with AbortController, and useEffect without proper cleanup. Document locations in a checklist.",
            "status": "pending",
            "testStrategy": "Manual code review: grep for 'setTimeout', 'AbortController', 'useEffect' in auth files.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Replace Custom setTimeout with useTimeout Hook",
            "description": "Refactor all identified custom setTimeout logic in auth components to use the useTimeout hook from hooks/index.ts.",
            "dependencies": [1],
            "details": "Import useTimeout from hooks/index.ts. Replace setTimeout(callback, delay) with useTimeout(callback, delay). Ensure proper cleanup by verifying hook handles clearTimeout internally.",
            "status": "pending",
            "testStrategy": "Component tests: Verify timeout callbacks execute after delay and are cleared on unmount. Check no memory leaks.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Refactor API Calls to Use useFetch Hook",
            "description": "Replace manual fetch calls in auth components with useFetch('/api/auth/v2/me', { refetchOnWindowFocus: false }).",
            "dependencies": [1],
            "details": "Update all auth API endpoints to useFetch pattern. Destructure { data, error, isLoading }. Remove manual AbortController and fetch logic. Handle data assignment safely.",
            "status": "pending",
            "testStrategy": "Network tab verification: Single API call per component mount. Test loading/error states render correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement useIsMounted for State Updates and Cleanup",
            "description": "Wrap all side-effect state updates in auth components with useIsMountedEffect to prevent updates on unmounted components.",
            "dependencies": [1, 3],
            "details": "Import useIsMountedEffect from hooks/index.ts. Wrap useEffect callbacks that set state: useIsMountedEffect(() => { if (data) setUser(data.user); }); Remove custom mounted flags.",
            "status": "pending",
            "testStrategy": "Unmount during async operation: Verify no React warnings about setState on unmounted component.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Remove Custom Implementations and Verify Completeness",
            "description": "Delete all custom timeout/AbortController/mounted logic. Perform final audit and update tests.",
            "dependencies": [2, 3, 4],
            "details": "Remove redundant code. Ensure hooks/index.ts provides all functionality. Run code review checklist. Update component tests to verify hooks prevent memory leaks per original test strategy.",
            "status": "pending",
            "testStrategy": "Full code review: No custom timeout/AbortController/useEffect cleanup remains. Component tests pass. E2E: Verify auth flow works without regressions.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "203",
        "title": "USER-TEST-1: User Validation Checkpoint 1",
        "description": "Manually test functionality from Tasks 187-191 (Foundation & Critical Fixes)",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": ["191"],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": "204",
        "title": "USER-TEST-2: User Validation Checkpoint 2",
        "description": "Manually test functionality from Tasks 192-196 (httpOnly Cookie Implementation)",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": ["196"],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": "205",
        "title": "USER-TEST-3: User Validation Checkpoint 3",
        "description": "Manually test functionality from Tasks 197-199 (Comprehensive Testing)",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": ["199"],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": "206",
        "title": "USER-TEST-4: User Validation Checkpoint 4",
        "description": "Manually test functionality from Tasks 200-202 (Polish & Optimization)",
        "details": "",
        "testStrategy": "",
        "status": "pending",
        "dependencies": ["202"],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-02T11:24:27.218Z",
      "taskCount": 20,
      "completedCount": 1,
      "tags": ["master"]
    }
  }
}
