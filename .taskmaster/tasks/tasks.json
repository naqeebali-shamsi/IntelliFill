{
  "master": {
    "tasks": [
      {
        "id": 157,
        "title": "Documentation Discovery and Inventory",
        "description": "Audit all existing documentation files across the IntelliFill codebase to create a comprehensive inventory of documentation assets, their locations, types, and metadata.",
        "details": "## Implementation Steps\n\n### 1. Scan All Documentation Locations\n```bash\n# Primary locations to scan\ndocs/                          # Main documentation hub (50+ files)\nCLAUDE.local.md               # Root AI context\nquikadmin/CLAUDE.md           # Backend context (1500+ lines)\nquikadmin-web/CLAUDE.md       # Frontend context (550+ lines)\n.claude/skills/               # 15 skill files\n**/README.md                  # Project READMEs\n```\n\n### 2. Create Inventory Schema\n```typescript\ninterface DocInventory {\n  path: string;\n  title: string;\n  category: 'tutorial' | 'how-to' | 'reference' | 'explanation' | 'ai-context' | 'skill';\n  format: 'markdown' | 'json';\n  lines: number;\n  lastModified: Date;\n  frontmatter: boolean;\n  crossReferences: string[];\n  status: 'active' | 'draft' | 'deprecated' | 'archived';\n}\n```\n\n### 3. Document Categories Found\n- **docs/tutorials/** - Learning-oriented (getting-started.md, first-document.md, understanding-workflow.md)\n- **docs/how-to/** - Problem-oriented (deployment, development, troubleshooting)\n- **docs/reference/** - Technical specs (api, architecture, database, configuration)\n- **docs/explanation/** - Conceptual (data-flow.md, security-model.md, architecture-decisions.md)\n- **docs/ai-development/** - AI agent guides (agentic-workflows.md, mcp-integration.md)\n- **docs/.meta/** - Templates and migration guides\n- **docs/prd/** - PRD documents\n- **docs/architecture/** - Architecture docs (dynamic-pii-architecture.md)\n- **docs/strategy/** - Go-to-market, feasibility analysis\n- **docs/claude-audit/** - Setup reports\n- **docs/debug/** - Debug evidence\n- **docs/sales/** - Sales prompts\n- **docs/tech-debt/** - Tech stability audit\n\n### 4. CLAUDE.md File Analysis\n- Root: CLAUDE.local.md (~65 lines) - concise, optimized\n- quikadmin/CLAUDE.md (~1500 lines) - comprehensive backend context\n- quikadmin-web/CLAUDE.md (~555 lines) - frontend patterns\n- quikadmin/.taskmaster/CLAUDE.md - Task Master integration\n\n### 5. Skills Directory Analysis\n15 skills covering: auth-flow, backend-api, browser-testing, docker-devops, documentation, e2e-testing, file-upload, frontend-component, frontend-design, prisma-database, queue-worker, testing, ui-components, zustand-store\n\n### 6. Output Format\nGenerate `docs/.meta/inventory.json` with complete file listing",
        "testStrategy": "1. Verify inventory captures all 50+ docs files\n2. Confirm all CLAUDE.md variants are catalogued\n3. Validate all 15 skills are documented\n4. Check inventory JSON validates against schema\n5. Cross-reference with `find docs/ -name \"*.md\" | wc -l` to ensure completeness\n6. Verify no node_modules README files are incorrectly included",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scan and Catalog All Documentation File Locations",
            "description": "Recursively scan the entire IntelliFill codebase to identify all documentation files across primary locations (docs/, CLAUDE.md files, .claude/skills/, README.md files) and capture file metadata including path, size, and modification date.",
            "dependencies": [],
            "details": "Execute a comprehensive file system scan targeting:\n- docs/ directory (55 markdown files identified)\n- Root CLAUDE.local.md\n- quikadmin/CLAUDE.md (~1500 lines)\n- quikadmin-web/CLAUDE.md (~555 lines)\n- quikadmin/.taskmaster/CLAUDE.md\n- .claude/skills/ directory (15 SKILL.md files + README.md)\n- **/README.md files (quikadmin/README.md, quikadmin-web/README.md)\n\nFor each file, capture: absolute path, filename, extension, file size in bytes, last modified timestamp. Store results in a structured format for processing in subsequent steps.",
            "status": "pending",
            "testStrategy": "Verify scan captures all 55+ docs files, 4 CLAUDE.md variants, 15 skills, and project READMEs. Cross-reference with `find docs/ -name '*.md' | wc -l` output.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Parse File Content and Extract Metadata",
            "description": "Read each catalogued documentation file to extract content metadata including YAML frontmatter, title, category, line count, presence of code examples, and internal cross-references.",
            "dependencies": [1],
            "details": "For each file from Step 1:\n1. Read file content and count lines\n2. Detect and parse YAML frontmatter (title, description, category, tags, lastUpdated, status)\n3. Identify document category using Diataxis framework: 'tutorial', 'how-to', 'reference', 'explanation', 'ai-context', 'skill'\n4. Detect code blocks (```language) and count examples\n5. Extract internal markdown links to other documentation files\n6. Identify status indicators (active, draft, deprecated, archived)\n7. Parse last updated dates from frontmatter or file metadata\n\nSkills follow SKILL.md pattern, CLAUDE.md files are ai-context category.",
            "status": "pending",
            "testStrategy": "Validate frontmatter parsing on 10 random files. Confirm all 15 skills are categorized as 'skill'. Verify CLAUDE.md files marked as 'ai-context'.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Map Cross-References and Document Relationships",
            "description": "Analyze all documentation files to build a dependency graph showing which documents reference others, identifying orphaned documents and key hub documents.",
            "dependencies": [2],
            "details": "Process extracted cross-references from Step 2:\n1. Build adjacency list of document relationships (source -> [targets])\n2. Identify hub documents with high inbound links (docs/README.md, CLAUDE.local.md)\n3. Detect orphaned documents (no inbound links except from indexes)\n4. Map the documentation reading flow as defined in docs/.meta/STRUCTURE_DIAGRAM.md\n5. Categorize relationships: 'parent-child', 'related', 'depends-on', 'summarizes'\n6. Identify broken internal links (references to non-existent files)\n7. Track external links for later validation\n\nOutput relationship data compatible with docs/.meta/relationships.json format.",
            "status": "pending",
            "testStrategy": "Verify docs/README.md shows as hub with highest inbound links. Confirm no false orphan detection for intentionally standalone files. Check relationship types are correctly classified.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Classify Documents by Diataxis Category and AI Priority",
            "description": "Apply consistent categorization to all documents using the Diataxis framework (tutorials, how-to, reference, explanation) plus AI-specific categories (ai-context, skill), and assign AI consumption priority levels.",
            "dependencies": [2],
            "details": "For each document:\n1. Assign primary Diataxis category based on path and content:\n   - docs/tutorials/* -> 'tutorial'\n   - docs/how-to/* -> 'how-to'\n   - docs/reference/* -> 'reference'\n   - docs/explanation/* -> 'explanation'\n   - docs/ai-development/* -> 'ai-development'\n   - .claude/skills/* -> 'skill'\n   - **/CLAUDE.md, CLAUDE.local.md -> 'ai-context'\n   - docs/prd/* -> 'prd'\n   - docs/architecture/* -> 'architecture'\n   - docs/strategy/* -> 'strategy'\n2. Assign AI priority level: 'critical' (CLAUDE.md, quick-start), 'important' (architecture, api), 'reference' (database, config), 'archive' (debug, claude-audit)\n3. Map to proposed structure from docs/.meta/STRUCTURE_DIAGRAM.md\n4. Flag documents needing migration to new numbered structure (00-quick-start through 06-archive)",
            "status": "pending",
            "testStrategy": "Validate all tutorials are categorized as 'tutorial'. Confirm CLAUDE.md files have 'critical' AI priority. Verify category distribution matches expected Diataxis quadrants.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Generate Inventory JSON and Summary Report",
            "description": "Compile all discovered documentation data into a structured inventory.json file and generate a human-readable summary report with statistics, category breakdowns, and actionable insights.",
            "dependencies": [3, 4],
            "details": "Generate docs/.meta/inventory.json with schema:\n```typescript\ninterface DocInventory {\n  generatedAt: string;\n  totalFiles: number;\n  files: Array<{\n    path: string;\n    title: string;\n    category: string;\n    format: 'markdown' | 'json';\n    lines: number;\n    lastModified: string;\n    hasFrontmatter: boolean;\n    crossReferences: string[];\n    status: 'active' | 'draft' | 'deprecated' | 'archived';\n    aiPriority: 'critical' | 'important' | 'reference' | 'archive';\n  }>;\n  statistics: {\n    byCategory: Record<string, number>;\n    byStatus: Record<string, number>;\n    byPriority: Record<string, number>;\n    totalLines: number;\n    avgLinesPerFile: number;\n  };\n}\n```\nAlso generate summary.md with: file counts, category distribution, CLAUDE.md stats, skills overview, and recommendations for Task 158.",
            "status": "pending",
            "testStrategy": "Validate inventory.json against defined TypeScript schema. Confirm totalFiles matches file system count. Verify summary.md includes all required sections and accurate statistics.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-30T07:58:11.578Z"
      },
      {
        "id": 158,
        "title": "Documentation Quality and Gap Analysis",
        "description": "Analyze all discovered documentation for content quality, accuracy, completeness, duplication, and identify gaps requiring attention.",
        "details": "## Implementation Steps\n\n### 1. Quality Metrics to Evaluate\n```typescript\ninterface QualityReport {\n  file: string;\n  metrics: {\n    hasYamlFrontmatter: boolean;\n    hasLastUpdated: boolean;\n    codeExamplesValid: boolean;\n    linksValid: boolean;\n    contentFreshness: 'fresh' | 'stale' | 'outdated'; // <30d, 30-90d, >90d\n    readabilityScore: number;\n  };\n  issues: string[];\n  recommendations: string[];\n}\n```\n\n### 2. Identify Duplicated Content\nKnown duplications to investigate:\n- `docs/README.md` vs `docs/MAINTENANCE.md` (overlapping update triggers)\n- `docs/reference/architecture/system-overview.md` vs content in `quikadmin/CLAUDE.md`\n- Multiple environment variable references across files\n- API endpoint documentation scattered across multiple files\n\n### 3. Check for Outdated Content\n- Compare `lastUpdated` timestamps (many files show 2025-11-25 or earlier)\n- Validate code examples against current codebase\n- Check for references to non-existent files/endpoints\n- Verify tech stack versions match package.json\n\n### 4. Identify Documentation Gaps\n- **Missing**: No dedicated troubleshooting guide for frontend\n- **Missing**: No comprehensive error codes reference\n- **Missing**: Environment-specific deployment guides incomplete\n- **Incomplete**: docs/claude-audit/ appears to be partial setup reports\n- **Incomplete**: docs/debug/ contains evidence_bundle.md only\n\n### 5. Analyze CLAUDE.md Files\n- `quikadmin/CLAUDE.md` is 1500+ lines - may be over-optimized for single file\n- Contains numbered prefix system (00-06) that doesn't match actual structure\n- References non-existent paths like `docs/00-quick-start/ai-agent-setup.md`\n\n### 6. Cross-Reference Validation\n- Check all internal markdown links resolve\n- Verify YAML frontmatter consistency\n- Validate code reference paths exist\n\n### 7. Generate Report\nCreate `docs/.meta/quality-report.md` with:\n- Summary statistics\n- High-priority issues\n- Duplication map\n- Gap analysis\n- Recommendations",
        "testStrategy": "1. Run markdown link checker on all docs\n2. Validate all code examples compile/run\n3. Verify frontmatter on random sample of 10 files\n4. Cross-check tech versions against package.json\n5. Manual review of top 5 most-referenced documents\n6. Confirm all recommended paths in CLAUDE.md exist",
        "priority": "high",
        "dependencies": ["157"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Documentation Quality Metrics Analyzer",
            "description": "Create a TypeScript script that analyzes each documentation file for quality metrics including YAML frontmatter presence, lastUpdated timestamps, content freshness classification, and generates structured quality reports.",
            "dependencies": [],
            "details": "Create `scripts/doc-quality-analyzer.ts` that:\n1. Scans all 55+ markdown files in `docs/` directory\n2. Parses YAML frontmatter to check for required fields (title, description, category, tags, lastUpdated)\n3. Classifies content freshness: 'fresh' (<30 days), 'stale' (30-90 days), 'outdated' (>90 days) based on lastUpdated\n4. Currently only 3 files have proper frontmatter - flag all others\n5. Check for valid markdown structure (headings, code blocks)\n6. Output results as JSON to `docs/.meta/quality-metrics.json` with per-file QualityReport objects\n7. Use the interface from task details: hasYamlFrontmatter, hasLastUpdated, codeExamplesValid, linksValid, contentFreshness, readabilityScore\n8. Most files currently show lastUpdated: 2025-11-25 which is stale (>30 days old)",
            "status": "pending",
            "testStrategy": "Run analyzer on `docs/` directory, verify output JSON contains entries for all 55 files, validate frontmatter detection correctly identifies the 3 files with proper frontmatter, confirm freshness classification marks 2025-11-25 files as 'stale'",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Detect and Map Duplicate Content Across Documentation",
            "description": "Analyze documentation files to identify content duplication, overlapping information, and redundant sections across the docs/ directory, quikadmin/CLAUDE.md (1500+ lines), and .claude/skills/ files.",
            "dependencies": [1],
            "details": "Create duplication analysis focusing on known overlaps:\n1. Compare `docs/README.md` update triggers table with `docs/MAINTENANCE.md` triggers (lines 19-28 vs 39-58)\n2. Analyze overlap between `docs/reference/architecture/system-overview.md` and `quikadmin/CLAUDE.md` architecture sections\n3. Find environment variable references scattered across: CLAUDE.local.md, docs/reference/configuration/environment.md, quikadmin/CLAUDE.md\n4. Check API endpoint documentation in `docs/reference/api/endpoints.md` vs `quikadmin/docs/01-current-state/api/endpoints/`\n5. Compare 15 skill files in `.claude/skills/` for overlapping patterns\n6. Use content similarity hashing or paragraph fingerprinting\n7. Output duplication map to `docs/.meta/duplication-map.json` showing file pairs, overlap percentage, and specific duplicated sections\n8. Flag `quikadmin/docs/` which has 90+ files potentially duplicating main docs/",
            "status": "pending",
            "testStrategy": "Verify duplication map identifies known duplicates (README.md vs MAINTENANCE.md table), confirm overlap detection between system-overview.md and CLAUDE.md, validate all 90+ quikadmin/docs files are analyzed for duplicates",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Validate Internal Links and Code References",
            "description": "Check all internal markdown links, code file references, and path references across documentation to identify broken links and non-existent file references.",
            "dependencies": [1],
            "details": "Create link validator that:\n1. Parse all markdown files for internal links [text](./path) and relative references\n2. Check `quikadmin/CLAUDE.md` lines 50-51 which reference `docs/00-quick-start/ai-agent-setup.md` - this path doesn't exist in current structure\n3. Validate references like `docs/01-current-state/` mentioned in CLAUDE.md exist with expected content\n4. Check `docs/.meta/STRUCTURE_DIAGRAM.md` proposed paths vs actual existing paths\n5. Verify code file references like `src/routes/auth/`, `prisma/schema.prisma` actually exist\n6. Validate cross-references in docs/README.md to ../AGENTS.md, ../CLAUDE.local.md, ../quikadmin/docs/\n7. Check that `quikadmin/docs/06-archive/` references are properly archived\n8. Output broken links report to `docs/.meta/broken-links.json` with source file, broken reference, and suggested fix\n9. Run equivalent to `npx markdown-link-check` on all 55 docs files",
            "status": "pending",
            "testStrategy": "Confirm broken link detection catches `docs/00-quick-start/ai-agent-setup.md` reference in CLAUDE.md, verify AGENTS.md reference is flagged if missing, validate all 55 docs files are scanned, ensure output includes actionable fix suggestions",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Identify Documentation Gaps and Missing Content",
            "description": "Analyze the documentation structure to identify missing guides, incomplete sections, and gaps in coverage based on codebase features and Diátaxis framework requirements.",
            "dependencies": [1, 2, 3],
            "details": "Perform gap analysis for:\n1. **Missing guides identified in task**: No frontend troubleshooting guide (only auth-issues.md, database-issues.md exist), no error codes reference, incomplete environment-specific deployment guides\n2. **Incomplete directories**: `docs/claude-audit/` has 3 partial setup reports, `docs/debug/` only has evidence_bundle.md\n3. **CLAUDE.md numbered system mismatch**: References `00-06` prefix directories but actual docs/ uses Diátaxis (tutorials/, how-to/, reference/, explanation/)\n4. Check `docs/.meta/STRUCTURE_DIAGRAM.md` proposed structure vs what actually exists\n5. Identify features in codebase not documented: Bull queues, Redis caching, Tesseract.js OCR config, pdf-lib form filling options\n6. Check if `quikadmin-web/docs/` and `quikadmin/docs/` (mentioned as having 50+ files) are properly linked\n7. Verify all 15 skill files in `.claude/skills/` have complete documentation\n8. Output gap analysis to `docs/.meta/gap-analysis.json` with priority rankings",
            "status": "pending",
            "testStrategy": "Verify gap analysis identifies frontend troubleshooting as missing, confirms claude-audit/ is incomplete, flags mismatch between numbered prefix system and actual Diátaxis structure, validates all skill files are checked",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Generate Comprehensive Quality Report with Recommendations",
            "description": "Consolidate all quality analysis findings into a comprehensive markdown report at docs/.meta/quality-report.md with summary statistics, prioritized issues, and actionable recommendations.",
            "dependencies": [1, 2, 3, 4],
            "details": "Create `docs/.meta/quality-report.md` containing:\n1. **Summary statistics**: Total files analyzed (55+ in docs/, 90+ in quikadmin/docs/), frontmatter compliance rate (currently ~5%), freshness distribution, link validity rate\n2. **High-priority issues**: Ordered list of critical problems including stale timestamps (most files 2025-11-25), missing frontmatter on 50+ files, broken internal references\n3. **Duplication map summary**: Visual table of overlapping content from subtask 2, estimated token waste from duplicates\n4. **Gap analysis summary**: Missing documentation areas with business impact assessment\n5. **CLAUDE.md analysis**: Note 1500+ line length, recommend splitting, identify invalid path references\n6. **Recommendations section**: Prioritized action items including frontmatter standardization script, link fixes, consolidation targets, archive candidates\n7. **Cross-reference tech versions**: Compare package.json versions (Node 18, Express 4.18, Prisma 6, React 18, etc.) with docs/reference/architecture/system-overview.md versions\n8. Include visual markdown tables and mermaid diagrams where helpful",
            "status": "pending",
            "testStrategy": "Review generated quality-report.md for completeness, verify all sections from implementation details are present, confirm recommendations are actionable, validate statistics match actual file counts, cross-check version numbers against package.json",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-30T08:07:47.188Z"
      },
      {
        "id": 159,
        "title": "Design Optimal Documentation Structure",
        "description": "Design an optimal folder hierarchy and organizational structure following Diataxis framework, Claude Code best practices, and token-efficient patterns for AI consumption.",
        "details": "## Implementation Steps\n\n### 1. Proposed Directory Structure\nBased on existing `.meta/STRUCTURE_DIAGRAM.md` and Diataxis framework:\n\n```\ndocs/\n├── README.md                    # Main hub (entry point)\n├── MAINTENANCE.md               # Keep - valuable maintenance guide\n│\n├── tutorials/                   # KEEP - Learning-oriented (existing)\n│   ├── README.md\n│   ├── getting-started.md\n│   ├── first-document.md\n│   └── understanding-workflow.md\n│\n├── how-to/                      # KEEP - Problem-oriented (existing)\n│   ├── README.md\n│   ├── deployment/\n│   ├── development/\n│   └── troubleshooting/\n│\n├── reference/                   # KEEP - Information-oriented (existing)\n│   ├── README.md\n│   ├── api/\n│   ├── architecture/\n│   ├── configuration/\n│   ├── database/\n│   ├── monitoring/\n│   └── security/\n│\n├── explanation/                 # KEEP - Understanding-oriented (existing)\n│   ├── README.md\n│   ├── adr/                     # Architecture Decision Records\n│   ├── data-flow.md\n│   ├── security-model.md\n│   └── architecture-decisions.md\n│\n├── ai-development/              # KEEP - AI agent guides (existing)\n│   ├── README.md\n│   ├── agentic-workflows.md\n│   └── mcp-integration.md\n│\n├── guides/                      # MOVE to how-to/ or merge\n│   └── (merge with how-to/)\n│\n├── prd/                         # KEEP - Product requirements\n├── strategy/                    # KEEP - Strategic docs\n├── decisions/                   # CONSOLIDATE with explanation/adr/\n├── architecture/                # CONSOLIDATE with reference/architecture/\n│\n└── _archive/                    # NEW - Deprecated content\n    ├── claude-audit/\n    ├── debug/\n    ├── sales/\n    └── tech-debt/\n```\n\n### 2. CLAUDE.md Optimization Strategy\n```markdown\n## Root Level: CLAUDE.local.md\n- Keep concise (~65 lines) - GOOD\n- Focus on quick reference\n- Link to detailed docs\n\n## Backend: quikadmin/CLAUDE.md\n- Currently 1500+ lines - TOO LONG\n- Split into:\n  - Essential context (300 lines max)\n  - Link to docs/ for details\n  - Remove duplicate documentation protocols\n\n## Frontend: quikadmin-web/CLAUDE.md\n- Currently ~555 lines - ACCEPTABLE\n- Keep pattern examples\n- Remove redundant info\n```\n\n### 3. Token Optimization Strategies\n- Use index files (README.md) as navigation hubs\n- Implement lazy-loading documentation pattern\n- Keep CLAUDE.md files under 500 lines\n- Reference docs/ instead of duplicating\n\n### 4. Cross-Reference Design\n```yaml\n# Each doc should have\nfrontmatter:\n  title: string\n  category: tutorials|how-to|reference|explanation\n  relatedDocs: string[]\n  lastUpdated: date\n  status: active|deprecated\n```\n\n### 5. Output Deliverables\n- `docs/.meta/proposed-structure.md` - Visual structure diagram\n- `docs/.meta/migration-plan.md` - Step-by-step migration\n- Updated `docs/.meta/STRUCTURE_DIAGRAM.md`",
        "testStrategy": "1. Validate proposed structure against Diataxis principles\n2. Estimate token savings from CLAUDE.md optimization\n3. Review with stakeholders for practical concerns\n4. Test navigation flow for common developer tasks\n5. Verify all existing content has a home in new structure\n6. Measure estimated tokens for root CLAUDE context load",
        "priority": "medium",
        "dependencies": ["157", "158"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit Current vs Proposed Structure and Create Reconciliation Matrix",
            "description": "Compare the existing Diataxis-based structure (tutorials, how-to, reference, explanation, ai-development) with the proposed numbered structure in STRUCTURE_DIAGRAM.md (00-quick-start through 06-archive). Create a reconciliation matrix mapping current folders to optimal target locations.",
            "dependencies": [],
            "details": "Analyze discrepancy between current docs/ structure and proposed .meta/STRUCTURE_DIAGRAM.md numbered structure. Current structure follows Diataxis (tutorials/, how-to/, reference/, explanation/, ai-development/) while proposed uses numbered prefixes (00-quick-start/ through 06-archive/). Create docs/.meta/proposed-structure.md with: 1) Decision on which naming convention to adopt (numbered vs semantic Diataxis names), 2) Mapping of all 55+ existing docs to their target locations, 3) Identification of orphaned content (claude-audit/, debug/, sales/, tech-debt/, architecture/, decisions/, prd/, strategy/, guides/) that needs archival or consolidation. Consider that current README.md already references Diataxis structure correctly.",
            "status": "pending",
            "testStrategy": "Verify mapping covers all 55+ files from glob results. Validate decision aligns with Diataxis principles. Ensure no content is orphaned without a designated target.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Design CLAUDE.md Token Optimization Strategy with Line Budgets",
            "description": "Create concrete optimization plan for reducing backend CLAUDE.md from 1137 lines to under 500 lines while preserving critical context. Define line budgets for each section and identify content to extract to docs/.",
            "dependencies": [1],
            "details": "Backend CLAUDE.md (1137 lines) needs reduction to ~300-500 lines. Frontend CLAUDE.md (448 lines) is acceptable. Strategy document should include: 1) Section-by-section line budget (e.g., Quick Reference: 50 lines, Architecture: 100 lines, Development Protocols: 80 lines), 2) Identification of content to extract (detailed code examples, extensive command references, duplicated docs info), 3) Link replacement strategy using format 'See docs/reference/X.md for details', 4) Preserve: critical file paths, common commands, security protocols, testing patterns. Create docs/.meta/claude-md-optimization-plan.md with before/after line counts per section and extraction targets.",
            "status": "pending",
            "testStrategy": "Calculate estimated token savings (target: 40-50% reduction). Verify all extracted content has valid target paths in docs/. Ensure remaining content provides sufficient context for AI agents.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Design Cross-Reference and Metadata Schema for Documents",
            "description": "Define YAML frontmatter schema, cross-reference patterns, and navigation index structure to enable AI agents to efficiently traverse documentation while minimizing token consumption.",
            "dependencies": [1],
            "details": "Design comprehensive metadata system: 1) YAML frontmatter schema with fields: title, category (tutorials|how-to|reference|explanation), status (active|deprecated|draft), priority (critical|important|reference), relatedDocs[], codeReferences[], lastUpdated, aiHints{readFirst, skipFor, dependencies}. 2) Create docs/.meta/index.json structure for complete documentation graph with navigation hints. 3) Design ai-context.json format for lazy-loading documentation hints. 4) Specify README.md hub pattern for each major section with consistent navigation. Document in docs/.meta/metadata-schema.md. Consider existing templates in docs/.meta/templates/.",
            "status": "pending",
            "testStrategy": "Validate schema covers all use cases from existing frontmatter in doc templates. Test navigation flow from entry point to any document in 3 or fewer hops. Verify AI agents can determine document relevance from metadata alone.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create Migration Plan with Consolidation Rules and Archive Strategy",
            "description": "Develop step-by-step migration plan document specifying file moves, content merges, link updates, and archive procedures. Include rollback strategy and verification checkpoints.",
            "dependencies": [1, 2, 3],
            "details": "Create docs/.meta/migration-plan.md with: 1) Phase 1: Create archive structure (_archive/claude-audit/, _archive/debug/, _archive/sales/, _archive/tech-debt/), 2) Phase 2: Consolidate duplicates - merge docs/architecture/ (2 files) into reference/architecture/, merge docs/decisions/ (1 ADR) into explanation/adr/, merge docs/guides/ content into how-to/, 3) Phase 3: Update all cross-references (identify ~20 internal links needing updates), 4) Phase 4: CLAUDE.md optimization - extract content per subtask 2 plan, 5) Phase 5: Validate with markdown-link-check. Include git commands for each move, verification steps after each phase, and rollback instructions. Estimate: 15-20 file moves, 3 content merges, 1 CLAUDE.md rewrite.",
            "status": "pending",
            "testStrategy": "Dry-run migration commands in test branch. Run npx markdown-link-check on migrated docs. Verify archived content remains accessible. Confirm CLAUDE.md files under 500 lines post-migration.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-30T08:08:57.413Z"
      },
      {
        "id": 160,
        "title": "Execute Documentation Consolidation",
        "description": "Execute the restructuring plan by merging duplicates, reorganizing files, updating cross-references, ensuring consistent formatting, and archiving obsolete content.",
        "details": "## Implementation Steps\n\n### 1. Create Archive Structure\n```bash\nmkdir -p docs/_archive/{claude-audit,debug,sales,tech-debt}\n\n# Move non-essential docs to archive\nmv docs/claude-audit/* docs/_archive/claude-audit/\nmv docs/debug/* docs/_archive/debug/\nmv docs/sales/* docs/_archive/sales/\nmv docs/tech-debt/* docs/_archive/tech-debt/\n```\n\n### 2. Consolidate Architecture Documentation\n```bash\n# Merge duplicate architecture docs\n# docs/architecture/*.md -> docs/reference/architecture/\nmv docs/architecture/dynamic-pii-architecture*.md docs/reference/architecture/\n\n# Update docs/decisions/ -> docs/explanation/adr/\nmv docs/decisions/*.md docs/explanation/adr/\n```\n\n### 3. Merge Duplicate Content\nPriority merges:\n1. Environment variables: Single source in `docs/reference/configuration/environment.md`\n2. API endpoints: Consolidate to `docs/reference/api/endpoints.md`\n3. Architecture overview: Single source in `docs/reference/architecture/system-overview.md`\n\n### 4. Optimize CLAUDE.md Files\n\n```markdown\n## quikadmin/CLAUDE.md Refactoring\n\nKEEP:\n- Project Overview section\n- Architecture Quick Reference  \n- Development Protocols (condensed)\n- Common Commands\n\nMOVE TO docs/:\n- Documentation Protocols (1000+ lines)\n- Detailed PR requirements\n- Detailed testing guidelines\n- CI/CD check examples\n\nTarget: ~500 lines\n```\n\n### 5. Update All Cross-References\n```typescript\n// Script to update internal links\nconst linkUpdates = {\n  'docs/architecture/current/': 'docs/reference/architecture/',\n  'docs/decisions/': 'docs/explanation/adr/',\n  'docs/getting-started/': 'docs/tutorials/',\n  // ... all path changes\n};\n```\n\n### 6. Add Missing Frontmatter\nEnsure all docs have:\n```yaml\n---\ntitle: Document Title\ndescription: Brief description\ncategory: tutorials|how-to|reference|explanation\nlastUpdated: 2025-12-30\nstatus: active\n---\n```\n\n### 7. Update Root Documentation Hub\nUpdate `docs/README.md` with:\n- Clear navigation structure\n- Quick links for common tasks\n- AI agent reading order\n- Updated last modified date\n\n### 8. Validate Internal Consistency\n```bash\n# Run link validation\nnpx markdown-link-check docs/**/*.md\n\n# Verify frontmatter\nfor file in docs/**/*.md; do\n  head -20 \"$file\" | grep -q '^---' || echo \"Missing frontmatter: $file\"\ndone\n```",
        "testStrategy": "1. Run `npx markdown-link-check` on all docs - 0 broken links\n2. Validate all moved files have correct path references\n3. Verify CLAUDE.md files are under 500 lines (except comprehensive backend)\n4. Test navigation from docs/README.md to all major sections\n5. Confirm archived content is still accessible but clearly marked\n6. Verify no duplicate content exists (grep for key phrases)\n7. Test AI agent context loading with new structure\n8. Confirm all code examples in docs still reference valid paths",
        "priority": "medium",
        "dependencies": ["159"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Archive Structure and Move Non-Essential Documentation",
            "description": "Create the docs/_archive/ directory hierarchy and move claude-audit/, debug/, sales/, and tech-debt/ directories to archive with proper README index",
            "dependencies": [],
            "details": "Create docs/_archive/ with subdirectories: claude-audit, debug, sales, tech-debt. Move 6 files total: claude_setup_report.md, claude_setup_addendum.md, taskmaster_provider_check.md (claude-audit), evidence_bundle.md (debug), gemini-prompts.md (sales), tech-stability-audit-2025-12.md (tech-debt). Create docs/_archive/README.md index explaining archived content is retained for reference but not actively maintained. Update any cross-references in other docs (check .meta/DOCUMENTATION_MIGRATION_GUIDE.md). Remove empty source directories after move.",
            "status": "pending",
            "testStrategy": "Verify all 6 files moved correctly, _archive/README.md exists, no broken links to archived content, empty source directories removed",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Consolidate Architecture and ADR Documentation",
            "description": "Merge duplicate architecture docs into reference/architecture/ and move decisions/ content to explanation/adr/ following Diataxis structure",
            "dependencies": [1],
            "details": "Move docs/architecture/dynamic-pii-architecture.md and dynamic-pii-architecture-options.md to docs/reference/architecture/. Move docs/decisions/ADR-001-document-relationship-design.md to docs/explanation/adr/ alongside existing ADR-001-document-processing-pipeline.md. Update docs/explanation/architecture-decisions.md to reference the consolidated ADR location. Remove empty architecture/ and decisions/ directories. Update cross-references in any files that link to old paths. Ensure proper YAML frontmatter on all moved files.",
            "status": "pending",
            "testStrategy": "Verify 3 files moved to correct locations, old directories removed, architecture-decisions.md references new ADR paths, run grep to confirm no remaining links to old paths",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add Missing Frontmatter and Standardize Metadata",
            "description": "Ensure all docs have consistent YAML frontmatter with title, description, category, lastUpdated, and status fields",
            "dependencies": [1, 2],
            "details": "Scan all ~55 markdown files in docs/ for frontmatter presence using grep/head. For files missing frontmatter, add standard YAML header: title (from H1), description (one-line summary), category (tutorials|how-to|reference|explanation|ai-development), lastUpdated (2025-12-30), status (active). Priority files: tutorials/README.md, all moved architecture files, explanation/ files. Use consistent date format YYYY-MM-DD. Update lastUpdated on any files modified during consolidation. Create validation script or document checklist for future frontmatter compliance.",
            "status": "pending",
            "testStrategy": "Run 'head -20 docs/**/*.md | grep -c \"^---\"' to count frontmatter presence, verify all active docs have required fields, sample 10 random files for compliance",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update Cross-References and Internal Links",
            "description": "Find and update all internal documentation links affected by file moves, ensuring navigation remains intact",
            "dependencies": [1, 2],
            "details": "Create mapping of path changes: docs/architecture/* -> docs/reference/architecture/*, docs/decisions/* -> docs/explanation/adr/*, docs/claude-audit/* -> docs/_archive/claude-audit/*, docs/debug/* -> docs/_archive/debug/*, docs/sales/* -> docs/_archive/sales/*, docs/tech-debt/* -> docs/_archive/tech-debt/*. Grep all .md files for old paths and update to new paths. Update docs/README.md quick links section. Update .meta/DOCUMENTATION_MIGRATION_GUIDE.md with completed migrations. Check CLAUDE.local.md and quikadmin/CLAUDE.md for any docs references. Verify no broken relative links remain.",
            "status": "pending",
            "testStrategy": "Run 'npx markdown-link-check docs/**/*.md' for all docs, grep for old paths returns 0 results, manually test navigation from docs/README.md to major sections",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Update Documentation Hub and Validate Consolidation",
            "description": "Update docs/README.md hub with current structure, clear navigation, and run final validation to ensure zero broken links",
            "dependencies": [3, 4],
            "details": "Update docs/README.md: refresh Documentation Structure section with current hierarchy, add _archive section noting archived content, update Quick Links for any path changes, set lastUpdated to 2025-12-30, verify AI agent reading order still valid. Add note about archived vs active content distinction. Update Project Structure diagram if needed. Run comprehensive validation: npx markdown-link-check on all docs, verify frontmatter with grep, test all tutorial/how-to links work. Document token savings if CLAUDE.md optimization was done. Create summary of consolidation changes for future reference.",
            "status": "pending",
            "testStrategy": "npx markdown-link-check returns 0 broken links, docs/README.md accurately reflects directory structure, navigation from hub reaches all major sections in 2 clicks, archived content accessible but clearly marked",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-12-30T08:12:52.537Z"
      },
      {
        "id": 161,
        "title": "Add YAML Frontmatter to Documentation Files",
        "description": "Batch-add consistent YAML frontmatter to approximately 48 documentation files in the main docs/ directory that are missing it, using the template from docs/.meta/templates/document-template.md.",
        "details": "## Implementation Details\n\n### Scope\n- Target: ~48 files in main docs/ (61 total - 13 with existing frontmatter)\n- Template: Use simplified frontmatter from docs/.meta/templates/document-template.md\n- Batch approach: Process by directory to avoid context limits\n\n### Frontmatter Format\n```yaml\n---\ntitle: \"Document Title\"\ndescription: \"Brief description of the document content\"\ncategory: \"tutorials|how-to|reference|explanation|ai-development\"\nlastUpdated: \"2025-12-30\"\nstatus: \"active\"\n---\n```\n\n### Processing Order (Priority)\n1. `docs/tutorials/` - 4 files\n2. `docs/how-to/` - 10 files (deployment, development, troubleshooting subdirs)\n3. `docs/reference/` - 10 files (api, architecture, configuration, database, design, monitoring, security subdirs)\n4. `docs/explanation/` - 6 files (including adr/ subdir)\n5. `docs/ai-development/` - 3 files\n6. `docs/guides/` - 2 files\n7. Root docs files - 5 files (README.md, PRD.md, MAINTENANCE.md, etc.)\n8. `docs/prd/`, `docs/strategy/` - remaining files\n\n### Implementation Steps\n1. Read each markdown file\n2. Check if frontmatter exists (starts with ---)\n3. If missing, prepend frontmatter:\n   - Extract title from first # heading\n   - Generate description from first paragraph\n   - Assign category based on directory\n   - Set lastUpdated to 2025-12-30\n   - Set status to 'active'\n4. Write updated file\n5. Verify file structure not broken\n\n### Edge Cases\n- Files starting with `# ` in YAML (like the template) - skip these\n- Files in _archive/ - status should be 'archived'\n- Files in .meta/ - skip (internal tooling)\n\n### Pseudo-code\n```typescript\nconst categories = {\n  'tutorials': 'tutorials',\n  'how-to': 'how-to',\n  'reference': 'reference',\n  'explanation': 'explanation',\n  'ai-development': 'ai-development',\n  'guides': 'how-to',\n  '_archive': 'archived'\n};\n\nfor (const file of markdownFiles) {\n  if (file.includes('.meta/')) continue;\n  \n  const content = await readFile(file);\n  if (content.startsWith('---')) continue; // Already has frontmatter\n  \n  const title = extractTitle(content); // First # heading\n  const description = extractDescription(content); // First paragraph\n  const category = determineCategory(file, categories);\n  const status = file.includes('_archive') ? 'archived' : 'active';\n  \n  const frontmatter = `---\ntitle: \"${title}\"\ndescription: \"${description}\"\ncategory: \"${category}\"\nlastUpdated: \"2025-12-30\"\nstatus: \"${status}\"\n---\n\n`;\n  \n  await writeFile(file, frontmatter + content);\n}\n```",
        "testStrategy": "## Validation Approach\n\n### Automated Checks\n1. **Frontmatter Parser Test**: Use a YAML parser to validate all files have valid YAML frontmatter\n2. **Required Fields Check**: Verify each file has: title, description, category, lastUpdated, status\n3. **Category Validation**: Ensure category is one of: tutorials, how-to, reference, explanation, ai-development, archived\n\n### Manual Verification\n1. Spot-check 5 files from each category for correct metadata\n2. Verify file content not corrupted (compare line counts before/after)\n3. Check that existing frontmatter files were not modified\n\n### Verification Script\n```bash\n# Count files with valid frontmatter\ngrep -l '^---$' docs/**/*.md | wc -l\n# Should equal ~61 after completion\n\n# Validate YAML structure\nfor f in docs/**/*.md; do\n  head -20 \"$f\" | grep -q 'title:' && \\\n  head -20 \"$f\" | grep -q 'description:' && \\\n  head -20 \"$f\" | grep -q 'category:' && \\\n  head -20 \"$f\" | grep -q 'lastUpdated:' && \\\n  head -20 \"$f\" | grep -q 'status:' || echo \"Missing fields: $f\"\ndone\n```\n\n### Success Criteria\n- [ ] All 48 files in docs/ have valid YAML frontmatter\n- [ ] No files with corrupted content\n- [ ] Categories match directory locations\n- [ ] Build/lint passes if applicable",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-30T11:39:47.597Z"
      },
      {
        "id": 162,
        "title": "Migrate Unique Files from quikadmin/docs/",
        "description": "Migrate 15 unique documentation files from quikadmin/docs/ to the main docs/ directory as identified in docs/.meta/quikadmin-docs-review.md, update cross-references, and remove migrated files from source.",
        "details": "## Implementation Details\n\n### Files to Migrate (from quikadmin-docs-review.md)\n\n| Source | Target | Priority |\n|--------|--------|----------|\n| `00-quick-start/ai-agent-setup.md` | `docs/ai-development/agent-setup.md` | High |\n| `01-current-state/architecture/quick-reference.md` | `docs/reference/architecture/quick-reference.md` | High |\n| `02-guides/development/implementing-auth.md` | `docs/how-to/development/implementing-auth.md` | High |\n| `02-guides/development/ocr-implementation.md` | `docs/how-to/development/ocr-implementation.md` | Medium |\n| `02-guides/development/pdf-implementation.md` | `docs/how-to/development/pdf-implementation.md` | Medium |\n| `02-guides/user/document-reprocessing.md` | `docs/tutorials/document-reprocessing.md` | Medium |\n| `02-guides/user/templates.md` | `docs/tutorials/template-usage.md` | Medium |\n| `research/pdf-library-comparison.md` | `docs/explanation/pdf-library-research.md` | Low |\n| `design/design-system.md` | `docs/reference/design/design-system.md` | Medium |\n\n### Content to Merge (into existing files)\n| Source | Target |\n|--------|--------|\n| `01-current-state/api/endpoints/profile.md` | Merge into `docs/reference/api/endpoints.md` |\n| `01-current-state/api/endpoints/templates.md` | Merge into `docs/reference/api/endpoints.md` |\n| `01-current-state/api/endpoints/document-reprocessing.md` | Merge into `docs/reference/api/endpoints.md` |\n| `01-current-state/architecture/system-overview.md` | Merge detailed content into `docs/reference/architecture/system-overview.md` |\n\n### Implementation Steps\n\n1. **Create target directories**\n```bash\nmkdir -p docs/reference/design\n# Other dirs already exist\n```\n\n2. **For each standalone migration**:\n   - Read source file\n   - Add YAML frontmatter (if missing)\n   - Update internal links (../../ -> ../ patterns)\n   - git mv to preserve history\n   - Update any files that referenced the old location\n\n3. **For merge operations**:\n   - Read both source and target files\n   - Identify unique content in source\n   - Append/integrate unique sections to target\n   - Delete source file after verification\n\n4. **Update cross-references**:\n   - Search all docs for references to old paths\n   - Update to new paths\n   - Update quikadmin/CLAUDE.md if it references migrated files\n\n### Pseudo-code\n```typescript\n// Standalone migrations\nconst migrations = [\n  { src: 'quikadmin/docs/00-quick-start/ai-agent-setup.md', \n    dest: 'docs/ai-development/agent-setup.md' },\n  // ... other migrations\n];\n\nfor (const m of migrations) {\n  // Use git mv to preserve history\n  await exec(`git mv \"${m.src}\" \"${m.dest}\"`);\n  \n  // Update internal links in migrated file\n  let content = await readFile(m.dest);\n  content = updateRelativeLinks(content, m.src, m.dest);\n  await writeFile(m.dest, content);\n}\n\n// Update references in all docs\nconst allDocs = await glob('docs/**/*.md');\nfor (const doc of allDocs) {\n  let content = await readFile(doc);\n  for (const m of migrations) {\n    content = content.replace(\n      new RegExp(escapeRegex(m.src), 'g'),\n      m.dest\n    );\n  }\n  await writeFile(doc, content);\n}\n```\n\n### Files to Keep in quikadmin/docs/ (Backend-Specific)\n- `03-reference/TEST_CREDENTIALS.md`\n- `01-current-state/architecture/SECURITY_ROTATION.md`",
        "testStrategy": "## Validation Approach\n\n### Pre-Migration Checklist\n1. Verify all source files exist\n2. Verify target directories exist\n3. Backup current state (git stash or commit first)\n\n### Post-Migration Verification\n1. **File Existence Check**:\n   - All 15 target files exist in docs/\n   - Source files removed (except backend-specific ones)\n\n2. **Link Integrity Test**:\n```bash\n# Find broken internal links\nfor f in docs/**/*.md; do\n  grep -oP '\\]\\(\\./[^)]+\\)' \"$f\" | while read link; do\n    target=$(echo $link | sed 's/.*\\.\\/\\([^)]*\\).*/\\1/')\n    dir=$(dirname \"$f\")\n    if [[ ! -f \"$dir/$target\" ]]; then\n      echo \"Broken link in $f: $target\"\n    fi\n  done\ndone\n```\n\n3. **Git History Check**:\n```bash\n# Verify git history preserved for migrated files\ngit log --follow docs/ai-development/agent-setup.md\n```\n\n4. **Reference Update Check**:\n```bash\n# No references to old paths should exist\ngrep -r \"quikadmin/docs/00-quick-start\" docs/ # Should return nothing\ngrep -r \"quikadmin/docs/02-guides\" docs/ # Should return nothing\n```\n\n### Success Criteria\n- [ ] All 15 unique files migrated to correct locations\n- [ ] Git history preserved for migrated files\n- [ ] No broken internal links in docs/\n- [ ] No references to old quikadmin/docs/ paths\n- [ ] quikadmin/CLAUDE.md updated if needed\n- [ ] Merged content integrated into target files",
        "priority": "high",
        "dependencies": ["161"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-12-30T12:13:32.882Z"
      },
      {
        "id": 163,
        "title": "Archive Duplicate Files from quikadmin/docs/",
        "description": "Archive approximately 95 duplicate/outdated files from quikadmin/docs/ to quikadmin/docs/_archive/, preserving git history and keeping approximately 10 backend-specific files in place.",
        "details": "## Implementation Details\n\n### Files to Archive (~95 files)\n\n**By Directory:**\n\n1. **06-archive/** and **archive/** (~30 files) - ARCHIVE ALL\n   - Old numbered sections (100-700 series)\n   - Historical implementation plans\n   - Upgrade reports and test results\n\n2. **.meta/** (~22 files) - ARCHIVE ALL\n   - `CLEANUP_*.md`\n   - `PHASE*_COMPLETION_SUMMARY.md`\n   - `DOCUMENTATION_ARCHITECTURE_*.md`\n   - `TASK-*.md`\n\n3. **04-future-vision/** (~4 files) - ARCHIVE ALL\n   - Vision documentation explicitly marked \"NOT IMPLEMENTED\"\n\n4. **Duplicates from other sections** (~39 files)\n   - `00-quick-start/README.md`, `project-overview.md`\n   - `01-current-state/` duplicates\n   - `02-guides/development/DEV_SETUP.md`, `TESTING_PLAN.md`\n   - `getting-started/` - all 6 files\n   - `infrastructure/` and `deployment/` - 5 files\n\n### Files to KEEP in quikadmin/docs/ (~10 files)\n- `03-reference/TEST_CREDENTIALS.md`\n- `01-current-state/architecture/SECURITY_ROTATION.md`\n- Supabase middleware implementation details\n- Any files referenced by migrated docs in Task 162\n\n### Archive Structure\n```\nquikadmin/docs/_archive/\n├── README.md              # Explains archive status\n├── numbered-sections/     # Old 100-700 series\n├── meta-historical/       # .meta completion summaries\n├── future-vision/         # Unimplemented vision docs\n├── duplicates/            # Content duplicated in main docs/\n└── historical/            # Implementation plans, upgrade reports\n```\n\n### Implementation Steps\n\n1. **Create archive structure**:\n```bash\nmkdir -p quikadmin/docs/_archive/{numbered-sections,meta-historical,future-vision,duplicates,historical}\n```\n\n2. **Create archive README**:\n```markdown\n# Archived Documentation\n\n**Archived Date:** 2025-12-30\n**Reason:** Documentation consolidation - content migrated to main `docs/` directory\n\nThis directory contains historical/duplicate documentation preserved for reference.\n\n## Current Documentation\nSee the main `docs/` directory at the project root for current documentation.\n\n## Structure\n- `numbered-sections/` - Old numbered documentation (100-700 series)\n- `meta-historical/` - Task completion summaries and cleanup logs  \n- `future-vision/` - Unimplemented architecture visions\n- `duplicates/` - Content now in main docs/\n- `historical/` - Implementation plans and upgrade reports\n\n## Backend-Specific Documentation\nSee `quikadmin/CLAUDE.md` for backend-specific context.\nActive backend docs remain in `quikadmin/docs/` (not in _archive).\n```\n\n3. **Move files using git mv**:\n```bash\n# Use git mv to preserve history\ngit mv quikadmin/docs/06-archive/* quikadmin/docs/_archive/numbered-sections/\ngit mv quikadmin/docs/archive/* quikadmin/docs/_archive/historical/\ngit mv quikadmin/docs/.meta/*.md quikadmin/docs/_archive/meta-historical/\ngit mv quikadmin/docs/04-future-vision/* quikadmin/docs/_archive/future-vision/\n```\n\n4. **Update quikadmin/docs/README.md**:\n```markdown\n# Backend Documentation\n\nThis directory contains backend-specific documentation.\n\n## Main Documentation\nFor comprehensive project documentation, see the main `docs/` directory.\n\n## Backend-Specific Docs\n- `03-reference/TEST_CREDENTIALS.md` - Test credentials (sensitive)\n- `01-current-state/architecture/SECURITY_ROTATION.md` - Credential rotation\n\n## Archived Content\nSee `_archive/` for historical documentation.\n```\n\n5. **Clean up empty directories**:\n```bash\nfind quikadmin/docs -type d -empty -delete\n```\n\n### Pseudo-code\n```typescript\nconst archiveMappings = {\n  '06-archive': '_archive/numbered-sections',\n  'archive': '_archive/historical',\n  '.meta': '_archive/meta-historical',\n  '04-future-vision': '_archive/future-vision',\n};\n\n// Create archive structure\nawait exec('mkdir -p quikadmin/docs/_archive/{numbered-sections,meta-historical,future-vision,duplicates,historical}');\n\n// Move directories\nfor (const [src, dest] of Object.entries(archiveMappings)) {\n  const srcPath = `quikadmin/docs/${src}`;\n  const destPath = `quikadmin/docs/${dest}`;\n  if (await exists(srcPath)) {\n    await exec(`git mv \"${srcPath}\"/* \"${destPath}/\"`);\n  }\n}\n\n// Handle individual duplicate files\nconst duplicates = [\n  'quikadmin/docs/00-quick-start/README.md',\n  'quikadmin/docs/00-quick-start/project-overview.md',\n  // ... list from review\n];\n\nfor (const dup of duplicates) {\n  await exec(`git mv \"${dup}\" quikadmin/docs/_archive/duplicates/`);\n}\n\n// Clean up empty directories\nawait exec('find quikadmin/docs -type d -empty -delete');\n```",
        "testStrategy": "## Validation Approach\n\n### Pre-Archive Verification\n1. **List files to archive**: Generate complete list before operation\n2. **Verify keep-list**: Confirm backend-specific files will remain\n3. **Check dependencies**: Ensure no active code references files being archived\n\n### Post-Archive Verification\n\n1. **File Count Check**:\n```bash\n# Count files in archive\nfind quikadmin/docs/_archive -name \"*.md\" | wc -l\n# Should be ~95\n\n# Count remaining active files\nfind quikadmin/docs -name \"*.md\" -not -path \"*/_archive/*\" | wc -l\n# Should be ~10\n```\n\n2. **Git History Check**:\n```bash\n# Verify history preserved\ngit log --follow quikadmin/docs/_archive/historical/test-results/SMOKE_TEST_RESULTS.md\n```\n\n3. **README Verification**:\n```bash\n# Archive README exists\ncat quikadmin/docs/_archive/README.md\n\n# Main README updated\ncat quikadmin/docs/README.md\n```\n\n4. **No Broken References**:\n```bash\n# Search for references to archived paths in active docs\ngrep -r \"06-archive\" docs/ quikadmin/docs/*.md 2>/dev/null || echo \"Clean\"\ngrep -r \"04-future-vision\" docs/ quikadmin/docs/*.md 2>/dev/null || echo \"Clean\"\n```\n\n5. **Backend-Specific Files Remain**:\n```bash\n# Verify key files still exist\ntest -f quikadmin/docs/03-reference/TEST_CREDENTIALS.md && echo \"OK\" || echo \"MISSING\"\ntest -f quikadmin/docs/01-current-state/architecture/SECURITY_ROTATION.md && echo \"OK\" || echo \"MISSING\"\n```\n\n### Success Criteria\n- [ ] ~95 files moved to _archive/ structure\n- [ ] ~10 backend-specific files remain in place\n- [ ] Git history preserved for all moved files\n- [ ] _archive/README.md explains archive status\n- [ ] quikadmin/docs/README.md points to main docs/\n- [ ] No empty directories remain\n- [ ] No broken references in active documentation",
        "priority": "medium",
        "dependencies": ["162"],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-01T04:33:37.594Z"
      },
      {
        "id": 164,
        "title": "Enforce Prisma Singleton Pattern Across Codebase",
        "description": "Replace all per-request PrismaClient instantiation with singleton import from utils/prisma.ts to prevent connection pool exhaustion",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-31T09:41:14.413Z"
      },
      {
        "id": 165,
        "title": "Register Audit Middleware Globally",
        "description": "Register createAuditMiddleware globally in index.ts to ensure 100% audit coverage for all API endpoints with configurable exclusions",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-31T09:41:20.628Z"
      },
      {
        "id": 166,
        "title": "Fix RLS Context Error Handling",
        "description": "Make RLS set_user_context failures visible with ERROR logging, metrics tracking, and configurable 500 response in production",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2025-12-31T09:41:26.796Z"
      },
      {
        "id": 167,
        "title": "Implement Circuit Breaker for Supabase Auth",
        "description": "Add circuit breaker pattern using opossum for supabaseAdmin.auth.getUser() to handle Supabase outages gracefully",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-31T09:54:07.379Z"
      },
      {
        "id": 168,
        "title": "Add Token Caching Layer",
        "description": "Implement Redis-backed token cache with SHA256 key hashing, 5-min TTL, and in-memory fallback to reduce Supabase calls",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-31T10:47:38.495Z"
      },
      {
        "id": 169,
        "title": "Create Organization Context Middleware",
        "description": "Create dedicated middleware for organizationId extraction, validation, and consistent enforcement across org-scoped endpoints",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-31T15:13:39.893Z"
      },
      {
        "id": 170,
        "title": "Enhance Health Endpoint with Connection Metrics",
        "description": "Add /health/detailed endpoint exposing Supabase connectivity, Prisma pool stats, Redis status, and RLS failure counts",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2025-12-31T16:02:42.675Z"
      },
      {
        "id": 171,
        "title": "Normalize Rate Limiter Key Generation",
        "description": "Create shared generateRateLimitKey function with user/org/ip scopes and consistent validation across all rate limiters",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "low",
        "subtasks": [],
        "updatedAt": "2025-12-31T16:13:17.565Z"
      },
      {
        "id": 172,
        "title": "Consolidate .env files to single root configuration",
        "description": "Secure and clarify .env file structure: Remove duplicate Supabase keys from root .env (security fix - SERVICE_ROLE_KEY should NOT be in root), keep root .env only for AI tool keys (TaskMaster: PERPLEXITY, GROQ, GOOGLE, etc), add startup validation in backend to catch missing env vars, and document which file is authoritative for which keys.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "details": "REVISED APPROACH: Keep separate .env structure but improve security and clarity.\n\n**Current state analysis**:\n- Root `.env` contains duplicate Supabase keys including SERVICE_ROLE_KEY (SECURITY ISSUE)\n- `quikadmin/.env` is authoritative for all backend configuration\n- `quikadmin-web/.env` is authoritative for frontend VITE_ prefixed vars\n- Root `.env` should only contain AI tool keys for TaskMaster/Claude\n\n**Key files**:\n- Root `.env` (lines 1-10): Currently has Supabase keys + AI tool keys\n- `quikadmin/.env` (lines 1-32): Full backend config\n- `quikadmin-web/.env` (lines 1-7): Frontend VITE_ vars\n- `quikadmin/src/config/index.ts` (lines 78-203): Config loading and validation\n- `docs/reference/configuration/environment.md`: Documentation to update\n\n**Security fix**: SERVICE_ROLE_KEY in root .env is a security risk - this key grants admin access and should only exist in backend .env file.",
        "testStrategy": "1. Verify root .env contains ONLY AI tool keys (no SUPABASE_* vars). 2. Verify backend starts successfully with proper validation errors for missing vars. 3. Verify frontend loads correctly with VITE_ vars from quikadmin-web/.env. 4. Test startup with missing critical vars (DATABASE_URL, JWT_SECRET) to confirm helpful error messages. 5. Review documentation for accuracy.",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove duplicate Supabase keys from root .env (security fix)",
            "description": "Remove SUPABASE_URL, SUPABASE_ANON_KEY, and critically SUPABASE_SERVICE_ROLE_KEY from root .env file. The SERVICE_ROLE_KEY should ONLY exist in quikadmin/.env as it grants admin-level database access.",
            "dependencies": [],
            "details": "Edit root `.env` (N:\\IntelliFill\\.env) to remove lines 1-4 containing Supabase credentials. Keep only the AI tool section (lines 6-10): PERPLEXITY_API_KEY, GOOGLE_API_KEY, GEMINI_API_KEY, GROQ_API_KEY. Update comment from 'For Claude' to 'AI Tool Keys (TaskMaster, Claude Code, etc)'. This is a critical security fix - SERVICE_ROLE_KEY bypasses RLS and should never be in a shared/root location.",
            "status": "pending",
            "testStrategy": "Run `grep -r 'SERVICE_ROLE_KEY' .env` from root to confirm it only appears in quikadmin/.env. Verify backend still starts (it reads from quikadmin/.env).",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Enhance backend startup validation with clear error messages",
            "description": "Add comprehensive startup validation in quikadmin/src/config/index.ts that provides clear, actionable error messages when required environment variables are missing, including which .env file to check.",
            "dependencies": [],
            "details": "Enhance the `getEnv()` function in quikadmin/src/config/index.ts (line 78-84) to provide better error messages that indicate the source file. Add a new `validateRequiredEnvVars()` function that runs early in loadConfig() and lists ALL missing required vars at once (not fail-fast) so developers can fix all issues in one pass. Required vars: DATABASE_URL, JWT_SECRET, JWT_REFRESH_SECRET, SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY. Include suggestion text: 'Check quikadmin/.env - see docs/reference/configuration/environment.md for details'.",
            "status": "pending",
            "testStrategy": "Temporarily remove DATABASE_URL from quikadmin/.env and verify error message mentions the file location and docs link. Test with multiple missing vars to confirm all are reported.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Document authoritative source for each environment variable",
            "description": "Update docs/reference/configuration/environment.md with a new section that clearly documents which .env file is authoritative for which variables, preventing duplication confusion.",
            "dependencies": [1, 2],
            "details": "Add new section '## File Authority Reference' to docs/reference/configuration/environment.md (after line 14) with a clear table:\n\n| File | Authority | Variables |\n|------|-----------|----------|\n| `.env` (root) | AI Tools only | PERPLEXITY_API_KEY, GOOGLE_API_KEY, GEMINI_API_KEY, GROQ_API_KEY |\n| `quikadmin/.env` | Backend | DATABASE_URL, JWT_*, SUPABASE_*, REDIS_URL, R2_*, CORS_ORIGINS, etc. |\n| `quikadmin-web/.env` | Frontend | VITE_API_URL, VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY, VITE_USE_BACKEND_AUTH |\n\nAdd explicit warning: 'SECURITY: SUPABASE_SERVICE_ROLE_KEY must ONLY exist in quikadmin/.env. Never duplicate this key to root .env or frontend files.'",
            "status": "pending",
            "testStrategy": "Review documentation for accuracy against actual file contents. Verify no conflicting information in existing sections.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Update CLAUDE.local.md with .env file authority reference",
            "description": "Update CLAUDE.local.md to reference the new environment documentation structure and clarify which .env file to edit for different variable types.",
            "dependencies": [3],
            "details": "Update the 'Environment Config' section in N:\\IntelliFill\\CLAUDE.local.md to include a quick reference table similar to the full docs, and add a link to docs/reference/configuration/environment.md for complete details. Add note: 'Root .env is for AI tools only (TaskMaster keys). Backend config goes in quikadmin/.env.'",
            "status": "pending",
            "testStrategy": "Verify links work and information is consistent with the detailed documentation.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Create .env.example templates that reflect the authority model",
            "description": "Update root .env.example (create if needed) and verify quikadmin/.env.example and quikadmin-web/.env.example accurately reflect their authoritative scope without overlapping variables.",
            "dependencies": [3],
            "details": "Create/update root .env.example with ONLY AI tool keys section. Verify quikadmin/.env.example contains all backend vars without duplicating to root. Verify quikadmin-web/.env.example contains only VITE_ prefixed frontend vars. Remove any duplicate Supabase entries that may exist across .env.example files. Add header comments to each .env.example explaining the file's purpose and authority scope.",
            "status": "pending",
            "testStrategy": "Compare all .env.example files to ensure no variable duplication (except public anon keys which frontend needs). Verify a fresh clone can set up environment by following examples.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": 173,
        "title": "Create Custom React Hooks Library Foundation",
        "description": "Create foundational custom React hooks (useToggle, useLocalStorage, useTimeout, useInterval) in quikadmin-web/src/hooks/ as the base library for codebase-wide refactoring of 53+ usage sites.",
        "details": "## Implementation Details\n\n### Overview\nCreate four foundational hooks following the existing pattern in `useDebounce.ts` with proper TypeScript types, JSDoc documentation, memory leak prevention, and comprehensive test coverage.\n\n### Directory Structure\n```\nquikadmin-web/src/hooks/\n├── useToggle.ts          # NEW - 25+ usage sites\n├── useLocalStorage.ts    # NEW - 19 usage sites  \n├── useTimeout.ts         # NEW - 5 usage sites\n├── useInterval.ts        # NEW - 4 usage sites\n├── index.ts              # NEW - barrel export\n├── useDebounce.ts        # EXISTS - reference pattern\n└── __tests__/\n    ├── useToggle.test.tsx\n    ├── useLocalStorage.test.tsx\n    ├── useTimeout.test.tsx\n    └── useInterval.test.tsx\n```\n\n### 1. useToggle Hook (`useToggle.ts`)\n\n**Target usage sites (25+):**\n- `AppLayout.tsx:144-145` - sidebarOpen, sidebarCollapsed\n- `autocomplete-field.tsx:95-99` - isOpen, isLoading, isFocused\n- `Register.tsx:40-42` - form toggles\n- `ResetPassword.tsx:29-35` - showPassword, showConfirmPassword, isLoading, resetSuccess\n- `Login.tsx:35` - showPassword\n- `ProfileDetail.tsx:94` - isEditing\n- `bulk-actions-toolbar.tsx:88,201` - showDeleteDialog\n\n**Implementation:**\n```typescript\nimport { useState, useCallback } from 'react'\n\n/**\n * Toggle boolean state with stable callbacks\n * @param initialValue - Initial boolean value (default: false)\n * @returns [value, toggle, setValue] tuple\n */\nexport function useToggle(initialValue: boolean = false): [\n  boolean,\n  () => void,\n  React.Dispatch<React.SetStateAction<boolean>>\n] {\n  const [value, setValue] = useState(initialValue)\n  const toggle = useCallback(() => setValue(v => !v), [])\n  return [value, toggle, setValue]\n}\n```\n\n### 2. useLocalStorage Hook (`useLocalStorage.ts`)\n\n**Target usage sites (19):**\n- `theme-provider.tsx:30,54` - theme persistence\n- `stores/index.ts:94-105` - auth/ui storage\n- `stores/migrationUtils.ts:20-77` - token handling\n- `documentService.ts:171,190,212` - auth token retrieval\n\n**Implementation:**\n```typescript\nimport { useState, useEffect, useCallback } from 'react'\n\n/**\n * Sync state with localStorage with SSR safety\n * @param key - localStorage key\n * @param initialValue - Initial value if no stored value exists\n * @returns [storedValue, setValue, removeValue] tuple\n */\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T\n): [T, (value: T | ((prev: T) => T)) => void, () => void] {\n  // SSR-safe initial state getter\n  const readValue = useCallback((): T => {\n    if (typeof window === 'undefined') return initialValue\n    try {\n      const item = window.localStorage.getItem(key)\n      return item ? (JSON.parse(item) as T) : initialValue\n    } catch (error) {\n      console.warn(`Error reading localStorage key \"${key}\":`, error)\n      return initialValue\n    }\n  }, [key, initialValue])\n\n  const [storedValue, setStoredValue] = useState<T>(readValue)\n\n  const setValue = useCallback((value: T | ((prev: T) => T)) => {\n    try {\n      const valueToStore = value instanceof Function ? value(storedValue) : value\n      setStoredValue(valueToStore)\n      if (typeof window !== 'undefined') {\n        window.localStorage.setItem(key, JSON.stringify(valueToStore))\n        // Dispatch event for cross-tab sync\n        window.dispatchEvent(new StorageEvent('storage', { key, newValue: JSON.stringify(valueToStore) }))\n      }\n    } catch (error) {\n      console.warn(`Error setting localStorage key \"${key}\":`, error)\n    }\n  }, [key, storedValue])\n\n  const removeValue = useCallback(() => {\n    try {\n      if (typeof window !== 'undefined') {\n        window.localStorage.removeItem(key)\n        setStoredValue(initialValue)\n      }\n    } catch (error) {\n      console.warn(`Error removing localStorage key \"${key}\":`, error)\n    }\n  }, [key, initialValue])\n\n  // Cross-tab synchronization\n  useEffect(() => {\n    const handleStorageChange = (e: StorageEvent) => {\n      if (e.key === key && e.newValue !== null) {\n        try {\n          setStoredValue(JSON.parse(e.newValue))\n        } catch {\n          setStoredValue(initialValue)\n        }\n      }\n    }\n    window.addEventListener('storage', handleStorageChange)\n    return () => window.removeEventListener('storage', handleStorageChange)\n  }, [key, initialValue])\n\n  return [storedValue, setValue, removeValue]\n}\n```\n\n### 3. useTimeout Hook (`useTimeout.ts`)\n\n**Target usage sites (5):**\n- `ResetPassword.tsx:125-129` - redirect after success\n- `AuthCallback.tsx:56-72` - auth redirect delay\n- `VerifyEmail.tsx:72-78` - verify redirect\n- `useUpload.ts:200-207` - retry delay\n- `autocomplete-field.tsx:179` - debounce close\n\n**Implementation:**\n```typescript\nimport { useEffect, useRef, useCallback } from 'react'\n\n/**\n * Safe setTimeout with automatic cleanup\n * @param callback - Function to execute\n * @param delay - Delay in ms (null to pause)\n */\nexport function useTimeout(callback: () => void, delay: number | null): void {\n  const savedCallback = useRef(callback)\n  \n  // Remember latest callback\n  useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n\n  useEffect(() => {\n    if (delay === null) return\n    const id = setTimeout(() => savedCallback.current(), delay)\n    return () => clearTimeout(id)\n  }, [delay])\n}\n\n/**\n * Returns a timeout controller for imperative usage\n * @returns { set, clear, isActive }\n */\nexport function useTimeoutFn(): {\n  set: (callback: () => void, delay: number) => void\n  clear: () => void\n  isActive: boolean\n} {\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null)\n  const isActiveRef = useRef(false)\n\n  const clear = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current)\n      timeoutRef.current = null\n      isActiveRef.current = false\n    }\n  }, [])\n\n  const set = useCallback((callback: () => void, delay: number) => {\n    clear()\n    isActiveRef.current = true\n    timeoutRef.current = setTimeout(() => {\n      isActiveRef.current = false\n      callback()\n    }, delay)\n  }, [clear])\n\n  // Cleanup on unmount\n  useEffect(() => clear, [clear])\n\n  return { set, clear, isActive: isActiveRef.current }\n}\n```\n\n### 4. useInterval Hook (`useInterval.ts`)\n\n**Target usage sites (4):**\n- `useApiData.ts:76` - 2min data refresh\n- `useApiData.ts:122` - 1min job polling\n- `useApiData.ts:189` - 1min metrics refresh\n- `KnowledgeBase.tsx:230` - document polling\n\n**Implementation:**\n```typescript\nimport { useEffect, useRef } from 'react'\n\n/**\n * Safe setInterval with automatic cleanup and pause support\n * @param callback - Function to execute on each interval\n * @param delay - Interval in ms (null to pause)\n */\nexport function useInterval(callback: () => void, delay: number | null): void {\n  const savedCallback = useRef(callback)\n\n  // Remember latest callback to avoid stale closures\n  useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n\n  useEffect(() => {\n    if (delay === null) return\n    const id = setInterval(() => savedCallback.current(), delay)\n    return () => clearInterval(id)\n  }, [delay])\n}\n\n/**\n * Interval with immediate first call option\n * @param callback - Function to execute\n * @param delay - Interval in ms (null to pause)\n * @param immediate - Run callback immediately on start\n */\nexport function useIntervalImmediate(\n  callback: () => void,\n  delay: number | null,\n  immediate: boolean = true\n): void {\n  const savedCallback = useRef(callback)\n  const hasRun = useRef(false)\n\n  useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n\n  useEffect(() => {\n    if (delay === null) return\n    \n    if (immediate && !hasRun.current) {\n      savedCallback.current()\n      hasRun.current = true\n    }\n    \n    const id = setInterval(() => savedCallback.current(), delay)\n    return () => clearInterval(id)\n  }, [delay, immediate])\n}\n```\n\n### 5. Barrel Export (`index.ts`)\n\n```typescript\n// Existing hooks\nexport * from './useDebounce'\nexport * from './useApiData'\nexport * from './useDocuments'\nexport * from './useDocumentActions'\nexport * from './useDocumentDetail'\nexport * from './useDocumentStats'\nexport * from './useJobPolling'\nexport * from './useUpload'\n\n// New foundation hooks\nexport * from './useToggle'\nexport * from './useLocalStorage'\nexport * from './useTimeout'\nexport * from './useInterval'\n```\n\n### Code Quality Requirements\n\n1. **Follow existing patterns** from `useDebounce.ts`:\n   - JSDoc comments with @param, @returns, @example\n   - Proper TypeScript generics where applicable\n   - `import * as React from 'react'` style (match codebase)\n\n2. **Memory leak prevention**:\n   - All timeouts/intervals must have cleanup functions\n   - Use useRef for mutable values to avoid stale closures\n   - Proper unmount cleanup via useEffect return\n\n3. **SSR compatibility**:\n   - Guard `window` and `localStorage` access with typeof checks\n   - Return sensible defaults during SSR\n\n4. **Performance optimizations**:\n   - Wrap callbacks in useCallback\n   - Use useRef for values that shouldn't trigger re-renders\n   - Avoid unnecessary re-renders in hook consumers",
        "testStrategy": "## Test Strategy\n\n### Test Framework\nUse Vitest with `@testing-library/react` following the existing pattern in `__tests__/useUpload.test.tsx`.\n\n### 1. useToggle Tests (`__tests__/useToggle.test.tsx`)\n```typescript\ndescribe('useToggle', () => {\n  it('initializes with default false value')\n  it('initializes with provided initial value')\n  it('toggles value when toggle() is called')\n  it('allows direct setValue calls')\n  it('toggle function is stable across renders (useCallback)')\n  it('works with React StrictMode double-render')\n})\n```\n\n### 2. useLocalStorage Tests (`__tests__/useLocalStorage.test.tsx`)\n```typescript\ndescribe('useLocalStorage', () => {\n  beforeEach(() => localStorage.clear())\n  \n  it('returns initial value when localStorage is empty')\n  it('returns stored value when localStorage has data')\n  it('updates localStorage when setValue is called')\n  it('handles JSON parsing errors gracefully')\n  it('supports functional updates like setState')\n  it('removeValue clears localStorage and resets to initial')\n  it('syncs across tabs via storage event')\n  it('handles SSR (typeof window === undefined) safely')\n})\n```\n\n### 3. useTimeout Tests (`__tests__/useTimeout.test.tsx`)\n```typescript\ndescribe('useTimeout', () => {\n  beforeEach(() => vi.useFakeTimers())\n  afterEach(() => vi.useRealTimers())\n  \n  it('calls callback after specified delay')\n  it('does not call callback when delay is null')\n  it('clears timeout on unmount (no memory leak)')\n  it('uses latest callback reference (no stale closure)')\n  it('resets timeout when delay changes')\n})\n\ndescribe('useTimeoutFn', () => {\n  it('set() starts a new timeout')\n  it('clear() cancels active timeout')\n  it('isActive reflects timeout state')\n  it('clears previous timeout when set() called again')\n})\n```\n\n### 4. useInterval Tests (`__tests__/useInterval.test.tsx`)\n```typescript\ndescribe('useInterval', () => {\n  beforeEach(() => vi.useFakeTimers())\n  afterEach(() => vi.useRealTimers())\n  \n  it('calls callback repeatedly at interval')\n  it('does not run when delay is null (paused)')\n  it('clears interval on unmount (no memory leak)')\n  it('uses latest callback reference (no stale closure)')\n  it('restarts interval when delay changes')\n})\n\ndescribe('useIntervalImmediate', () => {\n  it('runs callback immediately when immediate=true')\n  it('waits for first interval when immediate=false')\n  it('only runs immediate callback once even with re-renders')\n})\n```\n\n### 5. Integration Verification\n1. **Type checking**: `bun run typecheck` must pass\n2. **Lint**: `bun run lint` must pass with no new warnings\n3. **Build**: `bun run build` must succeed\n4. **All tests**: `bun run test` must pass including new tests\n\n### 6. Manual Verification\n1. Import hooks in a test component to verify barrel export works\n2. Verify hooks work in React StrictMode (double invocation)\n3. Check browser console for memory leak warnings after unmount\n\n### Expected Test Coverage\n- Each hook: 90%+ line coverage\n- Each hook: 100% branch coverage for critical paths (cleanup, null handling)",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 174,
        "title": "Implement useIntersectionObserver for Lazy Rendering in Grid Views",
        "description": "Create a useIntersectionObserver hook for lazy rendering of list items and integrate it into DocumentLibrary.tsx, ProfileList.tsx, Templates.tsx, and SearchInterface.tsx grid views to reduce DOM bloat by 60-70%.",
        "details": "## Implementation Details\n\n### Overview\nCreate a performant `useIntersectionObserver` hook following the established pattern in `quikadmin-web/src/hooks/useDebounce.ts` and integrate a wrapper component for lazy rendering in 4 grid view locations that currently render all items at once.\n\n### 1. Create useIntersectionObserver Hook (`quikadmin-web/src/hooks/useIntersectionObserver.ts`)\n\n```typescript\n/**\n * IntersectionObserver hook for lazy rendering and visibility detection\n * @module hooks/useIntersectionObserver\n */\n\nimport * as React from 'react'\n\nexport interface UseIntersectionObserverOptions {\n  /** IntersectionObserver threshold (0-1), default 0 */\n  threshold?: number | number[]\n  /** Root margin for early loading, default '100px 0px' */\n  rootMargin?: string\n  /** Element to use as viewport, default null (browser viewport) */\n  root?: Element | null\n  /** Freeze visibility state once visible (for lazy load), default true */\n  freezeOnceVisible?: boolean\n  /** Callback when visibility changes */\n  onVisibilityChange?: (isVisible: boolean) => void\n}\n\nexport interface UseIntersectionObserverReturn {\n  /** Ref to attach to the target element */\n  ref: React.RefCallback<Element>\n  /** Whether element is currently visible */\n  isVisible: boolean\n  /** The observed entry */\n  entry: IntersectionObserverEntry | null\n}\n\n/**\n * Hook to observe element visibility using IntersectionObserver API\n * \n * @example\n * ```tsx\n * function LazyCard({ children }) {\n *   const { ref, isVisible } = useIntersectionObserver({\n *     rootMargin: '200px 0px',\n *     freezeOnceVisible: true\n *   })\n *   \n *   return (\n *     <div ref={ref}>\n *       {isVisible ? children : <Skeleton />}\n *     </div>\n *   )\n * }\n * ```\n */\nexport function useIntersectionObserver({\n  threshold = 0,\n  rootMargin = '100px 0px',\n  root = null,\n  freezeOnceVisible = true,\n  onVisibilityChange\n}: UseIntersectionObserverOptions = {}): UseIntersectionObserverReturn\n```\n\nKey implementation points:\n- Use `React.useRef` for observer instance and frozen state\n- Use `React.useState` for `isVisible` and `entry`\n- Use `React.useCallback` for ref callback to handle element changes\n- Clean up observer on unmount via `React.useEffect`\n- Support SSR by checking `typeof IntersectionObserver !== 'undefined'`\n\n### 2. Create LazyRender Wrapper Component (`quikadmin-web/src/components/ui/lazy-render.tsx`)\n\n```typescript\ninterface LazyRenderProps {\n  children: React.ReactNode\n  /** Placeholder while not visible (default: null) */\n  placeholder?: React.ReactNode\n  /** Height for placeholder to prevent layout shift */\n  placeholderHeight?: number | string\n  /** Class for placeholder container */\n  placeholderClassName?: string\n  /** IntersectionObserver options */\n  rootMargin?: string\n  threshold?: number\n}\n\nexport function LazyRender({ \n  children, \n  placeholder,\n  placeholderHeight = 'auto',\n  placeholderClassName,\n  rootMargin = '200px 0px',\n  threshold = 0\n}: LazyRenderProps)\n```\n\n### 3. Integration Sites\n\n#### A. DocumentLibrary.tsx (lines 445-481)\nCurrent implementation renders all `DocumentCard` components at once in grid view.\n\n```typescript\n// Before: documents.map((doc) => <DocumentCard ... />)\n\n// After:\n{documents.map((doc) => (\n  <motion.div key={doc.id} variants={itemVariants} layoutId={doc.id} className=\"relative group\">\n    <LazyRender \n      placeholderHeight={256} // h-64\n      placeholderClassName=\"bg-muted/40 rounded-xl\"\n    >\n      {/* Selection Checkbox Overlay */}\n      <div className={cn(...)}>\n        <input type=\"checkbox\" ... />\n      </div>\n      <DocumentCard ... />\n    </LazyRender>\n  </motion.div>\n))}\n```\n\n#### B. ProfileList.tsx (lines 432-442)\nCurrent: `profiles.map((profile) => <ProfileCard ... />)`\n\nWrap each ProfileCard with LazyRender, using `placeholderHeight={180}` for grid cards.\n\n#### C. Templates.tsx (lines 514-522)\nCurrent: `filteredTemplates.map((template) => <TemplateCard ... />)`\n\nWrap each TemplateCard with LazyRender, using `placeholderHeight={280}` for template cards.\n\n#### D. SearchInterface.tsx (lines 382-384)\nCurrent: `searchResults.map((result, index) => <SearchResultCard ... />)`\n\nWrap each SearchResultCard with LazyRender, using `placeholderHeight={120}` for result cards.\n\n### 4. Memory Optimization Considerations\n\n- Use `freezeOnceVisible: true` to prevent re-observing after first render\n- Use appropriate `rootMargin` (200px default) for smooth scrolling\n- Consider batch rendering for very large lists (100+ items)\n- Maintain existing Framer Motion animations by placing LazyRender inside motion.div\n\n### 5. Export from Hooks Index\n\nCreate `quikadmin-web/src/hooks/index.ts` if not exists, or update to include:\n```typescript\nexport * from './useIntersectionObserver'\nexport * from './useDebounce'\n// ... other hooks\n```\n\n### 6. Test Setup Update\n\nThe test setup at `quikadmin-web/src/test/setup.tsx` (lines 116-121) already mocks IntersectionObserver but needs enhancement:\n\n```typescript\nglobal.IntersectionObserver = class IntersectionObserver {\n  callback: IntersectionObserverCallback\n  constructor(callback: IntersectionObserverCallback) {\n    this.callback = callback\n  }\n  observe(target: Element) {\n    // Immediately trigger with isIntersecting: true for tests\n    this.callback([{ isIntersecting: true, target } as IntersectionObserverEntry], this)\n  }\n  unobserve() {}\n  disconnect() {}\n} as any\n```",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useIntersectionObserver (`__tests__/useIntersectionObserver.test.tsx`)\n\n```typescript\nimport { renderHook, act } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\nimport { useIntersectionObserver } from '../useIntersectionObserver'\n\ndescribe('useIntersectionObserver', () => {\n  let mockObserver: any\n  let mockCallback: IntersectionObserverCallback\n\n  beforeEach(() => {\n    mockObserver = {\n      observe: vi.fn(),\n      unobserve: vi.fn(),\n      disconnect: vi.fn(),\n    }\n    global.IntersectionObserver = vi.fn((callback) => {\n      mockCallback = callback\n      return mockObserver\n    }) as any\n  })\n\n  it('initializes with isVisible false')\n  it('sets isVisible true when element intersects')\n  it('freezes visibility state when freezeOnceVisible is true')\n  it('toggles visibility when freezeOnceVisible is false')\n  it('calls onVisibilityChange callback when visibility changes')\n  it('cleans up observer on unmount')\n  it('handles ref reassignment correctly')\n  it('respects custom threshold and rootMargin options')\n  it('handles SSR gracefully (no IntersectionObserver)')\n})\n```\n\n### 2. Unit Tests for LazyRender Component (`__tests__/lazy-render.test.tsx`)\n\n```typescript\ndescribe('LazyRender', () => {\n  it('renders placeholder when not visible')\n  it('renders children when visible')\n  it('applies placeholderHeight style')\n  it('applies placeholderClassName to placeholder container')\n  it('maintains children after becoming visible (freeze behavior)')\n})\n```\n\n### 3. Integration Tests for Page Components\n\n#### DocumentLibrary Integration\n```typescript\n// quikadmin-web/src/pages/__tests__/DocumentLibrary.test.tsx\ndescribe('DocumentLibrary lazy rendering', () => {\n  it('renders placeholder skeletons for off-screen documents')\n  it('renders DocumentCard when scrolled into view')\n  it('maintains functionality after lazy load (click, select, etc.)')\n})\n```\n\n### 4. Performance Verification\n\nManual testing checklist:\n- [ ] Open DevTools Performance tab\n- [ ] Navigate to DocumentLibrary with 50+ documents\n- [ ] Verify initial DOM nodes reduced (compare before/after)\n- [ ] Scroll through list - confirm cards render smoothly\n- [ ] No visual glitches or layout shifts during lazy loading\n- [ ] Memory usage does not spike with large datasets\n\n### 5. DOM Node Count Verification\n\n```bash\n# In browser console before changes:\ndocument.querySelectorAll('[data-slot=\"document-card\"]').length\n# Should equal total document count\n\n# After changes (on initial load):\ndocument.querySelectorAll('[data-slot=\"document-card\"]').length  \n# Should be ~10-15 (visible + buffer) instead of total\n\n# After scrolling through all:\ndocument.querySelectorAll('[data-slot=\"document-card\"]').length\n# Should equal total (all have been rendered once)\n```\n\n### 6. Accessibility Verification\n\n- [ ] Keyboard navigation still works through lazy-loaded items\n- [ ] Screen readers can navigate the list\n- [ ] Focus management works correctly when items load\n\n### 7. Edge Cases\n\n- [ ] Empty list renders correctly\n- [ ] Single item list works\n- [ ] Rapid scrolling doesn't cause issues\n- [ ] Window resize triggers re-evaluation\n- [ ] Works with Framer Motion animations",
        "status": "pending",
        "dependencies": ["173"],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 175,
        "title": "Apply useDebouncedValue Hook to KnowledgeBase and DataTable Search Filters",
        "description": "Integrate the existing useDebouncedValue hook from hooks/useDebounce.ts into KnowledgeBase.tsx filter input and DataTable search input to reduce unnecessary filter computations by approximately 85% during rapid typing.",
        "details": "## Implementation Details\n\n### Overview\nThis is a quick-win optimization that applies the existing `useDebouncedValue` hook to two high-frequency filter/search inputs that currently trigger immediate computations on every keystroke.\n\n### 1. KnowledgeBase.tsx Filter (lines 157, 167-175, 322-330)\n\n**Current State:**\n```typescript\n// Line 157 - immediate state update triggers useMemo on every keystroke\nconst [searchFilter, setSearchFilter] = React.useState('')\n\n// Lines 167-175 - useMemo recomputes on every searchFilter change\nconst filteredSources = React.useMemo(() => {\n  if (!searchFilter) return sources\n  const lower = searchFilter.toLowerCase()\n  return sources.filter(\n    (s) =>\n      s.title.toLowerCase().includes(lower) ||\n      s.filename.toLowerCase().includes(lower)\n  )\n}, [sources, searchFilter])\n```\n\n**Required Changes:**\n```typescript\n// Add import at top of file\nimport { useDebouncedValue } from '@/hooks/useDebounce'\n\n// After line 157, add debounced value\nconst [searchFilter, setSearchFilter] = React.useState('')\nconst debouncedFilter = useDebouncedValue(searchFilter, 300) // 300ms delay\n\n// Update useMemo dependency to use debounced value\nconst filteredSources = React.useMemo(() => {\n  if (!debouncedFilter) return sources\n  const lower = debouncedFilter.toLowerCase()\n  return sources.filter(\n    (s) =>\n      s.title.toLowerCase().includes(lower) ||\n      s.filename.toLowerCase().includes(lower)\n  )\n}, [sources, debouncedFilter]) // Change dependency from searchFilter to debouncedFilter\n```\n\n**Note:** Keep using `searchFilter` (not debounced) for:\n- Input value display (line 327)\n- Empty state checks that show \"No documents match your filter\" (lines 346, 348, 353)\n- Clear filter button logic (line 356)\n\n### 2. DataTable Search (lines 150, 180-189, 229-235, 278-284)\n\n**Current State:**\n```typescript\n// Line 150 - immediate state update\nconst [searchQuery, setSearchQuery] = React.useState(\"\")\n\n// Lines 180-189 - filters on every keystroke\nconst filteredData = React.useMemo(() => {\n  if (!searchQuery) return data\n  return data.filter((row) =>\n    columns.some((column) => {\n      const value = row[column.key]\n      return value?.toString().toLowerCase().includes(searchQuery.toLowerCase())\n    })\n  )\n}, [data, searchQuery, columns])\n```\n\n**Required Changes:**\n```typescript\n// Add import at top of file\nimport { useDebouncedValue } from '@/hooks/useDebounce'\n\n// After line 150, add debounced value\nconst [searchQuery, setSearchQuery] = React.useState(\"\")\nconst debouncedQuery = useDebouncedValue(searchQuery, 300)\n\n// Update filteredData useMemo to use debounced value\nconst filteredData = React.useMemo(() => {\n  if (!debouncedQuery) return data\n  return data.filter((row) =>\n    columns.some((column) => {\n      const value = row[column.key]\n      return value?.toString().toLowerCase().includes(debouncedQuery.toLowerCase())\n    })\n  )\n}, [data, debouncedQuery, columns]) // Change dependency from searchQuery to debouncedQuery\n\n// Update handleSearch - keep immediate state for input display\nconst handleSearch = (query: string) => {\n  setSearchQuery(query)\n  setCurrentPage(1) // Still reset page immediately for UX\n  // Note: onSearch callback might need debounced value for external filtering\n  if (onSearch) {\n    // Consider: should this use debouncedQuery? Depends on use case\n    onSearch(query)\n  }\n}\n```\n\n**Note:** Keep using `searchQuery` (not debounced) for:\n- Input value display (line 280)\n- Empty state message check (line 301)\n\n### 3. Performance Consideration\n\nThe 300ms debounce delay matches the existing pattern in DocumentLibrary.tsx (line 103) and provides:\n- Immediate visual feedback (input shows typed characters instantly)\n- Reduced filter computations (filters only run 300ms after typing stops)\n- Approximately 85% reduction in filter function calls during rapid typing\n- No perceptible delay for users (300ms is below human perception threshold for \"lag\")\n\n### Files to Modify\n1. `quikadmin-web/src/pages/KnowledgeBase.tsx` - Add import, debounced value, update useMemo\n2. `quikadmin-web/src/components/features/data-table.tsx` - Add import, debounced value, update useMemo",
        "testStrategy": "## Test Strategy\n\n### 1. Manual Testing - KnowledgeBase Filter\n\n1. **Navigate to Knowledge Base page** with multiple document sources loaded\n2. **Type rapidly** in the filter input (e.g., \"test document\" quickly)\n3. **Verify:**\n   - Input text appears immediately (no typing lag)\n   - Filter results update approximately 300ms after stopping typing\n   - Filtered results are correct after debounce\n4. **Clear filter** - verify immediate response\n5. **Edge cases:**\n   - Empty filter returns all sources\n   - No matches shows \"No documents match your filter\" state\n   - Clear Filter button works correctly\n\n### 2. Manual Testing - DataTable Search\n\n1. **Navigate to any page using DataTable** (e.g., ProfileList or similar)\n2. **Type rapidly** in the search input\n3. **Verify:**\n   - Input text appears immediately\n   - Table filters approximately 300ms after stopping typing\n   - Pagination resets to page 1 on search\n   - Sort order is preserved after filtering\n4. **Edge cases:**\n   - Empty search returns all data\n   - No matches shows appropriate empty state\n\n### 3. Performance Verification\n\n1. **Add temporary console.log** inside the useMemo callbacks:\n   ```typescript\n   const filteredSources = React.useMemo(() => {\n     console.log('[KnowledgeBase] Filter computation triggered')\n     // ... rest of code\n   }, [sources, debouncedFilter])\n   ```\n2. **Type 10 characters rapidly** and count console logs\n3. **Expected:** 1-2 logs instead of 10 logs (85%+ reduction)\n4. **Remove console.log** after verification\n\n### 4. Unit Tests (Optional Enhancement)\n\nAdd test in `quikadmin-web/src/hooks/__tests__/useDebounce.test.tsx`:\n```typescript\ndescribe('useDebouncedValue', () => {\n  it('debounces rapid value changes', async () => {\n    const { result, rerender } = renderHook(\n      ({ value }) => useDebouncedValue(value, 300),\n      { initialProps: { value: '' } }\n    )\n    \n    // Rapid updates\n    rerender({ value: 'a' })\n    rerender({ value: 'ab' })\n    rerender({ value: 'abc' })\n    \n    // Value should still be empty (debouncing)\n    expect(result.current).toBe('')\n    \n    // Wait for debounce\n    await act(async () => {\n      await new Promise(resolve => setTimeout(resolve, 350))\n    })\n    \n    // Now should have final value\n    expect(result.current).toBe('abc')\n  })\n})\n```\n\n### 5. Regression Testing\n\n1. **Verify DocumentLibrary.tsx** still works (uses same pattern)\n2. **Verify SearchInterface.tsx** still works (uses same hook)\n3. **Run existing frontend tests**: `bun run test`\n4. **Run type checking**: `bun run typecheck`",
        "status": "pending",
        "dependencies": [173],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 176,
        "title": "Implement Batch Polling with Exponential Backoff for KnowledgeBase Processing Status",
        "description": "Refactor the N+1 polling anti-pattern in KnowledgeBase.tsx (lines 222-235) that currently makes individual API calls for each processing document every 5 seconds. Implement batch refresh using useInterval hook with jitter and exponential backoff to reduce API calls by ~80%.",
        "details": "## Implementation Details\n\n### Overview\nThe current implementation in `KnowledgeBase.tsx:222-235` calls `refreshSource(id)` for **each** processing document individually every 5 seconds, causing a thundering herd problem when multiple documents are processing simultaneously. This needs to be replaced with:\n1. A single batch API call to refresh all processing sources at once\n2. A `useInterval` hook with jitter and exponential backoff\n\n### 1. Create useInterval Hook (`quikadmin-web/src/hooks/useInterval.ts`)\n\nFollow the pattern established in `useDebounce.ts`:\n\n```typescript\n/**\n * Interval hook with jitter and exponential backoff\n * @module hooks/useInterval\n */\nimport * as React from 'react'\n\ninterface UseIntervalOptions {\n  /** Base interval in milliseconds (default: 5000) */\n  delay: number\n  /** Enable/disable the interval (default: true) */\n  enabled?: boolean\n  /** Add random jitter to prevent thundering herd (0-1, default: 0.2 = ±20%) */\n  jitter?: number\n  /** Use exponential backoff on consecutive unchanged responses */\n  exponentialBackoff?: boolean\n  /** Maximum delay when using exponential backoff (default: 30000ms) */\n  maxDelay?: number\n  /** Backoff multiplier (default: 1.5) */\n  backoffMultiplier?: number\n}\n\nexport function useInterval(\n  callback: () => void | Promise<void>,\n  options: UseIntervalOptions\n): {\n  reset: () => void  // Reset backoff to initial delay\n  pause: () => void\n  resume: () => void\n} {\n  const { \n    delay, \n    enabled = true, \n    jitter = 0.2, \n    exponentialBackoff = false,\n    maxDelay = 30000,\n    backoffMultiplier = 1.5\n  } = options\n  \n  const savedCallback = React.useRef(callback)\n  const intervalRef = React.useRef<NodeJS.Timeout | null>(null)\n  const currentDelayRef = React.useRef(delay)\n  const isPausedRef = React.useRef(false)\n  \n  // Update callback ref on each render\n  React.useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n  \n  const calculateDelay = React.useCallback(() => {\n    let currentDelay = currentDelayRef.current\n    \n    // Apply jitter: ±jitter% of current delay\n    const jitterAmount = currentDelay * jitter\n    const jitteredDelay = currentDelay + (Math.random() * 2 - 1) * jitterAmount\n    \n    return Math.round(jitteredDelay)\n  }, [jitter])\n  \n  const scheduleNext = React.useCallback(() => {\n    if (!enabled || isPausedRef.current) return\n    \n    intervalRef.current = setTimeout(async () => {\n      await savedCallback.current()\n      \n      // Apply exponential backoff if enabled\n      if (exponentialBackoff) {\n        currentDelayRef.current = Math.min(\n          currentDelayRef.current * backoffMultiplier,\n          maxDelay\n        )\n      }\n      \n      scheduleNext()\n    }, calculateDelay())\n  }, [enabled, calculateDelay, exponentialBackoff, backoffMultiplier, maxDelay])\n  \n  const reset = React.useCallback(() => {\n    currentDelayRef.current = delay\n    if (intervalRef.current) {\n      clearTimeout(intervalRef.current)\n    }\n    scheduleNext()\n  }, [delay, scheduleNext])\n  \n  const pause = React.useCallback(() => {\n    isPausedRef.current = true\n    if (intervalRef.current) {\n      clearTimeout(intervalRef.current)\n    }\n  }, [])\n  \n  const resume = React.useCallback(() => {\n    isPausedRef.current = false\n    scheduleNext()\n  }, [scheduleNext])\n  \n  React.useEffect(() => {\n    if (enabled && !isPausedRef.current) {\n      scheduleNext()\n    }\n    \n    return () => {\n      if (intervalRef.current) {\n        clearTimeout(intervalRef.current)\n      }\n    }\n  }, [enabled, scheduleNext])\n  \n  return { reset, pause, resume }\n}\n```\n\n### 2. Add Batch Refresh to knowledgeService.ts\n\nAdd new batch endpoint function to `quikadmin-web/src/services/knowledgeService.ts`:\n\n```typescript\n/**\n * Batch refresh multiple document sources by IDs\n * More efficient than multiple individual calls\n */\nexport const getKnowledgeSourcesBatch = async (\n  sourceIds: string[]\n): Promise<{\n  success: boolean;\n  sources: (DocumentSource & { chunkCount: number })[];\n}> => {\n  if (sourceIds.length === 0) {\n    return { success: true, sources: [] }\n  }\n  const response = await api.post('/knowledge/sources/batch', { ids: sourceIds });\n  return response.data;\n};\n```\n\n### 3. Add Batch Refresh Action to knowledgeStore.ts\n\nAdd to `KnowledgeState` interface (around line 76):\n```typescript\nrefreshSourcesBatch: (sourceIds: string[]) => Promise<void>;\n```\n\nAdd implementation (after `refreshSource`):\n```typescript\nrefreshSourcesBatch: async (sourceIds) => {\n  if (sourceIds.length === 0) return;\n  \n  try {\n    const response = await knowledgeService.getKnowledgeSourcesBatch(sourceIds);\n    \n    set((state) => {\n      for (const source of response.sources) {\n        const index = state.sources.findIndex((s) => s.id === source.id);\n        if (index !== -1) {\n          state.sources[index] = source;\n        }\n      }\n    });\n  } catch (error) {\n    console.error('Failed to batch refresh sources:', error);\n  }\n},\n```\n\n### 4. Update Backend to Support Batch Endpoint (if not exists)\n\nCheck if `/api/knowledge/sources/batch` exists in backend. If not, add to `quikadmin/src/routes/knowledge.ts`:\n\n```typescript\n// POST /api/knowledge/sources/batch - Batch get sources by IDs\nrouter.post('/sources/batch', async (req, res) => {\n  const { ids } = req.body;\n  \n  if (!Array.isArray(ids) || ids.length === 0) {\n    return res.status(400).json({ success: false, error: 'IDs array required' });\n  }\n  \n  // Limit batch size to prevent abuse\n  if (ids.length > 50) {\n    return res.status(400).json({ success: false, error: 'Maximum 50 IDs per batch' });\n  }\n  \n  const sources = await prisma.documentSource.findMany({\n    where: { id: { in: ids }, organizationId: req.user.organizationId },\n    include: { _count: { select: { chunks: true } } }\n  });\n  \n  res.json({\n    success: true,\n    sources: sources.map(s => ({ ...s, chunkCount: s._count.chunks }))\n  });\n});\n```\n\n### 5. Refactor KnowledgeBase.tsx (lines 222-235)\n\nReplace the current N+1 polling implementation:\n\n```typescript\n// OLD CODE (DELETE):\n// React.useEffect(() => {\n//   const processingIds = sources\n//     .filter((s) => s.status === 'PROCESSING' || s.status === 'PENDING')\n//     .map((s) => s.id)\n//   if (processingIds.length === 0) return\n//   const interval = setInterval(() => {\n//     processingIds.forEach((id) => refreshSource(id))\n//   }, 5000)\n//   return () => clearInterval(interval)\n// }, [sources, refreshSource])\n\n// NEW CODE:\nimport { useInterval } from '@/hooks/useInterval'\n\n// Inside component, get batch refresh action:\nconst { refreshSourcesBatch } = useKnowledgeStore()\n\n// Track processing IDs with useMemo to avoid recalculating on every render\nconst processingIds = React.useMemo(() => \n  sources\n    .filter((s) => s.status === 'PROCESSING' || s.status === 'PENDING')\n    .map((s) => s.id),\n  [sources]\n)\n\n// Use the new useInterval hook with batch refresh\nconst { reset: resetPolling } = useInterval(\n  async () => {\n    if (processingIds.length > 0) {\n      await refreshSourcesBatch(processingIds)\n    }\n  },\n  {\n    delay: 5000,\n    enabled: processingIds.length > 0,\n    jitter: 0.2, // ±20% jitter to prevent thundering herd\n    exponentialBackoff: true,\n    maxDelay: 30000, // Max 30 seconds between polls\n    backoffMultiplier: 1.5\n  }\n)\n\n// Reset polling when a new document starts processing\nReact.useEffect(() => {\n  if (processingIds.length > 0) {\n    resetPolling()\n  }\n}, [processingIds.length, resetPolling])\n```\n\n### 6. Export from hooks/index.ts\n\nAdd to `quikadmin-web/src/hooks/index.ts`:\n```typescript\nexport { useInterval } from './useInterval'\n```\n\n### Files to Modify:\n1. `quikadmin-web/src/hooks/useInterval.ts` (NEW)\n2. `quikadmin-web/src/hooks/index.ts` (UPDATE - add export)\n3. `quikadmin-web/src/services/knowledgeService.ts` (ADD batch function)\n4. `quikadmin-web/src/stores/knowledgeStore.ts` (ADD refreshSourcesBatch action)\n5. `quikadmin-web/src/pages/KnowledgeBase.tsx` (REFACTOR lines 222-235)\n6. `quikadmin/src/routes/knowledge.ts` (ADD batch endpoint if missing)\n\n### API Call Reduction Math:\n- Before: 10 processing docs × 12 polls/min = 120 API calls/min\n- After: 1 batch call × 12 polls/min (reducing with backoff) = ~8-12 API calls/min\n- Savings: **~90% reduction in API calls**",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useInterval Hook (`__tests__/useInterval.test.tsx`)\n\n```typescript\nimport { renderHook, act, waitFor } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { useInterval } from '../useInterval'\n\ndescribe('useInterval', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n  })\n  \n  afterEach(() => {\n    vi.useRealTimers()\n  })\n  \n  it('calls callback at specified interval', async () => {\n    const callback = vi.fn()\n    renderHook(() => useInterval(callback, { delay: 1000 }))\n    \n    await act(async () => {\n      vi.advanceTimersByTime(3000)\n    })\n    \n    expect(callback).toHaveBeenCalledTimes(3)\n  })\n  \n  it('does not call callback when disabled', () => {\n    const callback = vi.fn()\n    renderHook(() => useInterval(callback, { delay: 1000, enabled: false }))\n    \n    vi.advanceTimersByTime(5000)\n    \n    expect(callback).not.toHaveBeenCalled()\n  })\n  \n  it('applies jitter to delay', async () => {\n    const callback = vi.fn()\n    const delays: number[] = []\n    \n    // Mock setTimeout to capture actual delays\n    const originalSetTimeout = globalThis.setTimeout\n    vi.spyOn(globalThis, 'setTimeout').mockImplementation((fn, delay) => {\n      delays.push(delay as number)\n      return originalSetTimeout(fn, delay)\n    })\n    \n    renderHook(() => useInterval(callback, { delay: 1000, jitter: 0.2 }))\n    \n    await act(async () => {\n      vi.advanceTimersByTime(5000)\n    })\n    \n    // Check delays are within jitter range (800-1200ms)\n    delays.forEach(d => {\n      expect(d).toBeGreaterThanOrEqual(800)\n      expect(d).toBeLessThanOrEqual(1200)\n    })\n  })\n  \n  it('applies exponential backoff', async () => {\n    const callback = vi.fn()\n    renderHook(() => useInterval(callback, { \n      delay: 1000, \n      exponentialBackoff: true,\n      backoffMultiplier: 2,\n      maxDelay: 10000\n    }))\n    \n    // After several iterations, delay should increase\n    await act(async () => {\n      vi.advanceTimersByTime(50000)\n    })\n    \n    // Verify backoff occurred (fewer calls than linear would produce)\n    expect(callback.mock.calls.length).toBeLessThan(50)\n  })\n  \n  it('reset() restores initial delay', async () => {\n    const callback = vi.fn()\n    const { result } = renderHook(() => useInterval(callback, { \n      delay: 1000, \n      exponentialBackoff: true,\n      maxDelay: 10000\n    }))\n    \n    await act(async () => {\n      vi.advanceTimersByTime(10000)\n    })\n    \n    act(() => {\n      result.current.reset()\n    })\n    \n    // After reset, should poll at initial rate again\n    const callsBefore = callback.mock.calls.length\n    await act(async () => {\n      vi.advanceTimersByTime(1000)\n    })\n    \n    expect(callback.mock.calls.length).toBeGreaterThan(callsBefore)\n  })\n  \n  it('pause() and resume() work correctly', () => {\n    const callback = vi.fn()\n    const { result } = renderHook(() => useInterval(callback, { delay: 1000 }))\n    \n    vi.advanceTimersByTime(2500)\n    expect(callback).toHaveBeenCalledTimes(2)\n    \n    act(() => result.current.pause())\n    vi.advanceTimersByTime(5000)\n    expect(callback).toHaveBeenCalledTimes(2) // No new calls\n    \n    act(() => result.current.resume())\n    vi.advanceTimersByTime(2000)\n    expect(callback).toHaveBeenCalledTimes(4)\n  })\n})\n```\n\n### 2. Integration Tests for KnowledgeBase Polling\n\n```typescript\n// In knowledgeStore.test.ts, add:\ndescribe('refreshSourcesBatch', () => {\n  it('batch updates multiple sources in single call', async () => {\n    const mockSources = [\n      { id: '1', title: 'Doc 1', status: 'READY', chunkCount: 5 },\n      { id: '2', title: 'Doc 2', status: 'READY', chunkCount: 3 },\n    ]\n    \n    vi.mocked(knowledgeService.getKnowledgeSourcesBatch).mockResolvedValue({\n      success: true,\n      sources: mockSources as any,\n    })\n    \n    // Set initial state with PROCESSING documents\n    useKnowledgeStore.setState({\n      sources: [\n        { id: '1', title: 'Doc 1', status: 'PROCESSING' },\n        { id: '2', title: 'Doc 2', status: 'PROCESSING' },\n      ] as any,\n    })\n    \n    await useKnowledgeStore.getState().refreshSourcesBatch(['1', '2'])\n    \n    expect(knowledgeService.getKnowledgeSourcesBatch).toHaveBeenCalledWith(['1', '2'])\n    expect(useKnowledgeStore.getState().sources[0].status).toBe('READY')\n    expect(useKnowledgeStore.getState().sources[1].status).toBe('READY')\n  })\n  \n  it('handles empty IDs array gracefully', async () => {\n    await useKnowledgeStore.getState().refreshSourcesBatch([])\n    expect(knowledgeService.getKnowledgeSourcesBatch).not.toHaveBeenCalled()\n  })\n})\n```\n\n### 3. Manual Testing Checklist\n\n1. **Upload 3+ documents simultaneously**\n   - [ ] Open browser DevTools Network tab\n   - [ ] Upload 3 documents at once\n   - [ ] Verify only ONE batch API call per poll interval (not 3 individual calls)\n   - [ ] Confirm all documents show processing status updates\n\n2. **Jitter Verification**\n   - [ ] Watch Network tab timing for batch calls\n   - [ ] Verify intervals vary slightly (±20% of 5 seconds = 4-6 seconds)\n   - [ ] Multiple browser tabs should NOT poll at exact same time\n\n3. **Exponential Backoff Test**\n   - [ ] Upload document, watch Network tab\n   - [ ] Initial polls: ~5 seconds apart\n   - [ ] After 30+ seconds: intervals should increase\n   - [ ] Maximum interval should not exceed 30 seconds\n\n4. **Backoff Reset Test**\n   - [ ] Let backoff increase to 20+ seconds\n   - [ ] Upload a new document\n   - [ ] Verify polling resets to 5-second interval\n\n5. **API Call Count Verification**\n   - [ ] Count API calls over 1 minute with 5 processing documents\n   - [ ] Before fix: ~60 calls (5 docs × 12 polls/min)\n   - [ ] After fix: ~12 calls or fewer (1 batch × 12 polls, decreasing with backoff)\n   - [ ] Reduction should be ~80-90%\n\n### 4. Backend Batch Endpoint Test\n\n```bash\n# Test batch endpoint directly\ncurl -X POST http://localhost:3002/api/knowledge/sources/batch \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"ids\": [\"source-id-1\", \"source-id-2\"]}'\n\n# Verify response contains both sources\n# Verify 400 error for empty array\n# Verify 400 error for array > 50 items\n```\n\n### 5. Performance Metrics\n\nMonitor these before/after metrics:\n- API calls per minute during processing\n- Backend request queue depth\n- Database query count for source lookups\n- Frontend re-render count (React DevTools Profiler)",
        "status": "pending",
        "dependencies": [173],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 177,
        "title": "Create useKeyPress Hook for Keyboard Shortcuts",
        "description": "Create a useKeyPress hook in quikadmin-web/src/hooks/ for declarative keyboard shortcut handling and apply it to DocumentLibrary.tsx (lines 191-216) and search-bar.tsx (lines 94-110) to replace manual window.addEventListener patterns with proper cleanup and improved maintainability.",
        "details": "## Implementation Details\n\n### Overview\nCreate a reusable `useKeyPress` hook following the established pattern in `quikadmin-web/src/hooks/useDebounce.ts` with proper TypeScript types, JSDoc documentation, and memory leak prevention. This hook will provide a declarative API for keyboard shortcuts, replacing the manual `window.addEventListener` patterns found in 2 locations.\n\n### 1. Create useKeyPress Hook (`quikadmin-web/src/hooks/useKeyPress.ts`)\n\n```typescript\n/**\n * Keyboard shortcut hook for React\n * @module hooks/useKeyPress\n */\n\nimport * as React from 'react'\n\nexport interface KeyPressOptions {\n  /** Key to listen for (e.g., 'a', 'Escape', 'Delete', 'k') */\n  key: string\n  /** Require Ctrl/Cmd modifier */\n  ctrlOrMeta?: boolean\n  /** Require Shift modifier */\n  shift?: boolean\n  /** Require Alt modifier */\n  alt?: boolean\n  /** Callback when key combination is pressed */\n  onPress: (event: KeyboardEvent) => void\n  /** Whether to prevent default browser behavior */\n  preventDefault?: boolean\n  /** Whether the shortcut is currently enabled */\n  enabled?: boolean\n  /** Target element (defaults to window) */\n  target?: EventTarget | null\n}\n\nexport interface KeyPressBinding {\n  key: string\n  ctrlOrMeta?: boolean\n  shift?: boolean\n  alt?: boolean\n  onPress: (event: KeyboardEvent) => void\n  preventDefault?: boolean\n  enabled?: boolean\n}\n\n/**\n * Hook for handling single keyboard shortcut\n *\n * @example\n * ```tsx\n * // Ctrl/Cmd + A to select all\n * useKeyPress({\n *   key: 'a',\n *   ctrlOrMeta: true,\n *   onPress: () => handleSelectAll(),\n *   enabled: documents.length > 0\n * })\n * ```\n */\nexport function useKeyPress(options: KeyPressOptions): void {\n  const { \n    key, \n    ctrlOrMeta = false, \n    shift = false, \n    alt = false,\n    onPress, \n    preventDefault = true,\n    enabled = true,\n    target\n  } = options\n\n  const savedCallback = React.useRef(onPress)\n  \n  // Update ref when callback changes\n  React.useLayoutEffect(() => {\n    savedCallback.current = onPress\n  }, [onPress])\n\n  React.useEffect(() => {\n    if (!enabled) return\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const keyMatch = e.key.toLowerCase() === key.toLowerCase()\n      const ctrlMatch = !ctrlOrMeta || (e.ctrlKey || e.metaKey)\n      const shiftMatch = !shift || e.shiftKey\n      const altMatch = !alt || e.altKey\n      \n      if (keyMatch && ctrlMatch && shiftMatch && altMatch) {\n        if (preventDefault) {\n          e.preventDefault()\n        }\n        savedCallback.current(e)\n      }\n    }\n\n    const eventTarget = target ?? window\n    eventTarget.addEventListener('keydown', handleKeyDown as EventListener)\n    \n    return () => {\n      eventTarget.removeEventListener('keydown', handleKeyDown as EventListener)\n    }\n  }, [key, ctrlOrMeta, shift, alt, preventDefault, enabled, target])\n}\n\n/**\n * Hook for handling multiple keyboard shortcuts\n *\n * @example\n * ```tsx\n * useKeyPressBindings([\n *   { key: 'a', ctrlOrMeta: true, onPress: handleSelectAll },\n *   { key: 'Escape', onPress: handleClear },\n *   { key: 'Delete', onPress: handleDelete, enabled: selectionCount > 0 },\n *   { key: 'f', ctrlOrMeta: true, onPress: focusSearch },\n * ])\n * ```\n */\nexport function useKeyPressBindings(bindings: KeyPressBinding[]): void {\n  const savedBindings = React.useRef(bindings)\n  \n  React.useLayoutEffect(() => {\n    savedBindings.current = bindings\n  }, [bindings])\n\n  React.useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      for (const binding of savedBindings.current) {\n        if (binding.enabled === false) continue\n        \n        const keyMatch = e.key.toLowerCase() === binding.key.toLowerCase()\n        const ctrlMatch = !binding.ctrlOrMeta || (e.ctrlKey || e.metaKey)\n        const shiftMatch = !binding.shift || e.shiftKey\n        const altMatch = !binding.alt || e.altKey\n        \n        if (keyMatch && ctrlMatch && shiftMatch && altMatch) {\n          if (binding.preventDefault !== false) {\n            e.preventDefault()\n          }\n          binding.onPress(e)\n          return // Only handle first matching binding\n        }\n      }\n    }\n\n    window.addEventListener('keydown', handleKeyDown)\n    return () => window.removeEventListener('keydown', handleKeyDown)\n  }, [])\n}\n```\n\n### 2. Refactor DocumentLibrary.tsx (lines 191-216)\n\n**Before (current manual implementation):**\n```typescript\nReact.useEffect(() => {\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if ((e.ctrlKey || e.metaKey) && e.key === 'a' && documents.length > 0) {\n      e.preventDefault();\n      handleSelectAll();\n    }\n    // ... more cases\n  };\n  window.addEventListener('keydown', handleKeyDown);\n  return () => window.removeEventListener('keydown', handleKeyDown);\n}, [documents, selectionCount, selectedDocumentId, handleSelectAll, clearSelection, handleBulkDelete]);\n```\n\n**After (using useKeyPressBindings):**\n```typescript\nimport { useKeyPressBindings } from '@/hooks/useKeyPress'\n\n// Replace lines 191-216 with:\nuseKeyPressBindings([\n  { \n    key: 'a', \n    ctrlOrMeta: true, \n    onPress: handleSelectAll,\n    enabled: documents.length > 0 \n  },\n  { \n    key: 'Escape', \n    onPress: () => {\n      if (selectedDocumentId) setSelectedDocumentId(null)\n      else if (selectionCount > 0) clearSelection()\n    },\n    preventDefault: false\n  },\n  { \n    key: 'Delete', \n    onPress: handleBulkDelete,\n    enabled: selectionCount > 0 \n  },\n  { \n    key: 'f', \n    ctrlOrMeta: true, \n    onPress: () => document.getElementById('document-search')?.focus()\n  },\n])\n```\n\n### 3. Refactor search-bar.tsx (lines 94-110)\n\n**Before (current manual implementation):**\n```typescript\nReact.useEffect(() => {\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if ((e.ctrlKey || e.metaKey) && e.key === \"k\") {\n      e.preventDefault()\n      inputRef.current?.focus()\n    }\n    if (e.key === \"Escape\" && value && document.activeElement === inputRef.current) {\n      onChange(\"\")\n      inputRef.current?.blur()\n    }\n  }\n  window.addEventListener(\"keydown\", handleKeyDown)\n  return () => window.removeEventListener(\"keydown\", handleKeyDown)\n}, [value, onChange])\n```\n\n**After (using useKeyPressBindings):**\n```typescript\nimport { useKeyPressBindings } from '@/hooks/useKeyPress'\n\n// Replace lines 94-110 with:\nuseKeyPressBindings([\n  { \n    key: 'k', \n    ctrlOrMeta: true, \n    onPress: () => inputRef.current?.focus()\n  },\n  { \n    key: 'Escape', \n    onPress: () => {\n      if (value && document.activeElement === inputRef.current) {\n        onChange(\"\")\n        inputRef.current?.blur()\n      }\n    },\n    preventDefault: false,\n    enabled: Boolean(value)\n  },\n])\n\n### 4. Export from hooks index (create if needed)\n\nIf `quikadmin-web/src/hooks/index.ts` doesn't exist, create it:\n```typescript\nexport * from './useDebounce'\nexport * from './useKeyPress'\nexport * from './useDocuments'\nexport * from './useDocumentDetail'\nexport * from './useDocumentStats'\nexport * from './useDocumentActions'\nexport * from './useUpload'\nexport * from './useJobPolling'\nexport * from './useApiData'\n```\n\n### Key Design Decisions\n\n1. **useRef for callbacks**: Prevents stale closure issues without requiring callback in deps array\n2. **useLayoutEffect for refs**: Ensures ref is updated synchronously before any effects run\n3. **enabled flag**: Allows conditional activation without remounting the effect\n4. **ctrlOrMeta**: Abstracts cross-platform modifier (Ctrl on Windows, Cmd on Mac)\n5. **preventDefault default true**: Most keyboard shortcuts should prevent browser defaults\n6. **Single handler in useKeyPressBindings**: More efficient than multiple event listeners",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for useKeyPress (`__tests__/useKeyPress.test.tsx`)\n\n```typescript\nimport { renderHook, act } from '@testing-library/react'\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'\nimport { useKeyPress, useKeyPressBindings } from '../useKeyPress'\n\ndescribe('useKeyPress', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n  })\n\n  afterEach(() => {\n    vi.useRealTimers()\n  })\n\n  it('calls onPress when key is pressed', () => {\n    const onPress = vi.fn()\n    renderHook(() => useKeyPress({ key: 'a', onPress }))\n\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'a' }))\n    })\n\n    expect(onPress).toHaveBeenCalledTimes(1)\n  })\n\n  it('requires ctrlOrMeta when specified', () => {\n    const onPress = vi.fn()\n    renderHook(() => useKeyPress({ key: 'a', ctrlOrMeta: true, onPress }))\n\n    // Without modifier - should not trigger\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'a' }))\n    })\n    expect(onPress).not.toHaveBeenCalled()\n\n    // With Ctrl - should trigger\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'a', ctrlKey: true }))\n    })\n    expect(onPress).toHaveBeenCalledTimes(1)\n\n    // With Meta - should trigger\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'a', metaKey: true }))\n    })\n    expect(onPress).toHaveBeenCalledTimes(2)\n  })\n\n  it('does not call onPress when enabled is false', () => {\n    const onPress = vi.fn()\n    renderHook(() => useKeyPress({ key: 'Delete', onPress, enabled: false }))\n\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Delete' }))\n    })\n\n    expect(onPress).not.toHaveBeenCalled()\n  })\n\n  it('prevents default when preventDefault is true', () => {\n    const onPress = vi.fn()\n    renderHook(() => useKeyPress({ key: 'f', ctrlOrMeta: true, onPress, preventDefault: true }))\n\n    const event = new KeyboardEvent('keydown', { key: 'f', ctrlKey: true })\n    const preventDefaultSpy = vi.spyOn(event, 'preventDefault')\n\n    act(() => {\n      window.dispatchEvent(event)\n    })\n\n    expect(preventDefaultSpy).toHaveBeenCalled()\n  })\n\n  it('cleans up event listener on unmount', () => {\n    const onPress = vi.fn()\n    const removeEventListenerSpy = vi.spyOn(window, 'removeEventListener')\n    \n    const { unmount } = renderHook(() => useKeyPress({ key: 'Escape', onPress }))\n    unmount()\n\n    expect(removeEventListenerSpy).toHaveBeenCalledWith('keydown', expect.any(Function))\n  })\n})\n\ndescribe('useKeyPressBindings', () => {\n  it('handles multiple bindings', () => {\n    const onPressA = vi.fn()\n    const onPressEscape = vi.fn()\n    \n    renderHook(() => useKeyPressBindings([\n      { key: 'a', ctrlOrMeta: true, onPress: onPressA },\n      { key: 'Escape', onPress: onPressEscape },\n    ]))\n\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'a', ctrlKey: true }))\n    })\n    expect(onPressA).toHaveBeenCalledTimes(1)\n    expect(onPressEscape).not.toHaveBeenCalled()\n\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape' }))\n    })\n    expect(onPressEscape).toHaveBeenCalledTimes(1)\n  })\n\n  it('respects enabled flag per binding', () => {\n    const onPressDelete = vi.fn()\n    \n    const { rerender } = renderHook(\n      ({ enabled }) => useKeyPressBindings([\n        { key: 'Delete', onPress: onPressDelete, enabled }\n      ]),\n      { initialProps: { enabled: false } }\n    )\n\n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Delete' }))\n    })\n    expect(onPressDelete).not.toHaveBeenCalled()\n\n    rerender({ enabled: true })\n    \n    act(() => {\n      window.dispatchEvent(new KeyboardEvent('keydown', { key: 'Delete' }))\n    })\n    expect(onPressDelete).toHaveBeenCalledTimes(1)\n  })\n})\n```\n\n### 2. Integration Testing - DocumentLibrary.tsx\n\n1. **Navigate to Document Library** at `/documents`\n2. **Test Ctrl+A (Select All)**:\n   - With documents loaded, press Ctrl+A (Windows) or Cmd+A (Mac)\n   - Verify all documents are selected\n   - Verify browser's native select-all is prevented\n3. **Test Escape (Clear Selection)**:\n   - With documents selected, press Escape\n   - Verify selection is cleared\n   - With document detail panel open, press Escape\n   - Verify detail panel closes first\n4. **Test Delete (Bulk Delete)**:\n   - Select 2+ documents\n   - Press Delete key\n   - Verify delete confirmation appears\n5. **Test Ctrl+F (Focus Search)**:\n   - Press Ctrl+F (Windows) or Cmd+F (Mac)\n   - Verify search input is focused\n   - Verify browser's native find dialog is prevented\n\n### 3. Integration Testing - SearchBar Component\n\n1. **Test Ctrl+K (Focus Search)**:\n   - On any page with SearchBar\n   - Press Ctrl+K (Windows) or Cmd+K (Mac)\n   - Verify search input is focused\n2. **Test Escape (Clear and Blur)**:\n   - Type a search query\n   - Press Escape\n   - Verify input is cleared and blurred\n\n### 4. Memory Leak Verification\n\n1. Navigate between pages multiple times\n2. Check browser DevTools Memory panel for listener leaks\n3. Use React DevTools to verify hooks unmount cleanly\n\n### 5. Regression Testing\n\nRun the existing test suite to ensure no regressions:\n```bash\ncd quikadmin-web && bun run test\n```",
        "status": "pending",
        "dependencies": [173],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 178,
        "title": "Refactor Boolean useState Patterns to useToggle Hook Across Codebase",
        "description": "Refactor 25+ boolean useState patterns throughout the frontend codebase to use the foundational useToggle hook from Task 173, reducing boilerplate code and improving consistency in state toggle patterns.",
        "details": "## Implementation Details\n\n### Overview\nThis task systematically replaces manual `useState(false)` / `useState(true)` patterns with the `useToggle` hook created in Task 173. The codebase contains 50+ instances of boolean useState patterns across 25+ files, with priority focus on 4 key files identified with highest impact.\n\n### 1. Priority File Refactors\n\n#### A. autocomplete-field.tsx (Lines 95-99) - 3 booleans\n**Current State:**\n```typescript\nconst [isOpen, setIsOpen] = React.useState(false);\nconst [isLoading, setIsLoading] = React.useState(false);\nconst [isFocused, setIsFocused] = React.useState(false);\n```\n\n**Refactored State:**\n```typescript\nimport { useToggle } from '@/hooks/useToggle';\n\nconst [isOpen, toggleOpen, setIsOpen] = useToggle(false);\nconst [isLoading, toggleLoading, setIsLoading] = useToggle(false);\nconst [isFocused, toggleFocused, setIsFocused] = useToggle(false);\n```\n\n**Usage Updates:**\n- Line 131: `setIsOpen(results.length > 0 && isFocused)` - keep using setIsOpen (conditional)\n- Line 169: `setIsOpen(true)` - keep using setIsOpen\n- Lines 167, 180-181: `setIsFocused(true/false)` - keep using setIsFocused\n- Line 122, 136: `setIsLoading(true/false)` - keep using setIsLoading\n\nNote: This file primarily uses direct set operations rather than toggles, but the hook provides both the setter and toggle function.\n\n#### B. AppLayout.tsx (Lines 144-145) - 2 booleans\n**Current State:**\n```typescript\nconst [sidebarOpen, setSidebarOpen] = React.useState(false);\nconst [sidebarCollapsed, setSidebarCollapsed] = React.useState(false);\n```\n\n**Refactored State:**\n```typescript\nimport { useToggle } from '@/hooks/useToggle';\n\nconst [sidebarOpen, toggleSidebarOpen, setSidebarOpen] = useToggle(false);\nconst [sidebarCollapsed, toggleSidebarCollapsed] = useToggle(false);\n```\n\n**Usage Updates:**\n- Line 148: `setSidebarCollapsed(!sidebarCollapsed)` → `toggleSidebarCollapsed()`\n- Line 76: `setSidebarOpen?.(false)` - keep using setSidebarOpen\n- Line 178, 196: `setSidebarOpen(...)` - keep using setSidebarOpen\n\n#### C. Register.tsx (Lines 40-42) - 3 booleans\n**Current State:**\n```typescript\nconst [showPassword, setShowPassword] = useState(false);\nconst [agreedToTerms, setAgreedToTerms] = useState(false);\nconst [marketingConsent, setMarketingConsent] = useState(false);\n```\n\n**Refactored State:**\n```typescript\nimport { useToggle } from '@/hooks/useToggle';\n\nconst [showPassword, toggleShowPassword] = useToggle(false);\nconst [agreedToTerms, , setAgreedToTerms] = useToggle(false);\nconst [marketingConsent, , setMarketingConsent] = useToggle(false);\n```\n\n**Usage Updates:**\n- Line 232: `setShowPassword(!showPassword)` → `toggleShowPassword()`\n- Lines 297, 315: `setAgreedToTerms/setMarketingConsent(checked as boolean)` - keep using setters\n\n#### D. ResetPassword.tsx (Lines 29-35) - 4 booleans\n**Current State:**\n```typescript\nconst [showPassword, setShowPassword] = useState(false);\nconst [showConfirmPassword, setShowConfirmPassword] = useState(false);\nconst [isLoading, setIsLoading] = useState(false);\nconst [isTokenValid, setIsTokenValid] = useState(true);\nconst [resetSuccess, setResetSuccess] = useState(false);\n```\n\n**Refactored State:**\n```typescript\nimport { useToggle } from '@/hooks/useToggle';\n\nconst [showPassword, toggleShowPassword] = useToggle(false);\nconst [showConfirmPassword, toggleShowConfirmPassword] = useToggle(false);\nconst [isLoading, , setIsLoading] = useToggle(false);\nconst [isTokenValid, , setIsTokenValid] = useToggle(true);\nconst [resetSuccess, , setResetSuccess] = useToggle(false);\n```\n\n**Usage Updates:**\n- Line 234: `setShowPassword(!showPassword)` → `toggleShowPassword()`\n- Line 275: `setShowConfirmPassword(!showConfirmPassword)` → `toggleShowConfirmPassword()`\n\n### 2. Secondary Files to Refactor (Lower Priority)\n\n| File | Booleans | Pattern |\n|------|----------|---------|\n| Login.tsx:35 | `showPassword` | Toggle pattern |\n| ForgotPassword.tsx:14-15 | `isLoading, emailSent` | Mixed setter/toggle |\n| VerifyEmail.tsx:39-42 | `isLoading, success, isResending` | Setter pattern |\n| ProfileDetail.tsx:94 | `isEditing` | Toggle pattern |\n| ProfileList.tsx:259 | `formModalOpen` | Setter pattern |\n| ProfileSettings.tsx:66 | `isAddFieldOpen` | Setter pattern |\n| Templates.tsx:243 | `createDialogOpen` | Setter pattern |\n| History.tsx:71-72 | `loading, statsLoading` | Setter pattern |\n| JobDetails.tsx:50 | `loading` | Setter pattern |\n| SimpleFillForm.tsx:160,165 | `filling, validatingForm` | Setter pattern |\n| FormFillDemo.tsx:73,75 | `isSubmitting, profileLoading` | Setter pattern |\n| bulk-actions-toolbar.tsx:88,201 | `showDeleteDialog` x2 | Setter pattern |\n| demo-login-button.tsx:73 | `isLoading` | Setter pattern |\n| demo-mode-indicator.tsx:65 | `dismissed` | Setter pattern |\n| document-filters.tsx:105 | `open` | Setter pattern |\n| form-preview.tsx:48 | `previewLoading` | Setter pattern |\n| profile-field-editor.tsx:58 | `isEditing` | Toggle pattern |\n| profile-fields-manager.tsx:193,480-481 | `isEditing, hasChanges, addDialogOpen` | Mixed |\n| profile-selector.tsx:118 | `showNoProfilesDialog` | Setter pattern |\n| search-bar.tsx:201 | `showResults` | Setter pattern |\n| template-manager.tsx:50 | `saveDialogOpen` | Setter pattern |\n| SearchInterface.tsx:71,250 | `expanded, showOptions` | Toggle pattern |\n| SuggestionPopover.tsx:204 | `open` | Setter pattern |\n\n### 3. Import Pattern\n\nAdd to hooks barrel export (create `hooks/index.ts` if needed):\n```typescript\n// hooks/index.ts\nexport { useDebouncedValue, useDebouncedCallback } from './useDebounce';\nexport { useToggle } from './useToggle';\n// ... other hooks from Task 173\n```\n\n### 4. Refactoring Guidelines\n\n1. **When to use toggle vs setter:**\n   - Use `toggle()` when the pattern is `setValue(!value)`\n   - Use `setValue()` when setting to a specific value or conditional\n\n2. **Destructuring patterns:**\n   - Full: `const [value, toggle, setValue] = useToggle(false);`\n   - Toggle only: `const [value, toggle] = useToggle(false);`\n   - Setter only: `const [value, , setValue] = useToggle(false);`\n\n3. **Migration order:**\n   - Start with priority files (autocomplete-field, AppLayout, Register, ResetPassword)\n   - Proceed to secondary files alphabetically by directory\n\n### 5. Code Reduction Estimate\n\n- **Before:** ~100 lines of `useState` + inline `!value` toggles\n- **After:** ~50 lines using `useToggle` with semantic toggle functions\n- **Estimated reduction:** 50% boilerplate reduction in toggle patterns",
        "testStrategy": "## Test Strategy\n\n### 1. Unit Tests for Refactored Components\n\nEach refactored component should maintain its existing test coverage. Verify behavior is unchanged:\n\n#### A. autocomplete-field.test.tsx (Existing)\n```typescript\ndescribe('AutocompleteField with useToggle', () => {\n  it('opens dropdown on focus when suggestions exist')\n  it('closes dropdown on blur')\n  it('shows loading indicator during fetch')\n  it('maintains focus state correctly')\n})\n```\n\n#### B. AppLayout Tests\n```typescript\ndescribe('AppLayout with useToggle', () => {\n  it('toggles sidebar collapsed state on button click')\n  it('opens mobile sidebar sheet')\n  it('closes sidebar when navigation link clicked')\n})\n```\n\n#### C. Register Tests\n```typescript\ndescribe('Register with useToggle', () => {\n  it('toggles password visibility')\n  it('maintains terms agreement state through checkbox')\n  it('maintains marketing consent state through checkbox')\n})\n```\n\n#### D. ResetPassword Tests\n```typescript\ndescribe('ResetPassword with useToggle', () => {\n  it('toggles password visibility for password field')\n  it('toggles password visibility for confirm password field')\n  it('sets loading state during submission')\n  it('sets success state after successful reset')\n})\n```\n\n### 2. Manual Testing Checklist\n\n#### Priority Files:\n- [ ] **autocomplete-field.tsx**\n  - [ ] Focus input → dropdown opens when suggestions available\n  - [ ] Blur input → dropdown closes\n  - [ ] Loading spinner appears during API fetch\n  - [ ] Typing triggers suggestion fetch after debounce\n\n- [ ] **AppLayout.tsx**\n  - [ ] Click collapse button → sidebar collapses\n  - [ ] Click expand button → sidebar expands\n  - [ ] Mobile: hamburger menu opens sidebar\n  - [ ] Mobile: clicking nav link closes sidebar\n\n- [ ] **Register.tsx**\n  - [ ] Click eye icon → password becomes visible\n  - [ ] Click eye icon again → password becomes hidden\n  - [ ] Check terms checkbox → enables submit button\n  - [ ] Uncheck terms checkbox → disables submit button\n  - [ ] Marketing checkbox toggles independently\n\n- [ ] **ResetPassword.tsx**\n  - [ ] Toggle password visibility for \"New Password\" field\n  - [ ] Toggle password visibility for \"Confirm Password\" field\n  - [ ] Submit shows loading state\n  - [ ] Success state displays correctly\n\n### 3. Regression Testing\n\nRun existing test suite to verify no regressions:\n```bash\ncd quikadmin-web\nbun run test\n```\n\n### 4. Visual Regression\n\n- [ ] No visual changes in components after refactoring\n- [ ] Animations and transitions work identically\n- [ ] Focus states render correctly\n- [ ] Loading indicators display properly\n\n### 5. Bundle Size Verification\n\nCheck that useToggle hook doesn't significantly increase bundle:\n```bash\ncd quikadmin-web\nbun run build\n# Compare bundle size before/after (should be negligible increase)\n```\n\n### 6. TypeScript Compilation\n\nEnsure all refactored files compile without errors:\n```bash\ncd quikadmin-web\nbun run typecheck\n```\n\n### 7. Integration Test Flow\n\nTest complete user flows that touch refactored components:\n1. **Authentication flow:** Register → Login → Password Reset\n2. **Navigation flow:** Dashboard → Documents → Use sidebar\n3. **Form filling:** Use autocomplete field with suggestions",
        "status": "pending",
        "dependencies": [173],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-01T04:33:37.596Z",
      "taskCount": 18,
      "completedCount": 15,
      "tags": ["master"],
      "created": "2026-01-01T04:34:15.714Z",
      "description": "Tasks for master context",
      "updated": "2026-01-01T04:43:30.809Z"
    }
  }
}
