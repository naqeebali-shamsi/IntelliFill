---
phase: 05-stripe-integration
plan: 02
type: execute
wave: 2
depends_on: ['05-01']
files_modified:
  - quikadmin/package.json
  - quikadmin/src/api/stripe.routes.ts
  - quikadmin/src/services/stripe.service.ts
  - quikadmin/src/api/routes.ts
autonomous: true
---

<objective>
Implement Stripe backend integration with webhook handling, checkout session creation, and customer portal access.

Purpose: Enable the backend to process payments, handle subscription lifecycle events, and provide checkout/portal endpoints for the frontend.

Output: Working Stripe API endpoints at `/api/stripe/*` that handle checkout, webhooks, and portal access.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-stripe-integration/05-CONTEXT.md
@.planning/phases/05-stripe-integration/05-RESEARCH.md
@.planning/phases/05-stripe-integration/05-01-SUMMARY.md
@quikadmin/CLAUDE.md
@quikadmin/src/api/routes.ts
@quikadmin/src/middleware/supabaseAuth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Stripe SDK</name>
  <files>quikadmin/package.json</files>
  <action>
    Install the Stripe Node.js SDK:

    ```bash
    cd quikadmin
    npm install stripe
    ```

    This adds the official Stripe SDK for server-side integration.
    Version should be latest (14.x as of 2026).

  </action>
  <verify>Package.json includes "stripe" in dependencies, `npm ls stripe` shows installed version</verify>
  <done>Stripe SDK installed and available for import</done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe service with subscription management</name>
  <files>quikadmin/src/services/stripe.service.ts</files>
  <action>
    Create a Stripe service that encapsulates all Stripe API interactions:

    ```typescript
    import Stripe from 'stripe';
    import { prisma } from '../utils/prisma';
    import { logger } from '../utils/logger';

    // Initialize Stripe with API version
    const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
      apiVersion: '2024-12-18.acacia',
    });

    export const stripeService = {
      /**
       * Get or create a Stripe customer for a user
       */
      async getOrCreateCustomer(userId: string, email: string): Promise<string> {
        const user = await prisma.user.findUnique({
          where: { id: userId },
          select: { stripeCustomerId: true },
        });

        if (user?.stripeCustomerId) {
          return user.stripeCustomerId;
        }

        // Create new Stripe customer
        const customer = await stripe.customers.create({
          email,
          metadata: { userId },
        });

        // Store customer ID
        await prisma.user.update({
          where: { id: userId },
          data: { stripeCustomerId: customer.id },
        });

        return customer.id;
      },

      /**
       * Create a checkout session for PRO subscription
       */
      async createCheckoutSession(
        userId: string,
        email: string,
        successUrl: string,
        cancelUrl: string
      ): Promise<Stripe.Checkout.Session> {
        const customerId = await this.getOrCreateCustomer(userId, email);

        const session = await stripe.checkout.sessions.create({
          customer: customerId,
          mode: 'subscription',
          line_items: [
            {
              price: process.env.STRIPE_PRO_PRICE_ID!,
              quantity: 1,
            },
          ],
          success_url: successUrl,
          cancel_url: cancelUrl,
          metadata: { userId },
          subscription_data: {
            metadata: { userId },
          },
        });

        return session;
      },

      /**
       * Create a customer portal session for billing management
       */
      async createPortalSession(
        userId: string,
        returnUrl: string
      ): Promise<Stripe.BillingPortal.Session> {
        const user = await prisma.user.findUnique({
          where: { id: userId },
          select: { stripeCustomerId: true },
        });

        if (!user?.stripeCustomerId) {
          throw new Error('No Stripe customer found for this user');
        }

        const session = await stripe.billingPortal.sessions.create({
          customer: user.stripeCustomerId,
          return_url: returnUrl,
        });

        return session;
      },

      /**
       * Get subscription status for a user
       */
      async getSubscriptionStatus(userId: string): Promise<{
        isPro: boolean;
        status: string | null;
        currentPeriodEnd: Date | null;
      }> {
        const user = await prisma.user.findUnique({
          where: { id: userId },
          select: {
            subscriptionStatus: true,
            currentPeriodEnd: true,
          },
        });

        return {
          isPro: user?.subscriptionStatus === 'active' || user?.subscriptionStatus === 'trialing',
          status: user?.subscriptionStatus ?? null,
          currentPeriodEnd: user?.currentPeriodEnd ?? null,
        };
      },

      /**
       * Handle webhook event - update subscription status
       */
      async handleWebhookEvent(event: Stripe.Event): Promise<void> {
        switch (event.type) {
          case 'checkout.session.completed': {
            const session = event.data.object as Stripe.Checkout.Session;
            if (session.mode === 'subscription' && session.subscription) {
              const subscription = await stripe.subscriptions.retrieve(
                session.subscription as string
              );
              await this.updateSubscription(subscription);
            }
            break;
          }

          case 'customer.subscription.created':
          case 'customer.subscription.updated': {
            const subscription = event.data.object as Stripe.Subscription;
            await this.updateSubscription(subscription);
            break;
          }

          case 'customer.subscription.deleted': {
            const subscription = event.data.object as Stripe.Subscription;
            await this.cancelSubscription(subscription);
            break;
          }

          case 'invoice.paid': {
            const invoice = event.data.object as Stripe.Invoice;
            if (invoice.subscription) {
              const subscription = await stripe.subscriptions.retrieve(
                invoice.subscription as string
              );
              await this.updateSubscription(subscription);
            }
            break;
          }

          case 'invoice.payment_failed': {
            const invoice = event.data.object as Stripe.Invoice;
            logger.warn('Payment failed for invoice', { invoiceId: invoice.id });
            // Status will be updated via subscription.updated event
            break;
          }

          default:
            logger.debug('Unhandled webhook event type', { type: event.type });
        }
      },

      /**
       * Update user subscription from Stripe subscription object
       */
      async updateSubscription(subscription: Stripe.Subscription): Promise<void> {
        const userId = subscription.metadata?.userId;
        if (!userId) {
          logger.warn('No userId in subscription metadata', { subId: subscription.id });
          return;
        }

        await prisma.user.update({
          where: { id: userId },
          data: {
            subscriptionId: subscription.id,
            subscriptionStatus: subscription.status,
            currentPeriodEnd: new Date(subscription.current_period_end * 1000),
          },
        });

        logger.info('Subscription updated', {
          userId,
          subscriptionId: subscription.id,
          status: subscription.status,
        });
      },

      /**
       * Handle subscription cancellation
       */
      async cancelSubscription(subscription: Stripe.Subscription): Promise<void> {
        const userId = subscription.metadata?.userId;
        if (!userId) {
          logger.warn('No userId in subscription metadata', { subId: subscription.id });
          return;
        }

        await prisma.user.update({
          where: { id: userId },
          data: {
            subscriptionStatus: 'canceled',
            // Keep currentPeriodEnd so user retains access until end of period
          },
        });

        logger.info('Subscription canceled', { userId, subscriptionId: subscription.id });
      },

      /**
       * Verify webhook signature
       */
      constructWebhookEvent(
        payload: string | Buffer,
        signature: string
      ): Stripe.Event {
        return stripe.webhooks.constructEvent(
          payload,
          signature,
          process.env.STRIPE_WEBHOOK_SECRET!
        );
      },
    };
    ```

    Key implementation notes:
    - Uses singleton Prisma client (imported from utils/prisma)
    - Stores userId in metadata for webhook correlation
    - Handles all relevant subscription lifecycle events
    - Instant unlock: checkout.session.completed updates DB immediately

  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Stripe service handles checkout, portal, webhooks, and subscription status</done>
</task>

<task type="auto">
  <name>Task 3: Create Stripe routes with webhook endpoint</name>
  <files>quikadmin/src/api/stripe.routes.ts</files>
  <action>
    Create routes file for Stripe endpoints:

    ```typescript
    import { Router, Request, Response, NextFunction } from 'express';
    import { stripeService } from '../services/stripe.service';
    import { authenticateSupabase } from '../middleware/supabaseAuth';
    import { logger } from '../utils/logger';
    import Joi from 'joi';

    const router = Router();

    // Validation schemas
    const checkoutSchema = Joi.object({
      successUrl: Joi.string().uri().required(),
      cancelUrl: Joi.string().uri().required(),
    });

    const portalSchema = Joi.object({
      returnUrl: Joi.string().uri().required(),
    });

    /**
     * POST /api/stripe/create-checkout-session
     * Create a Stripe Checkout session for PRO subscription
     * Protected - requires authentication
     */
    router.post(
      '/create-checkout-session',
      authenticateSupabase,
      async (req: Request, res: Response, next: NextFunction) => {
        try {
          const { error, value } = checkoutSchema.validate(req.body);
          if (error) {
            return res.status(400).json({
              success: false,
              error: { code: 'VALIDATION_ERROR', message: error.details[0].message },
            });
          }

          const user = (req as any).user;
          const { successUrl, cancelUrl } = value;

          const session = await stripeService.createCheckoutSession(
            user.id,
            user.email,
            successUrl,
            cancelUrl
          );

          res.json({
            success: true,
            data: { sessionId: session.id, url: session.url },
          });
        } catch (error) {
          logger.error('Failed to create checkout session', { error });
          next(error);
        }
      }
    );

    /**
     * POST /api/stripe/create-portal-session
     * Create a Stripe Customer Portal session for billing management
     * Protected - requires authentication
     */
    router.post(
      '/create-portal-session',
      authenticateSupabase,
      async (req: Request, res: Response, next: NextFunction) => {
        try {
          const { error, value } = portalSchema.validate(req.body);
          if (error) {
            return res.status(400).json({
              success: false,
              error: { code: 'VALIDATION_ERROR', message: error.details[0].message },
            });
          }

          const user = (req as any).user;
          const { returnUrl } = value;

          const session = await stripeService.createPortalSession(user.id, returnUrl);

          res.json({
            success: true,
            data: { url: session.url },
          });
        } catch (error) {
          logger.error('Failed to create portal session', { error });
          next(error);
        }
      }
    );

    /**
     * GET /api/stripe/subscription-status
     * Get current user's subscription status
     * Protected - requires authentication
     */
    router.get(
      '/subscription-status',
      authenticateSupabase,
      async (req: Request, res: Response, next: NextFunction) => {
        try {
          const user = (req as any).user;
          const status = await stripeService.getSubscriptionStatus(user.id);

          res.json({
            success: true,
            data: status,
          });
        } catch (error) {
          logger.error('Failed to get subscription status', { error });
          next(error);
        }
      }
    );

    /**
     * POST /api/stripe/webhook
     * Handle Stripe webhook events
     * IMPORTANT: Must use raw body parser, NOT json parser
     * This endpoint is called by Stripe, not by the frontend
     */
    router.post(
      '/webhook',
      // Note: express.raw() middleware applied at route level in routes.ts
      async (req: Request, res: Response) => {
        const signature = req.headers['stripe-signature'];

        if (!signature || typeof signature !== 'string') {
          logger.warn('Webhook received without signature');
          return res.status(400).json({ error: 'Missing signature' });
        }

        try {
          const event = stripeService.constructWebhookEvent(req.body, signature);

          logger.info('Webhook event received', { type: event.type, id: event.id });

          await stripeService.handleWebhookEvent(event);

          res.json({ received: true });
        } catch (error) {
          logger.error('Webhook error', { error });
          res.status(400).json({
            error: error instanceof Error ? error.message : 'Webhook error',
          });
        }
      }
    );

    export function createStripeRoutes(): Router {
      return router;
    }
    ```

    Key implementation notes:
    - Webhook endpoint uses raw body (configured in routes.ts)
    - All other endpoints use authenticateSupabase middleware
    - Joi validation on input
    - Consistent error response format

  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Stripe routes created with checkout, portal, status, and webhook endpoints</done>
</task>

<task type="auto">
  <name>Task 4: Mount Stripe routes with raw body middleware for webhook</name>
  <files>quikadmin/src/api/routes.ts</files>
  <action>
    Update routes.ts to mount Stripe routes with special handling for webhook:

    1. Import the Stripe routes:
    ```typescript
    import { createStripeRoutes } from './stripe.routes';
    ```

    2. Mount the routes with raw body middleware for webhook.
    Add BEFORE the general JSON body parser section, add:

    ```typescript
    // Stripe webhook needs raw body for signature verification
    // Must be mounted BEFORE json body parser
    app.use('/api/stripe/webhook', express.raw({ type: 'application/json' }));

    // Setup Stripe routes (Phase 5 - Subscription)
    // Mounted at /api/stripe for checkout, portal, webhook
    const stripeRoutes = createStripeRoutes();
    app.use('/api/stripe', stripeRoutes);
    ```

    Place the webhook raw body middleware early in the middleware chain,
    before the global JSON parser. The actual route mount can be with other route mounts.

  </action>
  <verify>Server starts without errors: `npm run dev` (check for compilation errors)</verify>
  <done>Stripe routes mounted at /api/stripe with proper webhook body parsing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds in quikadmin/
- [ ] `npx tsc --noEmit` passes
- [ ] Server starts with `npm run dev`
- [ ] GET /api/stripe/subscription-status returns 401 (unauthenticated)
- [ ] POST /api/stripe/webhook endpoint exists (returns 400 without signature)
</verification>

<success_criteria>

- Stripe SDK installed and initialized
- Service handles checkout, portal, and subscription management
- Webhook endpoint verifies signatures and updates database
- All endpoints follow existing API patterns (response format, error handling)
- Instant unlock: webhook updates isPro immediately on checkout.session.completed
  </success_criteria>

<output>
After completion, create `.planning/phases/05-stripe-integration/05-02-SUMMARY.md`
</output>
