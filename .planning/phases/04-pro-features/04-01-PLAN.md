---
phase: 04-pro-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - quikadmin-web/src/services/clientsService.ts
  - quikadmin-web/src/stores/clientsStore.ts
  - quikadmin-web/src/pages/ClientLibrary.tsx
  - quikadmin-web/src/App.tsx
autonomous: true
---

<objective>
Build client list and search UI accessible from Smart Profile navigation.

Purpose: PRO agents need quick access to their client database with search, filtering, and status management to handle 50+ clients/month efficiently.

Output: Functional ClientLibrary page with clientsService, clientsStore, search/filter UI, and pagination.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@quikadmin-web/CLAUDE.md

# Backend endpoints already exist - we're building frontend to consume them:

# GET /api/clients - List with search, filter by type/status, pagination

# GET /api/clients/:id/summary - Rich client summary with doc/form counts

# POST /api/clients/:id/archive - Archive client

# POST /api/clients/:id/restore - Restore archived client

# Existing patterns to follow:

@quikadmin-web/src/services/filledFormsService.ts
@quikadmin-web/src/stores/filledFormsStore.ts
@quikadmin-web/src/pages/FilledFormHistory.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create clientsService.ts</name>
  <files>quikadmin-web/src/services/clientsService.ts</files>
  <action>
Create API service for client management. Backend endpoints already exist at /api/clients.

Include:

- `getClients(params: ClientListParams)` - List with search, type, status, pagination
- `getClientById(id: string)` - Single client
- `getClientSummary(id: string)` - Rich summary with counts
- `createClient(data: CreateClientDto)` - Create new
- `updateClient(id: string, data: UpdateClientDto)` - Update
- `archiveClient(id: string)` - Archive
- `restoreClient(id: string)` - Restore from archive
- `deleteClient(id: string)` - Permanent delete

Define TypeScript interfaces:

- `Client` - Core client type (id, name, type, status, notes, createdAt, updatedAt)
- `ClientType` - 'COMPANY' | 'INDIVIDUAL'
- `ClientStatus` - 'ACTIVE' | 'ARCHIVED'
- `ClientSummary` - Extended with documentCount, formCount, extractedDataCount, profileFieldCount
- `ClientListParams` - search, type, status, limit, offset
- `ClientListResponse` - clients[], total, limit, offset

Follow the pattern in filledFormsService.ts for API structure.
</action>
<verify>TypeScript compiles: `cd quikadmin-web && bun run build 2>&1 | head -20`</verify>
<done>clientsService.ts exports all CRUD operations with proper typing</done>
</task>

<task type="auto">
  <name>Task 2: Create clientsStore.ts</name>
  <files>quikadmin-web/src/stores/clientsStore.ts</files>
  <action>
Create Zustand store for client state management with immer middleware.

State:

- `clients: Client[]` - Current page of clients
- `selectedClient: ClientSummary | null` - Selected client with full summary
- `total: number` - Total count for pagination
- `loading: boolean`
- `error: string | null`

Filters (with default values):

- `search: string` (default: '')
- `type: ClientType | 'all'` (default: 'all')
- `status: ClientStatus | 'all'` (default: 'all')
- `limit: number` (default: 20)
- `offset: number` (default: 0)

Actions:

- `fetchClients()` - Fetch with current filters
- `selectClient(id: string)` - Load client summary
- `clearSelectedClient()` - Clear selection
- `setSearch(search: string)` - Update search (resets offset to 0)
- `setTypeFilter(type: ClientType | 'all')` - Filter by type
- `setStatusFilter(status: ClientStatus | 'all')` - Filter by status
- `nextPage()` / `prevPage()` - Pagination
- `archiveClient(id: string)` - Archive and refresh
- `restoreClient(id: string)` - Restore and refresh
- `reset()` - Reset to initial state

Include selector hooks:

- `useClientsFilters()` - Returns filter state
- `useClientsPagination()` - Returns pagination info (hasNext, hasPrev, currentPage)

Follow pattern in filledFormsStore.ts.
</action>
<verify>TypeScript compiles with no errors</verify>
<done>clientsStore.ts exports store with all state/actions and selector hooks</done>
</task>

<task type="auto">
  <name>Task 3: Build ClientLibrary.tsx page</name>
  <files>quikadmin-web/src/pages/ClientLibrary.tsx, quikadmin-web/src/App.tsx</files>
  <action>
Create ClientLibrary page following FilledFormHistory.tsx patterns.

Structure:

1. PageHeader with title "Clients" and "New Client" button
2. Filter bar:
   - Search input (debounced, 300ms)
   - Type dropdown (All, Company, Individual)
   - Status dropdown (All, Active, Archived)
3. Client grid or table view:
   - ClientCard for each client showing: name, type badge, status badge, document count, form count, last updated
   - Click card to navigate to client detail (future) or show summary sidebar
4. Pagination controls (prev/next with count display)
5. Empty state when no clients
6. Loading skeleton

Use existing UI components: Card, Input, Select, Badge, Button, EmptyState, PageHeader
Use Lucide icons: Users, Building2, User, Archive, Search, Plus

Add route in App.tsx: `/clients` -> ClientLibrary

CSS: Use existing Tailwind patterns. Responsive grid (1 col mobile, 2 cols tablet, 3 cols desktop).
</action>
<verify>`bun run build` succeeds and page renders at /clients</verify>
<done>ClientLibrary page with search, filters, client cards, pagination, empty state</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd quikadmin-web && bun run build` succeeds
- [ ] `/clients` route accessible and renders ClientLibrary
- [ ] Search filters clients by name (debounced)
- [ ] Type filter shows only COMPANY or INDIVIDUAL
- [ ] Status filter shows only ACTIVE or ARCHIVED
- [ ] Pagination works (next/prev)
- [ ] Empty state shown when no clients match filters
</verification>

<success_criteria>

- All tasks completed
- No TypeScript errors
- Client list page functional with search, filters, pagination
- Follows existing codebase patterns (FilledFormHistory, filledFormsStore)
  </success_criteria>

<output>
After completion, create `.planning/phases/04-pro-features/04-01-SUMMARY.md`
</output>
