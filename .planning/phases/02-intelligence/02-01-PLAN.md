---
phase: 02-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - quikadmin-web/package.json
  - quikadmin/package.json
  - quikadmin-web/src/lib/entity-resolution/nameSimilarity.ts
  - quikadmin-web/src/lib/entity-resolution/idMatcher.ts
  - quikadmin-web/src/lib/entity-resolution/personMatcher.ts
  - quikadmin/src/services/PersonGroupingService.ts
  - quikadmin/src/routes/smart-profile.routes.ts
autonomous: true
---

<objective>
Backend foundation for multi-person document grouping with entity resolution.

Purpose: Enable the system to detect when uploaded documents belong to different people and automatically suggest groupings based on name similarity and ID matching. This is the intelligence layer that powers the PersonGrouper UI.

Output: Entity resolution utilities, PersonGroupingService, and enhanced extract-batch endpoint that returns detected person groups.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-intelligence/02-RESEARCH.md

# Source files

@quikadmin-web/package.json
@quikadmin/package.json
@quikadmin/src/routes/smart-profile.routes.ts
@quikadmin/src/services/SmartProfileService.ts
@quikadmin-web/src/stores/smartProfileStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies</name>
  <files>quikadmin-web/package.json, quikadmin/package.json</files>
  <action>
Install required packages:

**Frontend (quikadmin-web - use bun):**

```bash
cd quikadmin-web
bun add @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities fuse.js
```

**Backend (quikadmin - use npm):**

```bash
cd quikadmin
npm install fuzzball
npm install -D @types/fuzzball
```

Note: fuzzball is backend-only for server-side entity resolution. @dnd-kit and fuse.js are frontend-only.
</action>
<verify>

- `cd quikadmin-web && bun run build` succeeds (packages resolve)
- `cd quikadmin && npm run build` succeeds (fuzzball available)
  </verify>
  <done>
- @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities, fuse.js in frontend package.json
- fuzzball in backend package.json
- Both build successfully
  </done>
  </task>

<task type="auto">
  <name>Task 2: Create entity resolution utilities</name>
  <files>
quikadmin-web/src/lib/entity-resolution/nameSimilarity.ts,
quikadmin-web/src/lib/entity-resolution/idMatcher.ts,
quikadmin-web/src/lib/entity-resolution/personMatcher.ts,
quikadmin-web/src/lib/entity-resolution/index.ts
  </files>
  <action>
Create frontend utilities for client-side display and re-matching (not the main matching which happens server-side).

**nameSimilarity.ts:**

- Export `normalizeName(name: string): string` - lowercase, remove diacritics, normalize whitespace
- Export `TRANSLITERATION_MAP` - common Arabic to English variants (Mohamed/Mohammed/Mohd etc.)
- Export `areTransliterationVariants(name1, name2): boolean` - check if names might be transliteration variants

**idMatcher.ts:**

- Export `normalizeId(id: string): string` - uppercase, remove dashes/spaces
- Export `IdMatchResult` interface: `{ match: boolean; confidence: number; reason: string }`
- Export `compareIds(id1, id2): IdMatchResult` - exact match (1.0), partial/substring (0.85), prefix (0.7)

**personMatcher.ts:**

- Export `MATCH_THRESHOLDS = { AUTO_GROUP: 0.95, SUGGEST_GROUP: 0.85, REVIEW: 0.7 }`
- Export `MatchResult` interface: `{ confidence: number; matchType: 'exact_id' | 'high_similarity' | 'partial' | 'no_match'; suggestedAction: 'auto_group' | 'suggest' | 'keep_separate' }`

**index.ts:**

- Re-export all utilities

Use patterns from 02-RESEARCH.md code examples. These are lightweight frontend utilities; heavy matching happens server-side.
</action>
<verify>

- TypeScript compiles: `cd quikadmin-web && npx tsc --noEmit src/lib/entity-resolution/*.ts`
- Imports resolve: Add test import in any file, verify no errors
  </verify>
  <done>
- 4 files created in quikadmin-web/src/lib/entity-resolution/
- All type-check passes
- Functions follow 02-RESEARCH.md patterns
  </done>
  </task>

<task type="auto">
  <name>Task 3: Create PersonGroupingService</name>
  <files>quikadmin/src/services/PersonGroupingService.ts</files>
  <action>
Create backend service for entity resolution using fuzzball (Jaro-Winkler).

**PersonGroupingService.ts:**

Interface definitions:

```typescript
interface DocumentExtraction {
  documentId: string;
  fileName: string;
  extractedName: string | null;
  extractedIdNumber: string | null;
  fields: Record<string, { value: unknown; confidence: number }>;
}

interface PersonGroup {
  id: string;
  name: string | null;
  confidence: number;
  documentIds: string[];
  matchReason: string;
}

interface GroupingResult {
  groups: PersonGroup[];
  suggestedMerges: Array<{ groupIds: [string, string]; confidence: number; reason: string }>;
}
```

Implement `groupDocuments(extractions: DocumentExtraction[]): GroupingResult`:

1. For each pair of documents, calculate similarity using three-tier strategy:
   - Tier 1: Exact ID match (normalized) → confidence 1.0, auto_group
   - Tier 2: High name similarity via fuzzball.token_sort_ratio (≥0.95) → auto_group
   - Tier 3: Moderate similarity (0.85-0.95) → suggest
   - Tier 4: Low similarity → keep_separate
2. Use union-find algorithm to merge auto_group pairs into groups
3. Track suggested merges for user review

Helper functions:

- `private normalizeName(name: string): string` - lowercase, remove diacritics, normalize whitespace
- `private normalizeId(id: string): string` - uppercase, remove non-alphanumeric
- `private calculateNameSimilarity(name1: string, name2: string): number` - fuzzball.token_sort_ratio / 100

Export as singleton instance.
</action>
<verify>

- TypeScript compiles: `cd quikadmin && npm run build`
- Service exports correctly
  </verify>
  <done>
- PersonGroupingService.ts created with groupDocuments method
- Uses fuzzball for Jaro-Winkler similarity
- Three-tier matching strategy implemented
- Exported as singleton
  </done>
  </task>

<task type="auto">
  <name>Task 4: Enhance extract-batch endpoint to return person groups</name>
  <files>quikadmin/src/routes/smart-profile.routes.ts, quikadmin/src/services/SmartProfileService.ts</files>
  <action>
Modify the extract-batch endpoint to detect and return person groupings.

**SmartProfileService.ts:**

1. Import PersonGroupingService
2. After extracting all documents, call `personGroupingService.groupDocuments(extractions)`
3. Return groups in response

**smart-profile.routes.ts:**
Update POST /extract-batch response shape:

```typescript
interface ExtractBatchResponse {
  success: boolean;
  profileData: Record<string, unknown>;
  fieldSources: Record<string, FieldSource>;
  lowConfidenceFields: LowConfidenceField[];
  // NEW: Person grouping data
  detectedPeople: Array<{
    id: string;
    name: string | null;
    confidence: number;
    documentIds: string[];
  }>;
  suggestedMerges?: Array<{
    groupIds: [string, string];
    confidence: number;
    reason: string;
  }>;
}
```

The frontend already has `setDetectedPeople` action in smartProfileStore - just need backend to populate it.

For single-person uploads (1 document or all docs match same person), return single group with all documentIds.
</action>
<verify>

- Backend builds: `cd quikadmin && npm run build`
- API endpoint test: Upload 2 docs with different names, verify response includes detectedPeople array with 2 groups
  </verify>
  <done>
- SmartProfileService calls PersonGroupingService.groupDocuments
- extract-batch returns detectedPeople array
- suggestedMerges included when moderate matches detected
- Single-person case handled (1 group with all docs)
  </done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd quikadmin-web && bun run build` succeeds
- [ ] `cd quikadmin && npm run build` succeeds
- [ ] Entity resolution utilities type-check
- [ ] PersonGroupingService uses fuzzball correctly
- [ ] extract-batch returns detectedPeople in response
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Frontend has entity resolution utilities for display/UI
- Backend has PersonGroupingService with three-tier matching
- extract-batch API returns person groups
- Ready for Plan 02-02 (PersonGrouper UI)
  </success_criteria>

<output>
After completion, create `.planning/phases/02-intelligence/02-01-SUMMARY.md`
</output>
