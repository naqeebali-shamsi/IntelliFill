/**
 * JWT Compatibility Test
 * Tests token generation and validation across both AuthService implementations
 */

import jwt from 'jsonwebtoken';
import { AuthService } from '../src/services/AuthService';
import { PrismaAuthService } from '../src/services/PrismaAuthService';
import { DatabaseService } from '../src/database/DatabaseService';

// Test JWT secrets (matching what the services expect)
const TEST_JWT_SECRET = 'test-jwt-secret-that-is-at-least-64-characters-long-for-security-requirements';
const TEST_REFRESH_SECRET = 'test-refresh-secret-that-is-at-least-64-characters-long-for-security-requirements';

// Set environment variables for services
process.env.JWT_SECRET = TEST_JWT_SECRET;
process.env.JWT_REFRESH_SECRET = TEST_REFRESH_SECRET;
process.env.JWT_ISSUER = 'quikadmin-api';
process.env.JWT_AUDIENCE = 'quikadmin-client';
process.env.JWT_EXPIRES_IN = '15m';

class JWTCompatibilityTester {
  private authService: AuthService;
  private prismaAuthService: PrismaAuthService;
  private results: Array<{ test: string; passed: boolean; details: string }> = [];

  constructor() {
    // Mock database service for AuthService
    const mockDb = {
      query: jest.fn(),
      transaction: jest.fn(),
      end: jest.fn()
    } as unknown as DatabaseService;

    this.authService = new AuthService(mockDb);
    this.prismaAuthService = new PrismaAuthService();
  }

  private addResult(test: string, passed: boolean, details: string) {
    this.results.push({ test, passed, details });
    console.log(`${passed ? '✅' : '❌'} ${test}: ${details}`);
  }

  /**
   * Test 1: Compare JWT token structure and claims
   */
  async testTokenStructure() {
    console.log('\n🔍 Testing Token Structure Comparison...');

    const payload = {
      id: 'test-user-123',
      email: 'test@example.com',
      role: 'user'
    };

    // Generate tokens using both services' internal logic
    const authServiceToken = jwt.sign(payload, TEST_JWT_SECRET, {
      expiresIn: '15m',
      algorithm: 'HS256',
      issuer: 'quikadmin-api',
      audience: 'quikadmin-client'
    });

    const prismaServiceToken = jwt.sign(payload, TEST_JWT_SECRET, {
      expiresIn: '15m',
      issuer: 'quikadmin-api',
      audience: 'quikadmin-client',
      algorithm: 'HS256',
      notBefore: 0,
      jwtid: 'test-jti-123'
    });

    // Decode and compare
    const authDecoded = jwt.decode(authServiceToken, { complete: true });
    const prismaDecoded = jwt.decode(prismaServiceToken, { complete: true });

    this.addResult(
      'Algorithm Match',
      authDecoded?.header.alg === prismaDecoded?.header.alg,
      `AuthService: ${authDecoded?.header.alg}, PrismaAuthService: ${prismaDecoded?.header.alg}`
    );

    // Type guard for payload access
    const authPayload = authDecoded?.payload as jwt.JwtPayload;
    const prismaPayload = prismaDecoded?.payload as jwt.JwtPayload;

    this.addResult(
      'Issuer Match',
      authPayload?.iss === prismaPayload?.iss,
      `Both use issuer: ${authPayload?.iss}`
    );

    this.addResult(
      'Audience Match',
      authPayload?.aud === prismaPayload?.aud,
      `Both use audience: ${authPayload?.aud}`
    );

    // Key difference: PrismaAuthService adds jwtid and notBefore
    this.addResult(
      'PrismaAuthService adds jwtid',
      prismaPayload?.jti !== undefined,
      `PrismaAuthService includes jwtid: ${prismaPayload?.jti}`
    );

    this.addResult(
      'PrismaAuthService adds notBefore',
      prismaPayload?.nbf !== undefined,
      `PrismaAuthService includes nbf: ${prismaPayload?.nbf}`
    );
  }

  /**
   * Test 2: Cross-validation - Can each service validate the other's tokens?
   */
  async testCrossValidation() {
    console.log('\n🔄 Testing Cross-Service Token Validation...');

    const payload = {
      id: 'test-user-123',
      email: 'test@example.com',
      role: 'user'
    };

    // Token generated by AuthService pattern
    const authServiceToken = jwt.sign(payload, TEST_JWT_SECRET, {
      expiresIn: '15m',
      algorithm: 'HS256',
      issuer: 'quikadmin-api',
      audience: 'quikadmin-client'
    });

    // Token generated by PrismaAuthService pattern
    const prismaServiceToken = jwt.sign(
      { ...payload, jti: 'unique-id-123' },
      TEST_JWT_SECRET,
      {
        expiresIn: '15m',
        issuer: 'quikadmin-api',
        audience: 'quikadmin-client',
        algorithm: 'HS256',
        notBefore: 0,
        jwtid: 'unique-id-123'
      }
    );

    // Test PrismaAuthService validating AuthService token
    try {
      const result = await this.prismaAuthService.verifyToken(authServiceToken);
      this.addResult(
        'PrismaAuthService validates AuthService token',
        true,
        `Successfully validated: ${JSON.stringify(result)}`
      );
    } catch (error) {
      this.addResult(
        'PrismaAuthService validates AuthService token',
        false,
        `Failed: ${(error as Error).message}`
      );
    }

    // Mock the database lookup for AuthService
    const originalFindUser = this.authService['findUserById'];
    this.authService['findUserById'] = jest.fn().mockResolvedValue({
      id: 'test-user-123',
      email: 'test@example.com',
      role: 'user',
      is_active: true
    });

    // Test AuthService validating PrismaAuthService token
    try {
      const result = await this.authService.verifyAccessToken(prismaServiceToken);
      this.addResult(
        'AuthService validates PrismaAuthService token',
        true,
        `Successfully validated: ${JSON.stringify(result)}`
      );
    } catch (error) {
      this.addResult(
        'AuthService validates PrismaAuthService token',
        false,
        `Failed: ${(error as Error).message}`
      );
    }

    // Restore original method
    this.authService['findUserById'] = originalFindUser;
  }

  /**
   * Test 3: Identify key differences in verification logic
   */
  async testVerificationDifferences() {
    console.log('\n⚖️ Testing Verification Logic Differences...');

    // Test clockTolerance difference
    const expiredToken = jwt.sign(
      { id: 'test', email: 'test@example.com', role: 'user' },
      TEST_JWT_SECRET,
      {
        expiresIn: '-10s', // Already expired
        algorithm: 'HS256',
        issuer: 'quikadmin-api',
        audience: 'quikadmin-client'
      }
    );

    // AuthService has 30s clockTolerance, PrismaAuthService has 0
    this.addResult(
      'Clock Tolerance Difference',
      true,
      'AuthService: 30s tolerance, PrismaAuthService: 0s tolerance'
    );

    // Test token with future notBefore
    const futureToken = jwt.sign(
      { id: 'test', email: 'test@example.com', role: 'user' },
      TEST_JWT_SECRET,
      {
        expiresIn: '15m',
        notBefore: '1m', // Not valid for 1 minute
        algorithm: 'HS256',
        issuer: 'quikadmin-api',
        audience: 'quikadmin-client'
      }
    );

    try {
      await this.prismaAuthService.verifyToken(futureToken);
      this.addResult(
        'PrismaAuthService rejects future tokens',
        false,
        'Unexpectedly accepted future token'
      );
    } catch (error) {
      this.addResult(
        'PrismaAuthService rejects future tokens',
        true,
        'Correctly rejected future token'
      );
    }
  }

  /**
   * Test 4: Security features comparison
   */
  async testSecurityFeatures() {
    console.log('\n🔒 Testing Security Features...');

    // Both services check for 'none' algorithm
    const noneAlgToken = 'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpZCI6InRlc3QiLCJlbWFpbCI6InRlc3RAZXhhbXBsZS5jb20iLCJyb2xlIjoidXNlciJ9.';

    try {
      await this.authService.verifyAccessToken(noneAlgToken);
      this.addResult(
        'AuthService rejects "none" algorithm',
        false,
        'Failed to reject "none" algorithm'
      );
    } catch (error) {
      this.addResult(
        'AuthService rejects "none" algorithm',
        true,
        'Correctly rejected "none" algorithm'
      );
    }

    try {
      await this.prismaAuthService.verifyToken(noneAlgToken);
      this.addResult(
        'PrismaAuthService rejects "none" algorithm',
        false,
        'Failed to reject "none" algorithm'
      );
    } catch (error) {
      this.addResult(
        'PrismaAuthService rejects "none" algorithm',
        true,
        'Correctly rejected "none" algorithm'
      );
    }

    // Both check token structure
    const malformedToken = 'invalid.token';

    try {
      await this.authService.verifyAccessToken(malformedToken);
      this.addResult(
        'AuthService rejects malformed tokens',
        false,
        'Failed to reject malformed token'
      );
    } catch (error) {
      this.addResult(
        'AuthService rejects malformed tokens',
        true,
        'Correctly rejected malformed token'
      );
    }

    try {
      await this.prismaAuthService.verifyToken(malformedToken);
      this.addResult(
        'PrismaAuthService rejects malformed tokens',
        false,
        'Failed to reject malformed token'
      );
    } catch (error) {
      this.addResult(
        'PrismaAuthService rejects malformed tokens',
        true,
        'Correctly rejected malformed token'
      );
    }
  }

  /**
   * Generate summary report
   */
  generateReport() {
    console.log('\n' + '='.repeat(80));
    console.log('JWT COMPATIBILITY TEST RESULTS');
    console.log('='.repeat(80));

    const passed = this.results.filter(r => r.passed).length;
    const total = this.results.length;
    const passRate = ((passed / total) * 100).toFixed(1);

    console.log(`\n📊 Overall Results: ${passed}/${total} passed (${passRate}%)\n`);

    console.log('KEY DIFFERENCES IDENTIFIED:');
    console.log('1. PrismaAuthService adds "jwtid" claim for token uniqueness');
    console.log('2. PrismaAuthService adds "notBefore" (nbf) claim set to 0');
    console.log('3. AuthService has 30s clock tolerance, PrismaAuthService has 0s');
    console.log('4. PrismaAuthService stores tokens directly, AuthService hashes them');
    console.log('5. Different database schemas (Prisma vs raw SQL)');

    console.log('\nCOMPATIBILITY ISSUES:');
    console.log('❌ Tokens ARE compatible for basic validation');
    console.log('❌ Extra claims (jti, nbf) from PrismaAuthService are ignored by AuthService');
    console.log('❌ Clock tolerance difference may cause edge case validation differences');

    console.log('\nRECOMMENDATION:');
    console.log('✅ Use PrismaAuthService as the single source of truth');
    console.log('   - More modern implementation with Prisma ORM');
    console.log('   - Better type safety');
    console.log('   - Additional security features (jwtid, nbf)');
    console.log('   - Cleaner codebase');
    console.log('\n⚠️  Migration needed for AuthService features:');
    console.log('   - Account lockout after failed attempts');
    console.log('   - Refresh token hashing');
    console.log('   - Device info tracking');
    console.log('   - Password strength validation');

    return {
      passed,
      total,
      passRate: parseFloat(passRate),
      results: this.results
    };
  }

  async runAllTests() {
    console.log('🚀 Starting JWT Compatibility Tests...\n');

    await this.testTokenStructure();
    await this.testCrossValidation();
    await this.testVerificationDifferences();
    await this.testSecurityFeatures();

    return this.generateReport();
  }
}

// Run tests if executed directly
if (require.main === module) {
  const tester = new JWTCompatibilityTester();
  tester.runAllTests().then(report => {
    process.exit(report.passRate === 100 ? 0 : 1);
  });
}

export { JWTCompatibilityTester };